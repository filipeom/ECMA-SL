function initESLSymbolicObject(globalObject, objectPrototype, strict) {
  esl_symbolic := NewECMAScriptObject();
  setAllInternalMethodsOfOrdinaryObject(esl_symbolic);

  internalSymbolicNumber := CreateBuiltInFunctionObject(["type", "var"], "__internalSymbolicNumber", globalObject, strict, null);
  internalSymbolicAssume := CreateBuiltInFunctionObject(["expr"], "__internalSymbolicAssume", globalObject, strict, null);
  internalSymbolicAssert := CreateBuiltInFunctionObject(["expr"], "__internalSymbolicAssert", globalObject, strict, null);

  createBuiltInProperty(esl_symbolic, "number", internalSymbolicNumber);
  createBuiltInProperty(esl_symbolic, "assume", internalSymbolicAssume);
  createBuiltInProperty(esl_symbolic, "assert", internalSymbolicAssert);

  createBuiltInProperty(internalSymbolicNumber, "prototype", objectPrototype);
  createBuiltInProperty(internalSymbolicAssume, "prototype", objectPrototype);
  createBuiltInProperty(internalSymbolicAssert, "prototype", objectPrototype);

  setInternalProperty(esl_symbolic, "Prototype", objectPrototype);

  return esl_symbolic
};


function __internalSymbolicNumber(globalObject, this, NewTarget, strict, params) {
  x := l_nth(params, 1);

  print "trying to create a symbolic variable with name: "; 
  print x; 

  /*
    Criar a variavel simbolica usando o operador ESL correspondente e retorna-la
  */

  fail "symbolic value creation not implemented yet!"
};



function __internalSymbolicAssume(globalObject, this, NewTarget, strict, params) {

  print "trying to assume";

  /*
    Criar a variavel simbolica usando o operador ESL correspondente e retorna-la
  */

  fail "symbolic assume operation implemented yet!"
};



function __internalSymbolicAssert(globalObject, this, NewTarget, strict, params) {

  print "trying to assert";

  /*
    Criar a variavel simbolica usando o operador ESL correspondente e retorna-la
  */

  fail "symbolic assert operation not implemented yet!"
}
