import "Completion.esl"; 
import "Object.esl";
import "Scope.esl";

macro checkAbruptCompletion(c) {
  if (isAbruptCompletion(c)) {
    return c
  } else {
    c := getCompletionValue(c)
  }
};

function interpreter(scope, s) {
	print("........................................");
	match s with
	/* execution statements */
	| { type: "Program", body: body, variableDeclarations: vdecls, functionDeclarations: fdecls } -> 
			{ return program(scope, body, vdecls, fdecls) }
	| { type: "BlockStatement", body: body } -> 
			{ return block_statement(scope, body) }
	| { type: "ReturnStatement", argument: arg } -> 
			{ return return_statement(scope, arg) }
	/* expression statements */
	| { type: "ExpressionStatement", expression: expr } -> 
			{ return interpreter(scope, expr) }
	/* conditional statements */
	| { type: "IfStatement", test: test, consequent: stmt1, alternate: stmt2 } -> 
			{ return if_statement(scope, test, stmt1, stmt2) }
	| { type: "SwitchStatement", discriminant: discriminant, cases: cases } -> 
			{ return switch_statement(scope, discriminant, cases) }
	/* loop statements */
	| { type: "WhileStatement", test: test, body: body } -> 
			{ return while_loop_statement(scope, test, body) }
	
	
	| { type: "ForStatement", init: init, test: test, update: update, body: body } -> 
			{ return for_loop_statement(scope, init, test, update, body) }
	
	
	| { type: "BreakStatement", label: null } ->
			{ return break_statement(scope) }
	
	
	| { type: "ContinueStatement", label: null } ->
			{ return continue_statement(scope) }
	

	| { type: "AssignmentExpression", left: left, right: right, operator: "=" } -> {
        if (left.type = "Identifier") {
          var_name := left.name; 
          rhs := interpreter(scope, right); 
          @checkAbruptCompletion(rhs);
          update_scope(scope, scope, var_name, rhs); 
          return NormalCompletion(rhs)
				} elif (left.type = "MemberExpression") {
					obj_val := interpreter(scope, left.object); 
					@checkAbruptCompletion(obj_val); 
					if (left.computed) {
						/* o[p]*/
						prop_name := interpreter(scope, left.property); 
						@checkAbruptCompletion(prop_name)
					} else {
						/* o.p */
						prop_name := prop.name
					}
					rhs := interpreter(scope, right); 
          @checkAbruptCompletion(rhs);
					update_object(obj_val, prop_name, rhs); 
					return NormalCompletion(rhs)
				} else {
					throw "Illegal Assignment Expression"
				}
	
	| { type: "UnaryExpression", argument: arg, operator: op } -> 
		{ 
			arg_val := interpreter(scope, arg); 
      @checkAbruptCompletion(arg_val); 
			return NormalCompletion(apply_binary_operator(op, arg))
		}
	| { type: "BinaryExpression", left: left, right: right, operator: op } -> 
		{ 
			left_val := interpreter(scope, left); 
      @checkAbruptCompletion(left_val); 
			right_val := interpreter(scope, right);
			@checkAbruptCompletion(right_val);
			return NormalCompletion(apply_binary_operator(op, left_val, right_val)) 
		}
	/* conditional expressions */
	| { type: "ConditionalExpression", test: test, consequent: expr1, alternate: expr2 } -> 
		{ return conditional_expression(scope, test, expr1, expr2) }
	/* function call */
	| { type: "CallExpression", callee: callee, arguments: args } ->
			{ return call_expression(scope, callee, args) }
	| { type: "NewExpression", callee: callee, arguments: args } ->
			{ return new_expression(scope, callee, args) }
	/* logical expressions */
	| { type: "UnaryExpression", argument: arg, operator: "!" } -> 
			{ return logical_expression_not(scope, arg) }
	| { type: "LogicalExpression", left: left, right: right, operator: "||" } -> 
			{ return logical_expression_or(scope, left, right) }
	| { type: "LogicalExpression", left: left, right: right, operator: "&&" } -> 
			{ return logical_expression_and(scope, left, right) }
	/* object expressions */
	| { type: "Property", kind: kind, key: key, value: value, computed: false, shorthand: false } -> 
			{ return object_property(scope, key, value) }
	| { type: "ObjectExpression", properties: props } ->
			{ 
        object := Object();
        foreach (prop : props) {
          prop_name := prop.key.name; 
          prop_value := interpreter(scope, prop.value); 
          if (isAbruptCompletion(prop_value)) {
            return prop_value
          }; 
          object[prop_name] := getCompletionValue(prop_value)
        };
        return NormalCompletion(object)
      }
	| { type: "MemberExpression", object: object, property: prop, computed: true } ->
			{ 
        obj := interpreter(scope, object); 
        @checkAbruptCompletion(obj); 
        prop_name := interpreter(scope, prop);
        @checkAbruptCompletion(prop_name);
        return NormalCompletion(resolve_property(obj, prop_name))
      }
	/* update expressions */
	| { type: "UpdateExpression", argument: arg, operator: "++", prefix: prefix } -> 
		{ return update_expression_inc(scope, arg, prefix) }
	| { type: "UpdateExpression", argument: arg, operator: "--", prefix: prefix } -> 
		{ return update_expression_dec(scope, arg, prefix) }
	/* variable declarations */
	| { type: "VariableDeclarator", id: id, init: init } -> 
		{ return variable_declarator(scope, id, init) }
	| { type: "VariableDeclaration", kind: "var", declarations: decls } -> 
		{ return var_declaration(scope, decls) }
	| { type: "VariableDeclaration", kind: "let", declarations: decls } -> 
		{ return let_declaration(scope, decls) }
	| { type: "VariableDeclaration", kind: "const", declarations: decls } -> 
		{ return const_declaration(scope, decls) }
	/* values */
	| { type: "Literal", raw: raw, value: value } -> 
			{ return NormalCompletion(value) }
	| { type: "Identifier", name: name } -> 
			{ return NormalCompletion(resolve_scope(scope, name)) }
	/* custom empty value (to make our lives easier) */
	| { type: "EmptyValue" } -> { return 'empty }
	| { type: "FunctionExpression", id: null, params: params, body: code } -> 
		{ return FunctionObject(null, params, code, scope) }
	| default -> {
		print("[ERROR]: Found an unsuported statement");
		print(s);
		throw "Unsuported statement" 
	}
};

function program(scope, stmts, vdecls, fdecls) {
  initialize_scope(scope, vdecls, fdecls);
	retval := 'empty;
	count := 0;
	foreach (stmt : stmts) {
		count := count + 1;
    ret := interpreter(scope, stmt);
    if (isAbruptCompletion(ret)) {
      return ret
    }; 
    retvalaux := getCompletionValue(ret); 
    if (!(retvalaux = 'empty)) {
      retval := retvalaux
    };
		print count
  };
  return NormalCompletion(retval)
};

function apply_binary_operator(op, v1, v2) {
	switch(op) {
		case "+": { return v1 + v2 }
		sdefault: { throw "unsupported binary operator" }
	}
};

function apply_unary_operator(op, v) {
	switch(op) {
		sdefault: throw "unsupported unary operator"
	}
}
