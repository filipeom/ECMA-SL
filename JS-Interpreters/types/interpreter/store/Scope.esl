function Scope() {
  scope := {};
  scope.parent := null;
  scope.store := Object();
  scope.this_context := null;
  scope.this_store := scope.store;
  scope.flow_state := 'normal;
  return scope
};



function __initialize_scope_vdecls(scope, vdecls) {
  foreach(vdecl : vdecls) {
    scope.store[vdecl] := 'undefined
  };
  return scope
};

function __initialize_scope_fdecls(scope, fdecls) {
  foreach(fdecl : fdecls) {
    match fdecl with
    | { type: "FunctionExpression", id: id, params: params, body: code } -> {
      match id with
      | { type: "Identifier", name: name } -> {
        scope.store[name] := FunctionObject(name, params, code, scope) }
      | default -> { throw "Invalid function identifier" } }
    | { type: "FunctionDeclaration", id: id, params: params, body: code } -> {
      match id with
      | { type: "Identifier", name: name } -> {
        scope.store[name] := FunctionObject(name, params, code, scope) }
      | default -> { throw "Invalid function identifier" } }
    | default -> {
      print fdecl;
      throw "Unexpected function declaration type"
    }
  };
  return scope
};

function initialize_scope(scope, vdecls, fdecls) {
  scope := __initialize_scope_vdecls(scope, vdecls);
  scope := __initialize_scope_fdecls(scope, fdecls);
  return scope
};



function resolve_id(original_scope, scope, name, must_exist) {
  value := scope.store[name];
  if (value = 'undefined && !(scope.parent = null)) {
    upper_scope := scope.parent.parent_scope;
    return resolve_id(original_scope, upper_scope, name, must_exist)
  };
  if (!(value = 'undefined)) {
    return { store: scope.store, name: name, value: value }
  } elif (!(must_exist)) {
    return { store: original_scope.store, name: name, value: value }
  } else {
    throw "The name is not defined in the current scope"
  }
};

function resolve_left_value(scope, left, must_exist) {
  match left with
  | { type: "Identifier", name: name } -> {
    return resolve_id(scope, scope, name, must_exist)
  }
  | { type: "ThisExpression" } -> {
    return { store: scope.store, name: "this", value: scope.this_store }
  }
  | { type: "MemberExpression", object: object, property: prop, computed: true } -> {
    resolved_object := resolve_left_value(scope, object, true);
    eval_object := resolved_object.value;
    eval_prop := interpreter(scope, prop);
    return resolve_property(eval_object, eval_object, eval_prop, must_exist)
  }
  | default -> {
    throw "Unsuported left value"
  }
}
