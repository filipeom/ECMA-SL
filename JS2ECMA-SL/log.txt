../implementation/test/monitor/level/legal_flows/type_2_inlined.json
undefined
Parsing File...
Parsing... [1/2] 
{ type: 'string', value: 'high' }
{ type: 'boolean', value: true }
{ type: 'string', value: 'low' }
{ type: 'boolean', value: false }
{ type: 'string', value: 'parse_lvl' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'objLev' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'objLev' }
{ type: 'int', value: 0 }
{ type: 'string', value: '_prop_exists_lvl' }
{ type: 'string', value: 'parse_lvl' }
{ type: 'string', value: 'low' }
{ type: 'boolean', value: true }
{ type: 'boolean', value: true }
{ type: 'boolean', value: true }
{ type: 'boolean', value: true }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lub' }
{ type: 'boolean', value: false }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lub' }
{ type: 'boolean', value: true }
{ type: 'string', value: 'structLev' }
{ type: 'string', value: 'objLev' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'shadowPropValue' }
{ type: 'string', value: 'p' }
{ type: 'symbol', value: "'undefined" }
{ type: 'string', value: 'structLev' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'shadowPropExists' }
{ type: 'string', value: 'p' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'p' }
{ type: 'boolean', value: true }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'p' }
{ type: 'boolean', value: true }
{ type: 'string', value: 'parse_lvl' }
{ type: 'string', value: 'high' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'shadowPropValue' }
{ type: 'string', value: 'p' }
{ type: 'symbol', value: "'undefined" }
{ type: 'string', value: 'structLev' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'shadowPropExists' }
{ type: 'string', value: 'p' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'p' }
{ type: 'boolean', value: false }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'p' }
{ type: 'boolean', value: false }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'p' }
{ type: 'string', value: 'shadowPropValue' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lub' }
{ type: 'boolean', value: false }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'parse_lvl' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'shadowPropExists' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'int', value: 0 }
{ type: 'string', value: '_prop_value_lvl' }
{ type: 'boolean', value: true }
{ type: 'string', value: 'parse_lvl' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lubn' }
{ type: 'string', value: 'shadowPropValue' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'int', value: 0 }
{ type: 'string', value: 'parse_lvl' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'structLev' }
{ type: 'string', value: 'leq' }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'structLev' }
{ type: 'int', value: 0 }
{ type: 'string', value: 'LEQQQ' }
{ type: 'int', value: 0 }
{ type: 'boolean', value: false }
{ type: 'string', value: 'lub' }
{ type: 'string', value: 'DEBUGGING LUBN' }
{ type: 'int', value: 1 }
{ type: 'string', value: 'FINAL LUBN' }
Parsing... [2/2] 
Parsing complete.
function parse_lvl (lev_str) {
if([object Object]) {
return true
}else {
if([object Object]) {
return false
}else {
throw MONITOR EXCEPTION -> parselvl - Unkown Security Level
}
}
}
function upgObject (obj,lev_obj,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgObject - Levels must be literals
};
lev_ctx := "lub"( lev_obj, pc );
lev_2 = obj["objLev"];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj["objLev"] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Val Upgrade
};
return [object Object]
}
function shadowPropExists (prop_str) {
result := ([object Object] [object Object]);
return result
}
function main (_pc_1) {
_pc_1 := "parse_lvl"( "low" );
h_lev := true;
l_lev := true;
o_lev := true;
x_lev := true;
_freshvar_0 := "leq"( _pc_1, h_lev );
if(_freshvar_0) {
_fresh_lev_var0 := "lubn"( [object Object] );
h_lev := "lub"( _pc_1, _fresh_lev_var0 );
h := false
}else {
throw MONITOR EXCEPTION -> Illegal Assignment
};
_freshvar_1 := "leq"( _pc_1, l_lev );
if(_freshvar_1) {
_fresh_lev_var1 := "lubn"( [object Object] );
l_lev := "lub"( _pc_1, _fresh_lev_var1 );
l := true
}else {
throw MONITOR EXCEPTION -> Illegal Assignment
};
[object Object];
o["structLev"] := _pc_1;
o["objLev"] := _pc_1;
o_lev := _pc_1;
_fresh_lev_var2 := "lubn"( [object Object] );
_fresh_lev_var3 := "lubn"( [object Object] );
_fresh_lev_var4 := "lubn"( [object Object] );
_freshvar_lev_0 := "lubn"( [object Object] );
_freshvar_3 := "shadowPropValue"( "p" );
_fresh_field_lev_0 = o[_freshvar_3];
if([object Object]) {
_fresh_field_lev_1 = o["structLev"];
_freshvar_2 := "leq"( _freshvar_lev_0, _fresh_field_lev_1 );
if(_freshvar_2) {
_freshvar_4 := "shadowPropExists"( "p" );
_freshvar_lev_1 := "lub"( _freshvar_lev_0, _fresh_lev_var4 );
o[_freshvar_3] := _freshvar_lev_1;
o[_freshvar_4] := _freshvar_lev_0;
o["p"] := true
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
}else {
_freshvar_2 := "leq"( _freshvar_lev_0, _fresh_field_lev_0 );
if(_freshvar_2) {
_freshvar_lev_1 := "lubn"( [object Object] );
o[_freshvar_3] := _freshvar_lev_1;
o["p"] := true
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
};
_freshvar_lev_2 := "parse_lvl"( "high" );
_freshvar_5 := "leq"( _pc_1, h_lev );
if(_freshvar_5) {
h_lev := "lub"( _freshvar_lev_2, _pc_1 )
}else {
throw MONITOR EXCEPTION -> Illegal UpgVarLab
};
_fresh_lev_var8 := "lubn"( [object Object] );
_freshvar_lev_5 := "lub"( _pc_1, _fresh_lev_var8 );
_freshvar_6 := _freshvar_lev_5;
if(h) {
_fresh_lev_var5 := "lubn"( [object Object] );
_fresh_lev_var6 := "lubn"( [object Object] );
_fresh_lev_var7 := "lubn"( [object Object] );
_freshvar_lev_3 := "lubn"( [object Object] );
_freshvar_8 := "shadowPropValue"( "p" );
_fresh_field_lev_2 = o[_freshvar_8];
if([object Object]) {
_fresh_field_lev_3 = o["structLev"];
_freshvar_7 := "leq"( _freshvar_lev_3, _fresh_field_lev_3 );
if(_freshvar_7) {
_freshvar_9 := "shadowPropExists"( "p" );
_freshvar_lev_4 := "lub"( _freshvar_lev_3, _fresh_lev_var7 );
o[_freshvar_8] := _freshvar_lev_4;
o[_freshvar_9] := _freshvar_lev_3;
o["p"] := false
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
}else {
_freshvar_7 := "leq"( _freshvar_lev_3, _fresh_field_lev_2 );
if(_freshvar_7) {
_freshvar_lev_4 := "lubn"( [object Object] );
o[_freshvar_8] := _freshvar_lev_4;
o["p"] := false
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
}
};
_fresh_lev_var9 := "lubn"( [object Object] );
_fresh_lev_var10 := "lubn"( [object Object] );
_fresh_obj_0 := o;
_fresh_field_0 := "p";
_freshvar_10 := "shadowPropValue"( _fresh_field_0 );
_fresh_field_lev_4 = _fresh_obj_0[_freshvar_10];
_freshvar_lev_6 := "lubn"( [object Object] );
_freshvar_11 := "leq"( _freshvar_lev_6, x_lev );
if(_freshvar_11) {
_freshvar_lev_7 := "lub"( _fresh_field_lev_4, _freshvar_lev_6 );
x_lev := _freshvar_lev_7;
x = _fresh_obj_0[_fresh_field_0]
}else {
throw MONITOR EXCEPTION -> Illegal Field Lookup
};
_fresh_lev_var12 := "lubn"( [object Object] );
_freshvar_lev_8 := "lub"( _pc_1, _fresh_lev_var12 );
_freshvar_12 := _freshvar_lev_8;
if(x) {
_freshvar_13 := "leq"( _freshvar_12, l_lev );
if(_freshvar_13) {
_fresh_lev_var11 := "lubn"( [object Object] );
l_lev := "lub"( _freshvar_12, _fresh_lev_var11 );
l := false
}else {
throw MONITOR EXCEPTION -> Illegal Assignment
}
};
_fresh_lev_var13 := "lubn"( [object Object] );
_freshvar_lev_9 := "lub"( _fresh_lev_var13, _pc_1 );
return [object Object]
}
function lub (lev1,lev2) {
return [object Object]
}
function upgPropExists (obj,lev_obj,prop,lev_prop,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgPropExists - Levels must be literals
};
lev_ctx := "lubn"( [object Object] );
prop_2 := "shadowPropExists"( prop );
lev_2 = obj[prop_2];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj[prop_2] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Exists Upgrade
};
return [object Object]
}
function shadowPropValue (prop_str) {
result := ([object Object] [object Object]);
return result
}
function get_top () {
return true
}
function upgPropVal (obj,lev_obj,prop,lev_prop,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgPropExists - Levels must be literals
};
lev_ctx := "lubn"( [object Object] );
prop_2 := "shadowPropValue"( prop );
lev_2 = obj[prop_2];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj[prop_2] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Val Upgrade
};
return [object Object]
}
function upgStruct (obj,lev_obj,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgStruct - Levels must be literals
};
lev_ctx := "lub"( lev_obj, pc );
lev_2 = obj["structLev"];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj["structLev"] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Val Upgrade
};
console.log( pc );
return [object Object]
}
function leq (lev1,lev2) {
console.log( "LEQQQ" );
console.log( lev1 );
console.log( lev2 );
nlev1 := ([object Object] lev1);
nlev2 := ([object Object] lev2);
console.log( nlev1 );
console.log( nlev2 );
aux := [object Object];
console.log( aux );
return [object Object]
}
function lubn (levs) {
i := 0;
acc := false;
while ([object Object])
{acc := "lub"( acc, [object Object] );
console.log( "DEBUGGING LUBN" );
console.log( acc );
i := [object Object]
};
console.log( "FINAL LUBN" );
console.log( acc );
return acc
}
=========== Running ===========
function parse_lvl (lev_str) {
if([object Object]) {
return true
}else {
if([object Object]) {
return false
}else {
throw MONITOR EXCEPTION -> parselvl - Unkown Security Level
}
}
}
function upgObject (obj,lev_obj,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgObject - Levels must be literals
};
lev_ctx := "lub"( lev_obj, pc );
lev_2 = obj["objLev"];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj["objLev"] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Val Upgrade
};
return [object Object]
}
function shadowPropExists (prop_str) {
result := ([object Object] [object Object]);
return result
}
function main (_pc_1) {
_pc_1 := "parse_lvl"( "low" );
h_lev := true;
l_lev := true;
o_lev := true;
x_lev := true;
_freshvar_0 := "leq"( _pc_1, h_lev );
if(_freshvar_0) {
_fresh_lev_var0 := "lubn"( [object Object] );
h_lev := "lub"( _pc_1, _fresh_lev_var0 );
h := false
}else {
throw MONITOR EXCEPTION -> Illegal Assignment
};
_freshvar_1 := "leq"( _pc_1, l_lev );
if(_freshvar_1) {
_fresh_lev_var1 := "lubn"( [object Object] );
l_lev := "lub"( _pc_1, _fresh_lev_var1 );
l := true
}else {
throw MONITOR EXCEPTION -> Illegal Assignment
};
[object Object];
o["structLev"] := _pc_1;
o["objLev"] := _pc_1;
o_lev := _pc_1;
_fresh_lev_var2 := "lubn"( [object Object] );
_fresh_lev_var3 := "lubn"( [object Object] );
_fresh_lev_var4 := "lubn"( [object Object] );
_freshvar_lev_0 := "lubn"( [object Object] );
_freshvar_3 := "shadowPropValue"( "p" );
_fresh_field_lev_0 = o[_freshvar_3];
if([object Object]) {
_fresh_field_lev_1 = o["structLev"];
_freshvar_2 := "leq"( _freshvar_lev_0, _fresh_field_lev_1 );
if(_freshvar_2) {
_freshvar_4 := "shadowPropExists"( "p" );
_freshvar_lev_1 := "lub"( _freshvar_lev_0, _fresh_lev_var4 );
o[_freshvar_3] := _freshvar_lev_1;
o[_freshvar_4] := _freshvar_lev_0;
o["p"] := true
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
}else {
_freshvar_2 := "leq"( _freshvar_lev_0, _fresh_field_lev_0 );
if(_freshvar_2) {
_freshvar_lev_1 := "lubn"( [object Object] );
o[_freshvar_3] := _freshvar_lev_1;
o["p"] := true
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
};
_freshvar_lev_2 := "parse_lvl"( "high" );
_freshvar_5 := "leq"( _pc_1, h_lev );
if(_freshvar_5) {
h_lev := "lub"( _freshvar_lev_2, _pc_1 )
}else {
throw MONITOR EXCEPTION -> Illegal UpgVarLab
};
_fresh_lev_var8 := "lubn"( [object Object] );
_freshvar_lev_5 := "lub"( _pc_1, _fresh_lev_var8 );
_freshvar_6 := _freshvar_lev_5;
if(h) {
_fresh_lev_var5 := "lubn"( [object Object] );
_fresh_lev_var6 := "lubn"( [object Object] );
_fresh_lev_var7 := "lubn"( [object Object] );
_freshvar_lev_3 := "lubn"( [object Object] );
_freshvar_8 := "shadowPropValue"( "p" );
_fresh_field_lev_2 = o[_freshvar_8];
if([object Object]) {
_fresh_field_lev_3 = o["structLev"];
_freshvar_7 := "leq"( _freshvar_lev_3, _fresh_field_lev_3 );
if(_freshvar_7) {
_freshvar_9 := "shadowPropExists"( "p" );
_freshvar_lev_4 := "lub"( _freshvar_lev_3, _fresh_lev_var7 );
o[_freshvar_8] := _freshvar_lev_4;
o[_freshvar_9] := _freshvar_lev_3;
o["p"] := false
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
}else {
_freshvar_7 := "leq"( _freshvar_lev_3, _fresh_field_lev_2 );
if(_freshvar_7) {
_freshvar_lev_4 := "lubn"( [object Object] );
o[_freshvar_8] := _freshvar_lev_4;
o["p"] := false
}else {
throw MONITOR EXCEPTION -> Illegal Field Assign
}
}
};
_fresh_lev_var9 := "lubn"( [object Object] );
_fresh_lev_var10 := "lubn"( [object Object] );
_fresh_obj_0 := o;
_fresh_field_0 := "p";
_freshvar_10 := "shadowPropValue"( _fresh_field_0 );
_fresh_field_lev_4 = _fresh_obj_0[_freshvar_10];
_freshvar_lev_6 := "lubn"( [object Object] );
_freshvar_11 := "leq"( _freshvar_lev_6, x_lev );
if(_freshvar_11) {
_freshvar_lev_7 := "lub"( _fresh_field_lev_4, _freshvar_lev_6 );
x_lev := _freshvar_lev_7;
x = _fresh_obj_0[_fresh_field_0]
}else {
throw MONITOR EXCEPTION -> Illegal Field Lookup
};
_fresh_lev_var12 := "lubn"( [object Object] );
_freshvar_lev_8 := "lub"( _pc_1, _fresh_lev_var12 );
_freshvar_12 := _freshvar_lev_8;
if(x) {
_freshvar_13 := "leq"( _freshvar_12, l_lev );
if(_freshvar_13) {
_fresh_lev_var11 := "lubn"( [object Object] );
l_lev := "lub"( _freshvar_12, _fresh_lev_var11 );
l := false
}else {
throw MONITOR EXCEPTION -> Illegal Assignment
}
};
_fresh_lev_var13 := "lubn"( [object Object] );
_freshvar_lev_9 := "lub"( _fresh_lev_var13, _pc_1 );
return [object Object]
}
function lub (lev1,lev2) {
return [object Object]
}
function upgPropExists (obj,lev_obj,prop,lev_prop,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgPropExists - Levels must be literals
};
lev_ctx := "lubn"( [object Object] );
prop_2 := "shadowPropExists"( prop );
lev_2 = obj[prop_2];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj[prop_2] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Exists Upgrade
};
return [object Object]
}
function shadowPropValue (prop_str) {
result := ([object Object] [object Object]);
return result
}
function get_top () {
return true
}
function upgPropVal (obj,lev_obj,prop,lev_prop,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgPropExists - Levels must be literals
};
lev_ctx := "lubn"( [object Object] );
prop_2 := "shadowPropValue"( prop );
lev_2 = obj[prop_2];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj[prop_2] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Val Upgrade
};
return [object Object]
}
function upgStruct (obj,lev_obj,lev_str,lev_lev_str,pc) {
lev := "parse_lvl"( lev_str );
leq_1 := "leq"( lev_lev_str, pc );
if(([object Object] leq_1)) {
throw MONITOR EXCEPTION -> upgStruct - Levels must be literals
};
lev_ctx := "lub"( lev_obj, pc );
lev_2 = obj["structLev"];
leq_2 := "leq"( lev_ctx, lev_2 );
if(leq_2) {
lev_3 := "lub"( lev_ctx, lev );
obj["structLev"] := lev_3
}else {
throw MONITOR EXCEPTION -> Illegal P_Val Upgrade
};
console.log( pc );
return [object Object]
}
function leq (lev1,lev2) {
console.log( "LEQQQ" );
console.log( lev1 );
console.log( lev2 );
nlev1 := ([object Object] lev1);
nlev2 := ([object Object] lev2);
console.log( nlev1 );
console.log( nlev2 );
aux := [object Object];
console.log( aux );
return [object Object]
}
function lubn (levs) {
i := 0;
acc := false;
while ([object Object])
{acc := "lub"( acc, [object Object] );
console.log( "DEBUGGING LUBN" );
console.log( acc );
i := [object Object]
};
console.log( "FINAL LUBN" );
console.log( acc );
return acc
}
===============================

[]
[]
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAL EXPR
[ 'lev_str' ]
>BLOCK
>CONDITION
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Equal
>BLOCK
>CONDITION
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Equal
>BLOCK
>RETURN
++ VAL EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>PRINT
++ VAL EXPR
PRINT> "LEQQQ"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>PRINT
++ VAR EXPR
PRINT> true/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_And
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ NOPT
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAL EXPR
>MERGE
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>PRINT
++ VAL EXPR
PRINT> "LEQQQ"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>PRINT
++ VAR EXPR
PRINT> true/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_And
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ NOPT
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAL EXPR
>MERGE
>ASSIGN NEW OBJ
>FIELD ASSIGN
++ VAR EXPR
++ VAL EXPR
++ VAR EXPR
>FIELD ASSIGN
++ VAR EXPR
++ VAL EXPR
++ VAR EXPR
>ASSIGN
++ VAR EXPR
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ NOPT
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ NOPT
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
++ VAR EXPR
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>MERGE
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAL EXPR
[ 'prop_str' ]
>BLOCK
>ASSIGN
++ UNOPT
++ NOPT
++ VAR EXPR
++ VAL EXPR
==== ListExpr
==== Sconcat
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: 'p_prop_value_lvl' }
***************************
>FIELD LOOKUP
++ VAR EXPR
++ VAR EXPR
>CONDITION
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Equal
>BLOCK
>FIELD LOOKUP
++ VAR EXPR
++ VAL EXPR
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>PRINT
++ VAL EXPR
PRINT> "LEQQQ"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>PRINT
++ VAR EXPR
PRINT> true/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_And
>PRINT
++ VAR EXPR
PRINT> true/n
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAL EXPR
[ 'prop_str' ]
>BLOCK
>ASSIGN
++ UNOPT
++ NOPT
++ VAR EXPR
++ VAL EXPR
==== ListExpr
==== Sconcat
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: 'p_prop_exists_lvl' }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>FIELD ASSIGN
++ VAR EXPR
++ VAR EXPR
++ VAR EXPR
>FIELD ASSIGN
++ VAR EXPR
++ VAR EXPR
++ VAR EXPR
>FIELD ASSIGN
++ VAR EXPR
++ VAL EXPR
++ VAL EXPR
>MERGE
>MERGE
>ASSIGN CALL
++ VAL EXPR
++ VAL EXPR
[ 'lev_str' ]
>BLOCK
>CONDITION
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Equal
>BLOCK
>RETURN
++ VAL EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>PRINT
++ VAL EXPR
PRINT> "LEQQQ"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>PRINT
++ VAR EXPR
PRINT> true/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_And
>PRINT
++ VAR EXPR
PRINT> true/n
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>MERGE
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> true/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>ASSIGN
++ VAR EXPR
>CONDITION
++ VAR EXPR
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ NOPT
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAR EXPR
>ASSIGN
++ VAL EXPR
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
[ 'prop_str' ]
>BLOCK
>ASSIGN
++ UNOPT
++ NOPT
++ VAR EXPR
++ VAL EXPR
==== ListExpr
==== Sconcat
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: 'p_prop_value_lvl' }
***************************
>FIELD LOOKUP
++ VAR EXPR
++ VAR EXPR
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
++ VAR EXPR
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>MERGE
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>PRINT
++ VAL EXPR
PRINT> "LEQQQ"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>PRINT
++ VAR EXPR
PRINT> true/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_And
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAR EXPR
>FIELD LOOKUP
++ VAR EXPR
++ VAR EXPR
>MERGE
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAR EXPR
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>PRINT
++ VAL EXPR
PRINT> "LEQQQ"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>ASSIGN
++ UNOPT
++ VAR EXPR
==== Not
>PRINT
++ VAR EXPR
PRINT> true/n
>PRINT
++ VAR EXPR
PRINT> true/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_And
>PRINT
++ VAR EXPR
PRINT> true/n
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: true }
***************************
>CONDITION
++ VAR EXPR
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ NOPT
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN
++ VAL EXPR
>MERGE
>MERGE
>ASSIGN CALL
++ VAL EXPR
++ NOPT
++ VAR EXPR
==== ListExpr
[ 'levs' ]
>BLOCK
>ASSIGN
++ VAL EXPR
>ASSIGN
++ VAL EXPR
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>BLOCK
>BLOCK
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Lnth
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>PRINT
++ VAL EXPR
PRINT> "DEBUGGING LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>ASSIGN
++BINOPT
++ VAR EXPR
++ VAL EXPR
==== Plus
>LOOP
>CONDITION
++BINOPT
++ VAR EXPR
++ UNOPT
++ VAR EXPR
==== ListLen
==== Lt
>MERGE
>PRINT
++ VAL EXPR
PRINT> "FINAL LUBN"/n
>PRINT
++ VAR EXPR
PRINT> false/n
>RETURN
++ VAR EXPR
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>ASSIGN CALL
++ VAL EXPR
++ VAR EXPR
++ VAR EXPR
[ 'lev1', 'lev2' ]
>BLOCK
>RETURN
++BINOPT
++ VAR EXPR
++ VAR EXPR
==== Log_Or
*********** RETURN DEBUG *********
PrimitiveVal { value: false }
***************************
>RETURN
++ NOPT
++ VAR EXPR
++ VAR EXPR
==== TupleExpr
TupleVal {
  value: [ PrimitiveVal { value: false }, PrimitiveVal { value: false } ]
}
{"value":[{"value":false},{"value":false}]}
MAIN return -> false,false

asd

