import "ES5_interpreter/ES5_Reference_Interpreter.esl";

function JS_Interpreter_Program(p) {
  /* 14 Program */
  match p with
  | { sourceType: "script", type: "Program", body: SourceElementsopt, strict: strict } -> {
    /* The production Program : SourceElements opt is evaluated as follows: */

    /* 1. The code of this Program is strict mode code if the Directive Prologue (14.1) of its SourceElements
          contains a Use Strict Directive or if any of the conditions of 10.1.1 apply. If the code of this
          Program is strict mode code, SourceElements is evaluated in the following steps as strict mode code.
          Otherwise SourceElements is evaluated in the following steps as non-strict mode code. */

    /* 2. If SourceElements is not present, return (normal, empty, empty). */
    if (SourceElementsopt = []) {
      return normalEmptyCompletion('empty)
    };
    /* 3. Let progCxt be a new execution context for global code as described in 10.4.1. */
    progCxt := EnteringGlobalCode(p);
    |global| := getGlobalObject(getLexicalEnvironment(progCxt)); 
    /* 4. Let result be the result of evaluating SourceElements. */
    result := JS_Interpreter_SourceElements(SourceElementsopt, progCxt);
    /* 5. Exit the execution context progCxt. */

    /* 6. Return result. */
    print progCxt;
    return result
  }
};

function JS_Interpreter_SourceElements(SourceElements, scope) {
  /* The production SourceElements : SourceElements SourceElement is evaluated as follows: */

  i := 0;
  lSourceElements := l_len(SourceElements);
  while (i < lSourceElements) {
    /* 1. Let headResult be the result of evaluating SourceElements. */
    /* 2. If headResult is an abrupt completion, return headResult. */
    /* 3. Let tailResult be result of evaluating SourceElement. */
    /* 4. If tailResult.value is empty, let V = headResult.value, otherwise let V = tailResult.value. */
    result := JS_Interpreter_Stmt(l_nth(SourceElements, i), scope);
    if (isAnAbruptCompletion(result)) {
      return result
    };
    V := getCompletionValue(result);
    i := i + 1
  };
  /* 5. Return (tailResult.type, V, tailResult.target) */
  return newCompletion(getCompletionType(result), V, getCompletionTarget(result))
};

function JS_Interpreter_Expr(e, scope) {
  match e with
  | { type: "ThisExpression" } -> {
    /* 11.1.1 The this Keyword */

    /* The this keyword evaluates to the value of the ThisBinding of the current execution context. */
    return getThisBinding(scope)
  }
  | { type: "Identifier", name: name } -> {
    /* 11.1.2 Identifier Reference */

    /* An Identifier is evaluated by performing Identifier Resolution as specified in 10.3.1. The result of evaluating an
       Identifier is always a value of type Reference. */
    return IdentifierResolution(name, scope)
  }
  | { type: "Literal", value: value } -> {
    /* 11.1.3 Literal Reference */

    /* A Literal is evaluated as described in 7.8. */
    return formingTheValueOfTheNumericLiteral(value)
  }
  | { type: "ArrayExpression", elements: ElementList } -> {
    /* 11.1.4 Array Initialiser */
    arrayPrototype := getArrayPrototype(getGlobalObject(getLexicalEnvironment(scope)), false);
    array := internalNewArray(arrayPrototype, []);
    len := l_len ElementList;
    i := 0;
    while (i < len) {
      el := l_nth (ElementList, i);
      print "ARRAY LOOP. BEGINNING.";

      if (el = null) {
        initValue := 'undefined
      } else {
        initResult := JS_Interpreter_Expr(el, scope);
        initValue := GetValue(initResult)
      };

      print "ARRAY LOOP. GOT THE VALUE"; 
      print initValue; 

      descriptor := newDataPropertyDescriptorFull(initValue, true, true, true);
      {array.DefineOwnProperty}(array, ToString(ToUint32(int_to_float i)), descriptor, false);

      print "Array loop: END"; 
      print i; 
      i := i + 1
    };
    
    return array
  }
  | { type: "ObjectExpression" } -> {
    /* 11.1.5 Object Initialiser */

    /* An object initialiser is an expression describing the initialisation of an Object, written in a form resembling a
       literal. It is a list of zero or more pairs of property names and associated values, enclosed in curly braces. The
       values need not be literals; they are evaluated each time the object initialiser is evaluated. */

    return JS_Interpreter_ObjectInitializer(e, scope)
  }
  | { type: "ProtoAssignment", object: Object, value: Expression } -> {
    /* This pattern match is specific to this implementation and
       does not exist specified in the ES5 standard.
       Was created to test the assignment of a value to the Prototype of an object. */
    objectReference := JS_Interpreter_Expr(Object, scope);
    objectLocation := GetValue(objectReference);
    valueReference := JS_Interpreter_Expr(Expression, scope);
    value := GetValue(valueReference);

    objectLocation.Prototype := value;

    return value
  }
  | { type: "ESLPrint", value: Argument } -> {
    arg := JS_Interpreter_Expr(Argument, scope);
    argValue := GetValue(arg);

    print s_concat ["JSPrint - ", argValue];

    return argValue
  }
  | { type: "MemberExpression", object: MemberExpression, property: Expression } -> {
    /* 11.2.1 Property Accessors */

    /* The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows: */
    /* 1. Let baseReference be the result of evaluating MemberExpression. */
    baseReference := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let baseValue be GetValue(baseReference). */
    baseValue := GetValue(baseReference);
    /* 3. Let propertyNameReference be the result of evaluating Expression. */
    propertyNameReference := JS_Interpreter_Expr(Expression, scope);
    /* 4. Let propertyNameValue be GetValue(propertyNameReference). */
    propertyNameValue := GetValue(propertyNameReference);
    /* 5. Call CheckObjectCoercible(baseValue). */
    CheckObjectCoercible(baseValue);
    /* 6. Let propertyNameString be ToString(propertyNameValue). */
    propertyNameString := ToString(propertyNameValue);
    /* 7. If the syntactic production that is being evaluated is contained in strict mode code,
          let strict be true, else let strict be false. */
    if (isContainedInStrictCode(scope)) {
      strict := true
    } else {
      strict := false
    };
    /* 8. Return a value of type Reference whose base value is baseValue and whose referenced name is
          propertyNameString, and whose strict mode flag is strict. */
    return newPropertyReference(baseValue, propertyNameString, strict)
  }
  | { type: "NewExpression", callee: MemberExpression, arguments: Arguments } -> {
    /* 11.2.2 The new Operator */

    /* The production MemberExpression : new MemberExpression Arguments is evaluated as follows: */

    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let constructor be GetValue(ref). */
    constructor := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(constructor) is not Object, throw a TypeError exception. */
    if (!(Type(constructor) = "Object")) {
      throw TypeErrorException()
    };
    /* 5. If constructor does not implement the [[Construct]] internal method, throw a TypeError exception. */
    if (!("Construct" in_obj constructor)) {
      throw TypeErrorException()
    };
    /* 6. Return the result of calling the [[Construct]] internal method on constructor, providing the list argList as the
          argument values. */
    return Construct(constructor, argList)
  }
  | { type: "CallExpression", callee: MemberExpression, arguments: Arguments } -> {
    /* 11.2.3 Function Calls */

    /* The production CallExpression : MemberExpression Arguments is evaluated as follows: */
    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let func be GetValue(ref). */
    func := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (see 11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(func) is not Object, throw a TypeError exception. */
    if (!(Type(func) = "Object")) {
      throw TypeErrorException()
    };
    /* 5. If IsCallable(func) is false, throw a TypeError exception. */
    if (IsCallable(func) = false) {
      throw TypeErrorException()
    };
    /* 6. If Type(ref) is Reference, then */
    if (Type(ref) = "Reference") {
      /* a. If IsPropertyReference(ref) is true, then */
      if (IsPropertyReference(ref) = true) {
        /* i. Let thisValue be GetBase(ref). */
        thisValue := GetBase(ref)
      }
      /* b. Else, the base of ref is an Environment Record */
      else {
        /* i. Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). */
        thisValue := ImplicitThisValue(GetBase(ref))
      }
    }
    /* 7. Else, Type(ref) is not Reference. */
    else {
      /* a. Let thisValue be undefined. */
      thisValue := 'undefined
    };
    /* 8. Return the result of calling the [[Call]] internal method on func, providing thisValue as the this value
          and providing the list argList as the argument values. */
    return Call(func, thisValue, argList)
  }
  | { type: "FunctionExpression", id: Identifier, params: FormalParameterList, body: FunctionBody } -> {
    /* 11.2.5 Function Expressions */

    /* The production MemberExpression : FunctionExpression is evaluated as follows: */
    /* 1. Return the result of evaluating FunctionExpression. */
    return JS_Interpreter_FunctionExpression(e, scope)
  }
  | { type: "UpdateExpression", prefix: false } -> {
    /* 11.3 Postfix Expressions */
    return JS_Interpreter_PostfixExpressions(e, scope)
  }
  | { type: "UpdateExpression", prefix: true } -> {
    /* 11.4 Unary Operators */
    return JS_Interpreter_UnaryOperator(e, scope)
  }
  | { type: "UnaryExpression", prefix: true } -> {
    /* 11.4 Unary Operators */
    return JS_Interpreter_UnaryOperator(e, scope)
  }
  | { type: "BinaryExpression" } -> {
    return JS_Interpreter_BinExpr(e, scope)
  }
  | { type: "LogicalExpression" } -> {
    /* 11.11 Binary Logical Operators */
    return JS_Interpreter_LogicalExpression(e, scope)
  }
  | { type: "ConditionalExpression", test: LogicalORExpression, consequent: firstAssignmentExpression, alternate: secondAssignmentExpression } -> {
    /* 11.12 Conditional Operator ( ? : ) */

    /* The production ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression is
       evaluated as follows: */

    /* 1. Let lref be the result of evaluating LogicalORExpression. */
    lref := JS_Interpreter_Expr(LogicalORExpression, scope);
    /* 2. If ToBoolean(GetValue(lref)) is true, then */
    if (ToBoolean(GetValue(lref)) = true) {
      /* a. Let trueRef be the result of evaluating the first AssignmentExpression. */
      trueRef := JS_Interpreter_Expr(firstAssignmentExpression, scope);
      /* b. Return GetValue(trueRef). */
      return GetValue(trueRef)
    }
    /* 3. Else */
    else {
      /* a. Let falseRef be the result of evaluating the second AssignmentExpression. */
      falseRef := JS_Interpreter_Expr(secondAssignmentExpression, scope);
      /* b. Return GetValue(falseRef). */
      return GetValue(falseRef)
    }

    /* The ConditionalExpressionNoIn production is evaluated in the same manner as the ConditionalExpression
       production except that the contained LogicalORExpressionNoIn, AssignmentExpression and AssignmentExpressionNoIn
       are evaluated instead of the contained LogicalORExpression, first AssignmentExpression and second AssignmentExpression, respectively. */

    /* NOTE The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java, which
            each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression.
            The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a
            conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression. */
  }
  | { type: "AssignmentExpression" } -> {
    /* 11.13 Assignment Operators */

    /* The AssignmentExpressionNoIn productions are evaluated in the same manner as the AssignmentExpression
       productions except that the contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are evaluated
       instead of the contained ConditionalExpression and AssignmentExpression, respectively. */
    return JS_Interpreter_AssignmentExpression(e, scope)
  }
  | { type: "SequenceExpression", expressions: Expressions } -> {
    /* 11.14 Comma Operator ( , ) */

    /* The production Expression : Expression , AssignmentExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating Expression. */
    /* 2. Call GetValue(lref). */
    /* 3. Let rref be the result of evaluating AssignmentExpression. */
    /* 4. Return GetValue(rref). */
    lExpression := l_len Expressions;
    i := 0;
    while(i < lExpression) {
      ref := JS_Interpreter_Expr(l_nth(Expressions, i), scope);
      val := GetValue(ref);

      i := i + 1
    };

    return val

    /* The ExpressionNoIn production is evaluated in the same manner as the Expression production except that the
        contained ExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained Expression and
        AssignmentExpression, respectively. */

    /* NOTE GetValue must be called even though its value is not used because it may have observable side-effects. */
  }
};

function JS_Interpreter_AssignmentExpression(AssignmentExpression, scope) {
  match AssignmentExpression with
  | { operator: "=", left: LeftHandSideExpression, right: AssignmentExpression } -> {
    /* 11.13.1 Simple Assignment ( = ) */

    /* The production AssignmentExpression : LeftHandSideExpression = AssignmentExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating LeftHandSideExpression. */
    lref := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 3. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 4. Throw a SyntaxError exception if the following conditions are all true: */
      /* Type(lref) is Reference is true */
    if ((Type(lref) = "Reference") &&
      /* IsStrictReference(lref) is true */
        (IsStrictReference(lref)) &&
      /* Type(GetBase(lref)) is Environment Record */
        (Type(GetBase(lref)) = "EnvironmentRecord") &&
      /* GetReferencedName(lref) is either "eval" or "arguments" */
        ((GetReferencedName(lref) = "eval") || (GetReferencedName(lref) = "arguments")))
      {
        throw SyntaxErrorException()
      };
    /* 5. Call PutValue(lref, rval). */
    PutValue(lref, rval, getGlobalObject(getLexicalEnvironment(scope)));
    /* 6. Return rval. */
    return rval

  /* NOTE When an assignment occurs within strict mode code, its LeftHandSide must not evaluate to an unresolvable
          reference. If it does a ReferenceError exception is thrown upon assignment. The LeftHandSide also may not be a
          reference to a data property with the attribute value {[[Writable]]:false}, to an accessor property with the attribute value
          {[[Set]]:undefined}, nor to a non-existent property of an object whose [[Extensible]] internal property has the value false. In
          these cases a TypeError exception is thrown. */
  }
  | { operator: AssignmentOperator, left: LeftHandSideExpression, right: AssignmentExpression } -> {
    /* 11.13.2 Compound Assignment ( op= ) */

    /* The production AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression, where
       AssignmentOperator is @= and @ represents one of the operators indicated above, is evaluated as follows: */

    /* 1. Let lref be the result of evaluating LeftHandSideExpression. */
    lref :=JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of applying operator @ to lval and rval. */
    r := applyOperator(AssignmentOperator, lval, rval);
    /* 6. Throw a SyntaxError exception if the following conditions are all true: */
      /* Type(lref) is Reference is true */
    if ((Type(lref) = "Reference") &&
      /* IsStrictReference(lref) is true */
        (IsStrictReference(lref)) &&
      /* Type(GetBase(lref)) is Environment Record */
        (Type(GetBase(lref)) = "EnvironmentRecord") &&
      /* GetReferencedName(lref) is either "eval" or "arguments" */
        ((GetReferencedName(lref) = "eval") || (GetReferencedName(lref) = "arguments")))
      {
        throw SyntaxErrorException()
      };
    /* 7. Call PutValue(lref, r). */
    PutValue(lref, r, getGlobalObject(getLexicalEnvironment(scope)));
    /* 8. Return r. */
    return r

    /* NOTE See NOTE 11.13.1. */
  }
};

function JS_Interpreter_LogicalExpression(LogicalExpression, scope) {
  match LogicalExpression with
  | { operator: "&&", left: LogicalANDExpression, right: BitwiseORExpression } -> {
    /* The production LogicalANDExpression : LogicalANDExpression && BitwiseORExpression is evaluated as follows:

    /* 1. Let lref be the result of evaluating LogicalANDExpression. */
    lref := JS_Interpreter_Expr(LogicalANDExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. If ToBoolean(lval) is false, return lval. */
    if (ToBoolean(lval) = false) {
      return lval
    };
    /* 4. Let rref be the result of evaluating BitwiseORExpression. */
    rref := JS_Interpreter_Expr(BitwiseORExpression, scope);
    /* 5. Return GetValue(rref). */
    return GetValue(rref)
  }
  | { operator: "||", left: LogicalORExpression, right: LogicalANDExpression } -> {
    /* The production LogicalORExpression : LogicalORExpression || LogicalANDExpression is evaluated as follows:

    /* 1. Let lref be the result of evaluating LogicalORExpression. */
    lref := JS_Interpreter_Expr(LogicalORExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. If ToBoolean(lval) is true, return lval. */
    if (ToBoolean(lval) = true) {
      return lval
    };
    /* 4. Let rref be the result of evaluating LogicalANDExpression. */
    rref := JS_Interpreter_Expr(LogicalANDExpression, scope);
    /* 5. Return GetValue(rref). */
    return GetValue(rref)
  }
};

function JS_Interpreter_UnaryOperator(UnaryExpression, scope) {
  match UnaryExpression with
  | { type: "UnaryExpression", operator: "delete", argument: UnaryExpression } -> {
    /* 11.4.1 The delete Operator */

    /* The production UnaryExpression : delete UnaryExpression is evaluated as follows: */

    /* 1. Let ref be the result of evaluating UnaryExpression. */
    ref := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. If Type(ref) is not Reference, return true. */
    if (!(Type(ref) = "Reference")) {
      return true
    };
    /* 3. If IsUnresolvableReference(ref) then, */
    if (IsUnresolvableReference(ref)) {
      /* a. If IsStrictReference(ref) is true, throw a SyntaxError exception. */
      if (IsStrictReference(ref) = true) {
        throw SyntaxErrorException()
      }
      /* b. Else, return true. */
      else {
        return true
      }
    };
    /* 4. If IsPropertyReference(ref) is true, then */
    if (IsPropertyReference(ref) = true) {
      /* a. Return the result of calling the [[Delete]] internal method on ToObject(GetBase(ref)) providing
            GetReferencedName(ref) and IsStrictReference(ref) as the arguments. */
      return Delete(ToObject(GetBase(ref)), GetReferencedName(ref), IsStrictReference(ref))
    }
    /* 5. Else, ref is a Reference to an Environment Record binding, so */
    else {
      /* a. If IsStrictReference(ref) is true, throw a SyntaxError exception. */
      if (IsStrictReference(ref) = true) {
        throw SyntaxErrorException()
      };
      /* b. Let bindings be GetBase(ref). */
      bindings := GetBase(ref);
      /* c. Return the result of calling the DeleteBinding concrete method of bindings, providing
            GetReferencedName(ref) as the argument. */
      return DeleteBinding(bindings, GetReferencedName(ref))
    }

    /* NOTE When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its
            UnaryExpression is a direct reference to a variable, function argument, or function name.
            In addition, if a delete operator occurs within strict mode code and the property to be deleted has
            the attribute { [[Configurable]]: false }, a TypeError exception is thrown. */
  }
  | { type: "UnaryExpression", operator: "void", argument: UnaryExpression } -> {
    /* 11.4.2 The void Operator */

    /* The production UnaryExpression : void UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Call GetValue(expr). */
    GetValue(expr);
    /* 3. Return undefined. */
    return 'undefined
  }
  | { type: "UnaryExpression", operator: "typeof", argument: UnaryExpression } -> {
    /* 11.4.3 The typeof Operator */

    /* The production UnaryExpression : typeof UnaryExpression is evaluated as follows: */

    /* 1. Let val be the result of evaluating UnaryExpression. */
    val := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. If Type(val) is Reference, then */
    if (Type(val) = "Reference") {
      /* a. If IsUnresolvableReference(val) is true, return "undefined". */
      if (IsUnresolvableReference(val) = true) {
        return "undefined"
      };
      /* b. Let val be GetValue(val). */
      val := GetValue(val)
    };
    /* 3. Return a String determined by Type(val) according to Table 20. */
    if (Type(val) = "Undefined") {
      return "undefined"
    };
    if (Type(val) = "Null") {
      return "object"
    };
    if (Type(val) = "Boolean") {
      return "boolean"
    };
    if (Type(val) = "Number") {
      return "number"
    };
    if (Type(val) = "String") {
      return "string"
    };
    if (Type(val) = "Object") {
      /* Object (native and does not implement [[Call]]) | "object" */
      if (!("Call" in_obj val)) {
        return "object"
      }
      /* Object (native or host and does implement [[Call]]) | "function" */
      else {
        return "function"
      }
    }
  }
  | { type: "UpdateExpression", operator: "++", argument: UnaryExpression, prefix: true } -> {
    /* 11.4.4 Prefix Increment Operator */

    /* The production UnaryExpression : ++ UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(expr) is Reference is true */
      (Type(expr) = "Reference") &&
      /* IsStrictReference(expr) is true */
      (IsStrictReference(expr) = true) &&
      /* Type(GetBase(expr)) is Environment Record */
      (Type(GetBase(expr)) = "EnvironmentRecord") &&
      /* GetReferencedName(expr) is either "eval" or "arguments" */
      ((GetReferencedName(expr) = "eval") || (GetReferencedName(expr) = "arguments"))
    ) {
      throw SyntaxErrorException()
    };
    /* 3. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 4. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator
          (see 11.6.3). */
    newValue := oldValue + 1;
    /* 5. Call PutValue(expr, newValue). */
    PutValue(expr, newValue, getGlobalObject(getLexicalEnvironment(scope)));
    /* 6. Return newValue.*/
    return newValue
  }
  | { type: "UpdateExpression", operator: "--", argument: UnaryExpression, prefix: true } -> {
    /* 11.4.5 Prefix Decrement Operator */

    /* The production UnaryExpression : -- UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(expr) is Reference is true */
      (Type(expr) = "Reference") &&
      /* IsStrictReference(expr) is true */
      (IsStrictReference(expr) = true) &&
      /* Type(GetBase(expr)) is Environment Record */
      (Type(GetBase(expr)) = "EnvironmentRecord") &&
      /* GetReferencedName(expr) is either "eval" or "arguments" */
      ((GetReferencedName(expr) = "eval") || (GetReferencedName(expr) = "arguments"))
    ) {
      throw SyntaxErrorException()
    };
    /* 3. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 4. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the -
          operator (see 11.6.3). */
    newValue := oldValue - 1;
    /* 5. Call PutValue(expr, newValue). */
    PutValue(expr, newValue, getGlobalObject(getLexicalEnvironment(scope)));
    /* 6. Return newValue.*/
    return newValue
  }
  | { type: "UnaryExpression", operator: "+", argument: UnaryExpression } -> {
    /* 11.4.6 Unary + Operator */

    /* The unary + operator converts its operand to Number type. */

    /* The production UnaryExpression : + UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Return ToNumber(GetValue(expr)). */
    return ToNumber(GetValue(expr))
  }
  | { type: "UnaryExpression", operator: "-", argument: UnaryExpression } -> {
    /* 11.4.7 Unary - Operator */

    /* The unary - operator converts its operand to Number type and then negates it. Note that negating +0
       produces -0, and negating -0 produces +0. */

    /* The production UnaryExpression : - UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 3. If oldValue is NaN, return NaN. */
    if (oldValue = NaN) {
      return NaN
    };
    /* 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite
          sign. */
    return -(oldValue)
  }
  | { type: "UnaryExpression", operator: "~", argument: UnaryExpression } -> {
    /* 11.4.8 Bitwise NOT Operator ( ~ ) */

    /* The production UnaryExpression : ~ UnaryExpression is evaluated as follows: */

    /* Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* Let oldValue be ToInt32(GetValue(expr)). */
    oldValue := ToInt32(GetValue(expr));
    /* Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer. */
    return ~oldValue
  }
  | { type: "UnaryExpression", operator: "!", argument: UnaryExpression } -> {
    /* 11.4.9 Logical NOT Operator ( ! ) */

    /* The production UnaryExpression : ! UnaryExpression is evaluated as follows: */

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToBoolean(GetValue(expr)). */
    oldValue := ToBoolean(GetValue(expr));
    /* 3. If oldValue is true, return false. */
    if (oldValue = true) {
      return false
    };
    /* 4. Return true. */
    return true
  }
};

function JS_Interpreter_PostfixExpressions(PostfixExpression, scope) {
  match PostfixExpression with
  | { type: "UpdateExpression", operator: "++", argument: LeftHandSideExpression, prefix: false } -> {
    /* 11.3.1 Postfix Increment Operator */

    /* The production PostfixExpression : LeftHandSideExpression [no LineTerminator here] ++ is evaluated as follows: */

    /* 1. Let lhs be the result of evaluating LeftHandSideExpression. */
    lhs := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(lhs) is Reference is true */
      (Type(lhs) = "Reference") &&
      /* IsStrictReference(lhs) is true */
      (IsStrictReference(lhs) = true) &&
      /* Type(GetBase(lhs)) is Environment Record */
      (Type(GetBase(lhs)) = "EnvironmentRecord") &&
      /* GetReferencedName(lhs) is either "eval" or "arguments" */
      ((GetReferencedName(lhs) = "eval") || (GetReferencedName(lhs) = "arguments"))
    ) {
      throw SyntaxErrorException()
    };
    /* 3. Let oldValue be ToNumber(GetValue(lhs)). */
    oldValue := ToNumber(GetValue(lhs));
    /* 4. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator
          (see 11.6.3). */
    newValue := oldValue + 1;
    /* 5. Call PutValue(lhs, newValue). */
    PutValue(lhs, newValue, getGlobalObject(getLexicalEnvironment(scope)));
    /* 6. Return oldValue. */
    return oldValue
  }
  | { type: "UpdateExpression", operator: "--", argument: LeftHandSideExpression, prefix: false } -> {
    /* 11.3.2 Postfix Decrement Operator */

    /* The production PostfixExpression : LeftHandSideExpression [no LineTerminator here] -- is evaluated as follows: */

    /* 1. Let lhs be the result of evaluating LeftHandSideExpression. */
    lhs := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(lhs) is Reference is true */
      (Type(lhs) = "Reference") &&
      /* IsStrictReference(lhs) is true */
      (IsStrictReference(lhs) = true) &&
      /* Type(GetBase(lhs)) is Environment Record */
      (Type(GetBase(lhs)) = "EnvironmentRecord") &&
      /* GetReferencedName(lhs) is either "eval" or "arguments" */
      ((GetReferencedName(lhs) = "eval") || (GetReferencedName(lhs) = "arguments"))
    ) {
      throw SyntaxErrorException()
    };
    /* 3. Let oldValue be ToNumber(GetValue(lhs)). */
    oldValue := ToNumber(GetValue(lhs));
    /* 4. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the -
          operator (11.6.3). */
    newValue := oldValue - 1;
    /* 5. Call PutValue(lhs, newValue). */
    PutValue(lhs, newValue, getGlobalObject(getLexicalEnvironment(scope)));
    /* 6. Return oldValue. */
    return oldValue
  }
};

function JS_Interpreter_Arguments(ArgumentsList, scope) {
  /* 11.2.4 Argument Lists */
  /* The evaluation of an argument list produces a List of values (see 8.8). */

  /* The production ArgumentList : ArgumentList , AssignmentExpression is evaluated as follows:*/

  args := [];
  lArguments := l_len ArgumentsList;
  i := 0;
  /* 1. Let precedingArgs be the result of evaluating ArgumentList. */
  while(lArguments > i) {
    /* 2. Let ref be the result of evaluating AssignmentExpression. */
    ref := JS_Interpreter_Expr(l_nth(ArgumentsList, i), scope);
    /* 3. Let arg be GetValue(ref). */
    arg := GetValue(ref);

    args := l_add(args, arg);

    i := i + 1
  };

  /* 4. Return a List whose length is one greater than the length of precedingArgs and whose items are the items of
        precedingArgs, in order, followed at the end by arg which is the last item of the new list. */
  return args
};

function JS_Interpreter_FunctionDeclaration(FunctionDeclaration, scope) {
  print "JS_Interpreter_FunctionDeclaration";
  print FunctionDeclaration;
  /* 13 Function Definition */
  match FunctionDeclaration with
  | { id: Identifier, params: FormalParameterListopt, body: FunctionBody } -> {
    /* The production FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Return the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt , and body specified by FunctionBody. Pass in the VariableEnvironment of the running
          execution context as the Scope. Pass in true as the Strict flag if the FunctionDeclaration is contained in
          strict code or if its FunctionBody is strict code. */
    return CreateFunctionObject(FormalParameterListopt, FunctionBody, getVariableEnvironment(scope), isStrictModeCode(FunctionBody, scope))
  }
};

function JS_Interpreter_FunctionExpression(FunctionExpression, scope) {
  /* 13 Function Definition */
  match FunctionExpression with
  | { id: null, params: FormalParameterList, body: FunctionBody } -> {
    /* The production FunctionExpression : function ( FormalParameterList opt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Return the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt and body specified by FunctionBody. Pass in the LexicalEnvironment of the running
          execution context as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in
          strict code or if its FunctionBody is strict code. */
    return CreateFunctionObject(FormalParameterList, FunctionBody, getLexicalEnvironment(scope), isStrictModeCode(FunctionBody, scope))
  }
  | { id: Identifier, params: FormalParameterListopt, body: FunctionBody } -> {
    /* The production FunctionExpression : function Identifier ( FormalParameterList opt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context‘s
          Lexical Environment as the argument. */
    funcEnv := NewDeclarativeEnvironment(getLexicalEnvironment(scope));
    /* 2. Let envRec be funcEnv’s environment record. */
    envRec := getEnvironmentRecord(funcEnv);
    /* 3. Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument. */
    CreateImmutableBinding(envRec, Identifier.name);
    /* 4. Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the
          Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code. */
    closure := CreateFunctionObject(FormalParameterListopt, FunctionBody, funcEnv, isStrictModeCode(FunctionBody, scope));
    /* 5. Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure
          as the arguments. */
    InitializeImmutableBinding(envRec, Identifier.name, closure);
    /* 6. Return closure. */
    return closure


    /* NOTE The Identifier in a FunctionExpression can be referenced from inside the FunctionExpression's FunctionBody to
            allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the Identifier in a
            FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression. */
  }
};

function JS_Interpreter_FunctionBody(FunctionBody, scope) {
  match FunctionBody with
  | { body: SourceElementsopt, strict: strict } -> {
    /* The production FunctionBody : SourceElements opt is evaluated as follows: */

    /* 1. The code of this FunctionBody is strict mode code if it is part of a FunctionDeclaration or
          FunctionExpression that is contained in strict mode code or if the Directive Prologue (14.1)
          of its SourceElements contains a Use Strict Directive or if any of the conditions in 10.1.1 apply.
          If the code of this FunctionBody is strict mode code, SourceElements is evaluated in the following
          steps as strict mode code. Otherwise, SourceElements is evaluated in the following steps as
          non-strict mode code. */
    setContainedInStrictCode(scope, strict);
    /* 2. If SourceElements is present return the result of evaluating SourceElements. */
    if (!(SourceElementsopt = [])) {
      return JS_Interpreter_SourceElements(SourceElementsopt, scope)
    }
    /* 3. Else return (normal, undefined, empty). */
    else {
      return normalEmptyCompletion('undefined)
    }
  }
};

function JS_Interpreter_ObjectInitializer(objExpr, scope) {
  /* 11.1.5 Object Initialiser */
  match objExpr with
  | { type: "ObjectExpression", properties: PropertyNameAndValueList } -> {
    /* The production ObjectLiteral : { } is evaluated as follows: */
    /* Return a new object created as if by the expression new Object() where Object
        is the standard built-in constructor with that name. */
    if (l_len PropertyNameAndValueList = 0) {
      return NewObject()
    };

    /* The production PropertyNameAndValueList : PropertyAssignment is evaluated as follows: */

    /* 1. Let obj be the result of creating a new object as if by the expression new Object()
          where Object is the standard built-in constructor with that name. */
    obj := NewObject();

    /* The production PropertyNameAndValueList : PropertyNameAndValueList , PropertyAssignment is evaluated as follows: */

    /* 1. Let obj be the result of evaluating PropertyNameAndValueList. */
    lPropList := l_len PropertyNameAndValueList;
    i := 0;
    while (i < lPropList) {
      /* 2. Let propId be the result of evaluating PropertyAssignment. */
      propId := JS_Interpreter_PropertyAssignment(l_nth(PropertyNameAndValueList, i), scope);
      /* 3. Let previous be the result of calling the [[GetOwnProperty]] internal method of obj with argument
            propId.name. */
      previous := GetOwnProperty(obj, getPropertyName(propId));
      /* 4. If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true */
      if (!(previous = 'undefined)) {
        /* a. This production is contained in strict code and IsDataDescriptor(previous) is true and
              IsDataDescriptor(propId.descriptor) is true. */
        if (isContainedInStrictCode(scope) &&
            (IsDataPropertyDescriptor(previous) = true) &&
            (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) = true)) {
          throw SyntaxErrorException()
        };
        /* b. IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true. */
        if ((IsDataPropertyDescriptor(previous) = true) &&
            (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) = true)) {
          throw SyntaxErrorException()
        };
        /* c. IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true. */
        if ((IsAccessorPropertyDescriptor(previous) = true) &&
            (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) = true)) {
          throw SyntaxErrorException()
        };
        /* d. IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true and
              either both previous and propId.descriptor have [[Get]] fields or both previous and propId.descriptor
              have [[Set]] fields */
        if ((IsAccessorPropertyDescriptor(previous) = true) &&
            (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) = true) &&
            ((("Get" in_obj previous) && (!(previous.Get = 'undefined)) && ("Get" in_obj getPropertyDescriptor(propId)) && !(getPropertyDescriptor(propId).Get = 'undefined)) ||
             (("Set" in_obj previous) && (!(previous.Set = 'undefined)) && ("Set" in_obj getPropertyDescriptor(propId)) && !(getPropertyDescriptor(propId).Set = 'undefined)))) {
          throw SyntaxErrorException()
        }
      };

      /* 5. Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name, propId.descriptor, and
            false. */
      DefineOwnProperty(obj, getPropertyName(propId), getPropertyDescriptor(propId), false);

      i := i + 1
    };
    /* 6. Return obj. */
    return obj
  }
};

function JS_Interpreter_PropertyAssignment (PropertyAssignment, scope) {
  match PropertyAssignment with
  | { type: "Property", key: PropertyName, value: AssignmentExpression, kind: "init" } -> {
    /* The production PropertyAssignment : PropertyName : AssignmentExpression is evaluated as follows: */

    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let exprValue be the result of evaluating AssignmentExpression. */
    exprValue := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 3. Let propValue be GetValue(exprValue). */
    propValue := GetValue(exprValue);
    /* 4. Let desc be the Property Descriptor{[[Value]]: propValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newDataPropertyDescriptor(propValue);
    /* 5. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc)
  }
  | { type: "Property", key: PropertyName, value: FunctionExpression, kind: "get" } -> {
    /* The production PropertyAssignment : get PropertyName ( ) { FunctionBody } is evaluated as follows: */

    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let closure be the result of creating a new Function object as specified in 13.2 with an empty parameter list
          and body specified by FunctionBody. Pass in the LexicalEnvironment of the running execution context as the
          Scope. Pass in true as the Strict flag if the PropertyAssignment is contained in strict code or if its
          FunctionBody is strict code. */
    closure := JS_Interpreter_FunctionExpression(FunctionExpression, scope);
    /* 3. Let desc be the Property Descriptor{[[Get]]: closure, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newGetAccessorPropertyDescriptor(closure);
    /* 4. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc)
  }
  | { type: "Property", key: PropertyName, value: FunctionExpression, kind: "set" } -> {
    /* The production PropertyAssignment : set PropertyName ( PropertySetParameterList ) { FunctionBody } is
       evaluated as follows: */

    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by
          PropertySetParameterList and body specified by FunctionBody. Pass in the LexicalEnvironment of the
          running execution context as the Scope. Pass in true as the Strict flag if the PropertyAssignment is contained
          in strict code or if its FunctionBody is strict code. */
    closure := JS_Interpreter_FunctionExpression(FunctionExpression, scope);
    /* 3. Let desc be the Property Descriptor{[[Set]]: closure, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newSetAccessorPropertyDescriptor(closure);
    /* 4. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc)
  }
};

function JS_Interpreter_PropertyName(PropertyName, scope) {
  match PropertyName with
  /* The production PropertyName : IdentifierName is evaluated as follows: */
  | { type: "Identifier", name: IdentifierName } -> {
    /* 1. Return the String value containing the same sequence of characters as the IdentifierName. */
    return IdentifierName
  }
  /* The production PropertyName : StringLiteral is evaluated as follows: */
  | { type: "Literal", value: Literal } -> {
    /* Return the SV of the StringLiteral. */
    if (typeof Literal = __$Str) {
      return Literal
    };
    /* The production PropertyName : NumericLiteral is evaluated as follows: */

    /* 1. Let nbr be the result of forming the value of the NumericLiteral. */
    nbr := formingTheValueOfTheNumericLiteral(Literal);
    /* 2. Return ToString(nbr). */
    return ToString(nbr)
  }
};

function JS_Interpreter_Stmt(s, scope) {
  match s with
  | { type: "BlockStatement", body: StatementList } -> {
    /* 12.1 Block */
    if ((l_len StatementList) = 0) {
      return normalEmptyCompletion('empty)
    };

    return JS_Interpreter_StmtList(StatementList, scope)
  }
  | { type: "VariableDeclaration", declarations: VariableDeclarationList } -> {
    /* 12.2 Variable Statement */

    /* The production VariableStatement : var VariableDeclarationList ; is evaluated as follows: */

    i := 0;
    lVarDecl := l_len VariableDeclarationList;
    while(lVarDecl > i) {
      /* 1. Evaluate VariableDeclarationList. */
      JS_Interpreter_VarDecl(l_nth(VariableDeclarationList, i), scope);
      i := i + 1
    };
    /* 2. Return (normal, empty, empty).*/
    return normalEmptyCompletion('empty)
  }
  | { type: "EmptyStatement" } -> {
    return normalEmptyCompletion('empty)
  }
  | { type: "ExpressionStatement", expression: Expression } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (normal, GetValue(exprRef), empty). */
    return normalEmptyCompletion(GetValue(exprRef))
  }
  | { type: "IfStatement", test: Expression, consequent: Statement1, alternate: Statement2 } -> {
    exprRef := JS_Interpreter_Expr(Expression, scope);
    if (ToBoolean(GetValue(exprRef))) {
      return JS_Interpreter_Stmt(Statement1, scope)
    }
    else {
      if (!(Statement2 = null)) {
        return JS_Interpreter_Stmt(Statement2, scope)
      };

      return normalEmptyCompletion('empty)
    }
  }
  | { type: "LabeledStatement", label: Identifier, body: Statement } -> {
    /* 12.12 Labelled Statements */
    /* The production Identifier : Statement is evaluated by adding Identifier to the label set of Statement
      and then evaluating Statement. */
    if (!("labelSet" in_obj Statement)) {
      Statement.labelSet := []
    };
    Statement.labelSet := l_add(Statement.labelSet, Identifier.name);
    /* If the LabelledStatement itself has a non-empty label set, these labels are also added to
       the label set of Statement before evaluating it */
    if ("labelSet" in_obj s) {
      Statement.labelSet := l_concat(s.labelSet, Statement.labelSet)
    };

    return JS_Interpreter_Stmt(Statement, scope)
  }
  /* The label set of an IterationStatement or a SwitchStatement initially contains the single element empty. */
  | { type: "DoWhileStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "WhileStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "ForStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "ForInStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "ContinueStatement", label: Identifier } -> {
    /* 12.7 The continue Statement */
    /* A ContinueStatement without an Identifier is evaluated as follows: */
    if (Identifier = null) {
      /* 1. Return (continue, empty, empty). */
      return newCompletion('continue, 'empty, 'empty)
    };

    /* A ContinueStatement with the optional Identifier is evaluated as follows:
       1. Return (continue, empty, Identifier). */
    return newCompletion('continue, 'empty, Identifier.name)
  }
  | { type: "BreakStatement", label: Identifier } -> {
    /* 12.8 The break Statement */
    /* A BreakStatement without an Identifier is evaluated as follows: */
    if (Identifier = null) {
      /* 1. Return (break, empty, empty). */
      return newCompletion('break, 'empty, 'empty)
    };

    /* A BreakStatement with an Identifier is evaluated as follows:
       1. Return (break, empty, Identifier). */
    return newCompletion('break, 'empty, Identifier.name)
  }
  | { type: "ReturnStatement", argument: Expression } -> {
    /* 12.9 The return Statement */
    /* 1. If the Expression is not present, return (return, undefined, empty). */
    if (Expression = null) {
      return newCompletion('return, 'undefined, 'empty)
    };
    /* 2. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Return (return, GetValue(exprRef), empty). */
    return newCompletion('return, GetValue(exprRef), 'empty)
  }
  | { type: "WithStatement", object: Expression, body: Statement } -> {
    /* 12.10 The with Statement */

    /* The with statement adds an object environment record for a computed object to the lexical environment of
       the current execution context. It then executes a statement using this augmented lexical environment.
       Finally, it restores the original lexical environment. */

    /* The production WithStatement : with ( Expression ) Statement is evaluated as follows: */

    /* 1. Let val be the result of evaluating Expression. */
    val := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let obj be ToObject(GetValue(val)). */
    obj := ToObject(GetValue(val));
    /* 3. Let oldEnv be the running execution context‘s LexicalEnvironment. */
    oldEnv := getLexicalEnvironment(scope);
    /* 4. Let newEnv be the result of calling NewObjectEnvironment passing obj and oldEnv as the arguments. */
    newEnv := NewObjectEnvironment(obj, oldEnv);
    /* 5. Set the provideThis flag of newEnv to true. */
    setProvideThis(newEnv, true);
    /* 6. Set the running execution context‘s LexicalEnvironment to newEnv. */
    setLexicalEnvironment(scope, newEnv);
    /* 7. Let C be the result of evaluating Statement but if an exception is thrown during the evaluation, let C be
          (throw, V, empty), where V is the exception. (Execution now proceeds as if no exception were thrown.) */
    C := JS_Interpreter_Stmt(Statement, scope);
    /* 8. Set the running execution context‘s Lexical Environment to oldEnv. */
    setLexicalEnvironment(scope, oldEnv);
    /* 9. Return C. */
    return C
  }
  | { type: "SwitchStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_SwitchStatement(s, scope)
  }
  | { type: "ThrowStatement", argument: Expression } -> {
    /* 12.13 The throw Statement */
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (throw, GetValue(exprRef), empty). */
    return newCompletion('throw, GetValue(exprRef), 'empty)
  }
  | { type: "TryStatement" } -> {
    /* 12.14 The try Statement */

    /* The try statement encloses a block of code in which an exceptional condition can occur, such as a runtime
       error or a throw statement. The catch clause provides the exception-handling code. When a catch clause
       catches an exception, its Identifier is bound to that exception. */

    return JS_Interpreter_TryStatement(s, scope)
  }
  | { type: "DebuggerStatement" } -> {
    /* 12.15 The debugger statement */

    /* Evaluating the DebuggerStatement production may allow an implementation to cause a breakpoint when run
       under a debugger. If a debugger is not present or active this statement has no observable effect. */

    /* The production DebuggerStatement : debugger ; is evaluated as follows: */

    /* 1. If an implementation defined debugging facility is available and enabled, then */
    if(existsDebuggerImplementation()) {
      /* a. Perform an implementation defined debugging action. */
      /* b. Let result be an implementation defined Completion value. */
      result := debuggerAction()
    }
    /* 2. Else */
    else {
      /* a. Let result be (normal, empty, empty). */
      result := normalEmptyCompletion('empty)
    };
    /* 3. Return result. */
    return result
  }
};

function JS_Interpreter_TryStatement(TryStatement, scope) {
  match TryStatement with
  | { type: "TryStatement", block: Block, handler: Catch, finalizer: null } -> {
    /* The production TryStatement : try Block Catch is evaluated as follows: */

    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 2. If B.type is not throw, return B. */
    if (!(getCompletionType(B) = 'throw)) {
      return B
    };
    /* 3. Return the result of evaluating Catch with parameter B.value. */
    return JS_Interpreter_Catch(Catch, getCompletionValue(B), scope)
  }
  | { type: "TryStatement", block: Block, handler: null, finalizer: Finally } -> {
    /* The production TryStatement : try Block Finally is evaluated as follows: */

    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 2. Let F be the result of evaluating Finally. */
    F := JS_Interpreter_Stmt(Finally, scope);
    /* 3. If F.type is normal, return B. */
    if (getCompletionType(F) = 'normal) {
      return B
    };
    /* 4. Return F. */
    return F
  }
  | { type: "TryStatement", block: Block, handler: Catch, finalizer: Finally } -> {
    /* The production TryStatement : try Block Catch Finally is evaluated as follows: */

    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 2. If B.type is throw, then */
    if (getCompletionType(B) = 'throw) {
      /* a. Let C be the result of evaluating Catch with parameter B.value. */
      C := JS_Interpreter_Catch(Catch, getCompletionValue(B), scope)
    }
    /* 3. Else, B.type is not throw, */
    else {
      /* a. Let C be B. */
      C := B
    };
    /* 4. Let F be the result of evaluating Finally. */
    F := JS_Interpreter_Stmt(Finally, scope);
    /* 5. If F.type is normal, return C. */
    if (getCompletionType(F) = 'normal) {
      return C
    };
    /* 6. Return F. */
    return F
  }
};

function JS_Interpreter_Catch(Catch, parameter, scope) {
  match Catch with
  | { type: "CatchClause", param: Identifier, body: Block } -> {
    /* The production Catch : catch ( Identifier ) Block is evaluated as follows: */

    /* 1. Let C be the parameter that has been passed to this production. */
    C := parameter;
    /* 2. Let oldEnv be the running execution context‘s LexicalEnvironment. */
    oldEnv := getLexicalEnvironment(scope);
    /* 3. Let catchEnv be the result of calling NewDeclarativeEnvironment passing oldEnv as the argument. */
    catchEnv := NewDeclarativeEnvironment(oldEnv);
    /* 4. Call the CreateMutableBinding concrete method of catchEnv passing the Identifier String value as the
          argument. */
    CreateMutableBinding(getEnvironmentRecord(catchEnv), Identifier.name, false); /* TODO the third argument is optional as in the method signature */
    /* 5. Call the SetMutableBinding concrete method of catchEnv passing the Identifier, C, and false as arguments.
          Note that the last argument is immaterial in this situation. */
    SetMutableBinding(getEnvironmentRecord(catchEnv), Identifier.name, C, false);
    /* 6. Set the running execution context‘s LexicalEnvironment to catchEnv. */
    setLexicalEnvironment(scope, catchEnv);
    /* 7. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 8. Set the running execution context‘s LexicalEnvironment to oldEnv. */
    setLexicalEnvironment(scope, oldEnv);
    /* 9. Return B. */
    return B
  }
};

function JS_Interpreter_VarDecl(variableDeclaration, scope) {
  match variableDeclaration with
  | { type: "VariableDeclarator", id: Identifier, init: null } -> {
    /* The production VariableDeclaration : Identifier is evaluated as follows: */

    /* 1. Return a String value containing the same sequence of characters as in the Identifier. */
    /* return Identifier.name */
    return Identifier
  }
  | { type: "VariableDeclarator", id: Identifier, init: Initialiser } -> {
    /* The production VariableDeclaration : Identifier Initialiser is evaluated as follows: */

    /* 1. Let lhs be the result of evaluating Identifier as described in 11.1.2. */
    lhs := JS_Interpreter_Expr(Identifier, scope);
    /* 2. Let rhs be the result of evaluating Initialiser. */
    rhs := JS_Interpreter_Expr(Initialiser, scope);
    /* 3. Let value be GetValue(rhs). */
    value := GetValue(rhs);
    /* 4. Call PutValue(lhs, value). */
    PutValue(lhs, value, getGlobalObject(getLexicalEnvironment(scope)));
    /* 5. Return a String value containing the same sequence of characters as in the Identifier. */
    /* return Identifier.name */
    return Identifier
  }
  | { type: "VariableDeclaration", declarations: VariableDeclarationListNoIn } -> {
    /* Pattern created specifically for the ForInStatement where the VariableDeclarationListNoIn can only contain one VariableDeclarator
       and where the String returned by this function is used in the evaluation of the ForInStatement */
    ret := 'null;
    i := 0;
    ldeclarations := l_len VariableDeclarationListNoIn;
    while (ldeclarations > i) {
      ret := JS_Interpreter_VarDecl(l_nth(VariableDeclarationListNoIn, i), scope);
      i := i + 1
    };

    return ret
  }
};

function JS_Interpreter_StmtList(stmts, scope) {
  V := 'empty;
  i := 0;
  lstmts := l_len stmts;
  while (i < lstmts) {
    stmt := JS_Interpreter_Stmt(l_nth(stmts, i), scope);
    if (isAnAbruptCompletion(stmt)) {
      return stmt
    };
    if (!(getCompletionValue(stmt) = 'empty)) {
      V := getCompletionValue(stmt)
    };
    i := i + 1
  };

  return newCompletion(getCompletionType(stmt), V, getCompletionTarget(stmt))
};

function JS_Interpreter_BinExpr(e, scope) {
  match e with
  /* 11.5 Multiplicative Operators */
  | { type: "BinaryExpression", operator: "*", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the * Operator */
    /* The * operator performs multiplication, producing the product of its operands. Multiplication is commutative.
       Multiplication is not always associative in ECMAScript, because of finite precision.
       The result of a floating-point multiplication is governed by the rules of IEEE 754 binary double-precision
       arithmetic: */

    /* If either operand is NaN, the result is NaN. */
    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* Multiplication of an infinity by a zero results in NaN. */
    /* Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above. */
    /* Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value
       using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign.
       If the magnitude is too small to represent, the result is then a zero of appropriate sign.
       The ECMAScript language requires support of gradual underflow as defined by IEEE 754. */
    return leftNum * rightNum
  }
  | { type: "BinaryExpression", operator: "/", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the / Operator */
    /* The / operator performs division, producing the quotient of its operands. The left operand is the dividend and
       the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all
       division operations are double-precision floating-point numbers. The result of division is determined by the
       specification of IEEE 754 arithmetic: */

    /* If either operand is NaN, the result is NaN. */
    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* Division of an infinity by an infinity results in NaN. */
    /* Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above. */
    /* Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above. */
    /* Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above. */
    /* Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above. */

    /* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and rounded
       to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent,
       the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the
       operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of
       gradual underflow as defined by IEEE 754. */
    return leftNum / rightNum
  }
  | { type: "BinaryExpression", operator: "%", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.3 Applying the % Operator */
    /* The % operator yields the remainder of its operands from an implied division; the left operand is the dividend
       and the right operand is the divisor. */
    /* NOTE In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-
       point operands. */
    /* The result of a floating-point remainder operation as computed by the % operator is not the same as the
       ―remainder‖ operation defined by IEEE 754. The IEEE 754 ―remainder‖ operation computes the remainder
       from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual
       integer remainder operator. Instead the ECMAScript language defines % on floating-point operations to
       behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the
       C library function fmod. */
    /* The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic: */

    /* If either operand is NaN, the result is NaN. */
    /* The sign of the result equals the sign of the dividend. */
    /* If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN. */
    /* If the dividend is finite and the divisor is an infinity, the result equals the dividend. */
    /* If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the
       dividend. */
    /* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the
       floating-point remainder r from a dividend n and a divisor d is defined by the mathematical
       relation r = n  (d  q) where q is an integer that is negative only if n/d is negative and
       positive only if n/d is positive, and whose magnitude is as large as possible without
       exceeding the magnitude of the true mathematical quotient of n and d. r is computed and
       rounded to the nearest representable value using IEEE 754 round -to-nearest mode. */

    return leftNum % rightNum
  }
  /* 11.6 Additive Operators */
  | { type: "BinaryExpression", operator: "+", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* 11.6.1 The Addition operator ( + ) */

    /* The addition operator either performs string concatenation or numeric addition. */

    /* The production AdditiveExpression : AdditiveExpression + MultiplicativeExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lprim be ToPrimitive(lval). */
    lprim := ToPrimitive(lval, "Number");
    /* 6. Let rprim be ToPrimitive(rval). */
    rprim := ToPrimitive(rval, "Number");
    /* 7. If Type(lprim) is String or Type(rprim) is String, then */
    if ((Type(lprim) = "String") || (Type(rprim) = "String")) {
      /* a. Return the String that is the result of concatenating ToString( lprim) followed by ToString(rprim) */
      return s_concat [ToString(lprim), ToString(rprim)]
    };
    /* 8. Return the result of applying the addition operation to ToNumber( lprim) and ToNumber(rprim). See the
          Note below 11.6.3. */
    return applyingTheAdditionOperation(ToNumber(lprim), ToNumber(rprim))

    /* NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6. All native ECMAScript objects
              except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the
              absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner. */

    /* NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the relational operators (11.8.5), by using the
              logical-or operation instead of the logical-and operation. */
  }
  | { type: "BinaryExpression", operator: "-", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* 11.6.2 The Subtraction Operator ( - ) */

    /* The production AdditiveExpression : AdditiveExpression - MultiplicativeExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToNumber(lval). */
    lnum := ToNumber(lval);
    /* 6. Let rnum be ToNumber(rval). */
    rnum := ToNumber(rval);
    /* 7. Return the result of applying the subtraction operation to lnum and rnum.
          See the note below 11.6.3. */
    return applyingTheSubtractionOperation(lnum, rnum)
  }
  /* 11.7 Bitwise Shift Operators */
  | { type: "BinaryExpression", operator: "<<", left: ShiftExpression, right: AdditiveExpression } -> {
    /* 11.7.1 The Left Shift Operator ( << ) */

    /* Performs a bitwise left shift operation on the left operand by the amount specified by the right operand. */

    /* The production ShiftExpression : ShiftExpression << AdditiveExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer. */
    return lnum << shiftCount
  }
  | { type: "BinaryExpression", operator: ">>", left: ShiftExpression, right: AdditiveExpression } -> {
    /* 11.7.2 The Signed Right Shift Operator ( >> ) */

    /* Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the
       right operand. */

    /* The production ShiftExpression : ShiftExpression >> AdditiveExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most
          significant bit is propagated. The result is a signed 32-bit integer. */
    return lnum >> shiftCount
  }
  | { type: "BinaryExpression", operator: ">>>", left: ShiftExpression, right: AdditiveExpression } -> {
    /* 11.7.3 The Unsigned Right Shift Operator ( >>> ) */

    /* Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by
       the right operand. */

    /* The production ShiftExpression : ShiftExpression >>> AdditiveExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are
          filled with zero. The result is an unsigned 32-bit integer. */
    return lnum >>> shiftCount
  }
  /* 11.8 Relational Operators */
  /* The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship
     named by the operator holds between its two operands.
     The RelationalExpressionNoIn productions are evaluated in the same manner as the RelationalExpression
     productions except that the contained RelationalExpressionNoIn is evaluated instead of the contained
     RelationalExpression. */
  | { type: "BinaryExpression", operator: "<", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.1 The Less-than Operator ( < ) */

    /* The production RelationalExpression : RelationalExpression < ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison lval < rval. (see 11.8.5) */
    r := AbstractRelationalComparison(lval, rval, true);
    /* 6. If r is undefined, return false. Otherwise, return r.*/
    if (r = 'undefined) {
      return false
    };

    return r
  }
  | { type: "BinaryExpression", operator: ">", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.2 The Greater-than Operator ( > ) */

    /* The production RelationalExpression : RelationalExpression > ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is undefined, return false. Otherwise, return r. */
    if (r = 'undefined) {
      return false
    };

    return r
  }
  | { type: "BinaryExpression", operator: "<=", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.3 The Less-than-or-equal Operator ( <= ) */

    /* The production RelationalExpression : RelationalExpression <= ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false.
          (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is true or undefined, return false. Otherwise, return true. */
    if ((r = true) || (r = 'undefined)) {
      return false
    };

    return true
  }
  | { type: "BinaryExpression", operator: ">=", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.4 The Greater-than-or-equal Operator ( >= ) */

    /* The production RelationalExpression : RelationalExpression >= ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison lval < rval. (see 11.8.5) */
    r := AbstractRelationalComparison(lval, rval);
    /* 6. If r is true or undefined, return false. Otherwise, return true. */
    if ((r = true) || (r = 'undefined)) {
      return false
    };

    return true
  }
  | { type: "BinaryExpression", operator: "instanceof", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.6 The instanceof operator */

    /* The production RelationalExpression: RelationalExpression instanceof ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. If Type(rval) is not Object, throw a TypeError exception. */
    if (!(Type(rval) = "Object")) {
      throw TypeErrorException()
    };
    /* 6. If rval does not have a [[HasInstance]] internal method, throw a TypeError exception. */
    if ("HasInstance" in_obj rval) {
      throw TypeErrorException()
    };
    /* 7. Return the result of calling the [[HasInstance]] internal method of rval with argument lval. */
    return HasInstance(rval, lval)
  }
  | { type: "BinaryExpression", operator: "in", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.7 The in operator */

    /* The production RelationalExpression : RelationalExpression in ShiftExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. If Type(rval) is not Object, throw a TypeError exception. */
    if (!(Type(rval) = "Object")) {
      throw TypeErrorException()
    };
    /* 6. Return the result of calling the [[HasProperty]] internal method of rval with argument ToString(lval). */
    return HasProperty(rval, ToString(lval))
  }
  /* 11.9 Equality Operators */
  /* The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship
     named by the operator holds between its two operands.
     The EqualityExpressionNoIn productions are evaluated in the same manner as the EqualityExpression
     productions except that the contained EqualityExpressionNoIn and RelationalExpressionNoIn are evaluated
     instead of the contained EqualityExpression and RelationalExpression, respectively. */
  | { type: "BinaryExpression", operator: "==", left: EqualityExpression, right: RelationalExpression } -> {
    /* 11.9.1 The Equals Operator ( == ) */

    /* The production EqualityExpression : EqualityExpression == RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Return the result of performing abstract equality comparison rval == lval. (see 11.9.3). */
    return AbstractEqualityComparison(rval, lval)
  }
  | { type: "BinaryExpression", operator: "!=", left: EqualityExpression, right: RelationalExpression } -> {
    /* 11.9.2 The Does-not-equals Operator ( != ) */

    /* The production EqualityExpression : EqualityExpression != RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract equality comparison rval == lval. (see 11.9.3). */
    r := AbstractEqualityComparison(rval, lval);
    /* 6. If r is true, return false. Otherwise, return true. */
    if (r = true) {
      return false
    };
    return true
  }
  | { type: "BinaryExpression", operator: "===", left: EqualityExpression, right: RelationalExpression } -> {
    /* 11.9.4 The Strict Equals Operator ( === ) */

    /* The production EqualityExpression : EqualityExpression === RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Return the result of performing the strict equality comparison rval === lval. (See 11.9.6) */
    return StrictEqualityComparison(rval, lval)
  }
  | { type: "BinaryExpression", operator: "!==", left: EqualityExpression, right: RelationalExpression } -> {
    /* 11.9.5 The Strict Does-not-equal Operator ( !== ) */

    /* The production EqualityExpression : EqualityExpression !== RelationalExpression is evaluated as follows: */

    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing strict equality comparison rval === lval. (See 11.9.6) */
    r := StrictEqualityComparison(rval, lval);
    /* 6. If r is true, return false. Otherwise, return true. */
    if (r = true) {
      return false
    };
    return true
  }
  /* 11.10 Binary Bitwise Operators */
  | { type: "BinaryExpression", operator: operator, left: A, right: B } -> {
    /* The production A : A @ B, where @ is one of the bitwise operators in the productions above, is evaluated as
      follows: */

    /* 1. Let lref be the result of evaluating A. */
    lref := JS_Interpreter_Expr(A, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating B. */
    rref := JS_Interpreter_Expr(B, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToInt32(rval). */
    rnum := ToInt32(rval);
    /* 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer */
    return applyBitwiseOperator(operator, lnum, rnum)
  }
};

function JS_Interpreter_IterationStatement(iterStmt, scope) {
  match iterStmt with
  | { type: "DoWhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.1 The do-while Statement */
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Let iterating be true. */
    iterating := true;
    /* 3. Repeat, while iterating is true */
    repeat {
      /* a. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* b. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* c. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* d. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* e. If ToBoolean(GetValue(exprRef)) is false, set iterating to false. */
      if (ToBoolean(GetValue(exprRef)) = false) {
        iterating := false
      }
    } until iterating = false;
    /* 4. Return (normal, V, empty); */
    return normalEmptyCompletion(V)
  }
  | { type: "WhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.2 The while Statement */
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Repeat */
    repeat {
      /* a. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* b. If ToBoolean(GetValue(exprRef)) is false, return (normal, V, empty). */
      if (ToBoolean(GetValue(exprRef)) = false) {
        return normalEmptyCompletion(V)
      };
      /* c. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* d. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, then */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
          /* 1. Return (normal, V, empty). */
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
  | { type: "ForStatement", init: Expr_or_VarDecl_or_Null } -> {
    if (Expr_or_VarDecl_or_Null = null) {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope)
    };

    match Expr_or_VarDecl_or_Null with
    | { type: "VariableDeclaration" } -> {
      return JS_Interpreter_ForStmt_VarDecl(iterStmt, scope)
    }
    | default -> {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope)
    }
  }
  | { type: "ForInStatement", left: lhsExpr_or_VarDecl } -> {
    /* 12.6.4 The for-in Statement */
    match lhsExpr_or_VarDecl with
    | { type: "VariableDeclaration", kind: "var" } -> {
      /* production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement */
      return JS_Interpreter_ForInStmt_VarDecl(iterStmt, scope)
    }
    | { type: "Identifier" } -> {
      /* production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement */
      return JS_Interpreter_ForInStmt_lhsExpr(iterStmt, scope)
    }
  }
};

function JS_Interpreter_SwitchStatement(switchStmt, scope) {
  match switchStmt with
  | { type: "SwitchStatement", discriminant: Expression, cases: CaseBlock, labelSet: currentLabelSet } -> {
    /* 12.11 The switch Statement */
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let R be the result of evaluating CaseBlock, passing it GetValue(exprRef) as a parameter. */
    R := JS_Interpreter_CaseBlock(CaseBlock, GetValue(exprRef), scope);
    /* 3. If R.type is break and R.target is in the current label set, return (normal, R.value, empty). */
    if ((getCompletionType(R) = 'break) && (getCompletionTarget(R) in_list currentLabelSet)) {
      return normalEmptyCompletion(getCompletionValue(R))
    };
    /* 4. Return R. */
    return R
  }
};

function JS_Interpreter_ForInStmt_lhsExpr(forInStmt, scope) {
  match forInStmt with
  | { type: "ForInStatement", left: LeftHandSideExpression, right: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* The production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement is evaluated as follows: */

    /* 1. Let exprRef be the result of evaluating the Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let experValue be GetValue(exprRef). */
    experValue := GetValue(exprRef);
    /* 3. If experValue is null or undefined, return (normal, empty, empty). */
    if ((experValue = 'null) || (experValue = 'undefined)) {
      return normalEmptyCompletion('empty)
    };
    /* 4. Let obj be ToObject(experValue). */
    obj := ToObject(experValue);
    /* 5. Let V = empty. */
    V := 'empty;
    /* 6. Repeat */
    i := 0;
    obj_enums := getEnumerableProperties(obj, []);
    repeat {
      /* a. Let P be the name of the next property of obj whose [[Enumerable]] attribute is true.
            If there is no such property, return (normal, V, empty). */
      P := getNextPropertyName(obj_enums, i);
      i := i + 1;
      if (P = "None") {
        return normalEmptyCompletion(V)
      };
      /* b. Let lhsRef be the result of evaluating the LeftHandSideExpression ( it may be evaluated repeatedly). */
      lhsRef := JS_Interpreter_Expr(LeftHandSideExpression, scope);
      /* c. Call PutValue(lhsRef, P). */
      PutValue(lhsRef, P, getGlobalObject(getLexicalEnvironment(scope)));
      /* d. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* e. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* f. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* g. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !(getCompletionTarget(stmt) in_list currentLabelSet)) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
};

function JS_Interpreter_ForInStmt_VarDecl(forInStmt, scope) {
  match forInStmt with
  | { type: "ForInStatement", left: VariableDeclarationNoIn, right: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* The production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement is evaluated as follows: */

    /* 1. Let varName be the result of evaluating VariableDeclarationNoIn. */
    varName := JS_Interpreter_VarDecl(VariableDeclarationNoIn, scope);
    /* 2. Let exprRef be the result of evaluating the Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Let experValue be GetValue(exprRef). */
    experValue := GetValue(exprRef);
    /* 4. If experValue is null or undefined, return (normal, empty, empty). */
    if ((experValue = 'null) || (experValue = 'undefined)) {
      return normalEmptyCompletion('empty)
    };
    /* 5. Let obj be ToObject(experValue). */
    obj := ToObject(experValue);
    /* 6. Let V = empty. */
    V := 'empty;
    /* 7. Repeat */
    i := 0;
    obj_enums := getEnumerableProperties(obj, []);
    repeat {
      /* a. Let P be the name of the next property of obj whose [[Enumerable]] attribute is true.
            If there is no such property, return (normal, V, empty). */
      P := getNextPropertyName(obj_enums, i);
      i := i + 1;
      if (P = "None") {
        return normalEmptyCompletion(V)
      };
      /* b. Let varRef be the result of evaluating varName as if it were an Identifier Reference (11.1.2);
            it may be evaluated repeatedly. */
      varRef := JS_Interpreter_Expr(varName, scope);
      /* c. Call PutValue(varRef, P). */
      PutValue(varRef, P, getGlobalObject(getLexicalEnvironment(scope)));
      /* d. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* e. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* f. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* g. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !(getCompletionTarget(stmt) in_list currentLabelSet)) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
};

function JS_Interpreter_ForStmt_Expr(forStmt, scope) {
  match forStmt with
  | { type: "ForStatement", init: ExpressionNoIn, test: Expression1, update: Expression2, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.3 The for Statement
       The production IterationStatement : for (ExpressionNoIn opt ; Expression opt ; Expression opt ) Statement
       is evaluated as follows: */

    /* 1. If ExpressionNoIn is present, then. */
    if (!(ExpressionNoIn = null)) {
      /* a. Let exprRef be the result of evaluating ExpressionNoIn. */
      exprRef := JS_Interpreter_Expr(ExpressionNoIn, scope);
      /* b. Call GetValue(exprRef). (This value is not used but the call may have side-effects.) */
      GetValue(exprRef)
    };
    /* 2. Let V = empty. */
    V := 'empty;
    /* 3. Repeat */
    repeat {
      /* a. If the first Expression is present, then */
      if (!(Expression1 = null)) {
        /* i. Let testExprRef be the result of evaluating the first Expression. */
        testExprRef := JS_Interpreter_Expr(Expression1, scope);
        /* ii. If ToBoolean(GetValue(testExprRef)) is false, return (normal, V, empty). */
        if (ToBoolean(GetValue(testExprRef)) = false) {
          return normalEmptyCompletion(V)
        }
      };
      /* b. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* c. If stmt.value is not empty, let V = stmt.value */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V = getCompletionValue(stmt)
      };
      /* d. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !((getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* f. If the second Expression is present, then */
      if (!(Expression2 = null)) {
        /* i. Let incExprRef be the result of evaluating the second Expression. */
        incExprRef := JS_Interpreter_Expr(Expression2, scope);
        /* ii. Call GetValue(incExprRef). (This value is not used.) */
        GetValue(incExprRef)
      }
    }
  }
};

function JS_Interpreter_ForStmt_VarDecl(forStmt, scope) {
  match forStmt with
  | { type: "ForStatement", init: VariableDeclarationListNoIn, test: Expression1, update: Expression2, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.3 The for Statement
       The production IterationStatement : for ( var VariableDeclarationListNoIn ; Expression opt ; Expression opt ) Statement
       is evaluated as follows: */

    /* 1. Evaluate VariableDeclarationListNoIn. */
    JS_Interpreter_Stmt(VariableDeclarationListNoIn, scope);
    /* 2. Let V = empty. */
    V := 'empty;
    /* 3. Repeat */
    repeat {
      /* a. If the first Expression is present, then */
      if (!(Expression1 = null)) {
        /* i. Let testExprRef be the result of evaluating the first Expression. */
        testExprRef := JS_Interpreter_Expr(Expression1, scope);
        /* ii. If ToBoolean(GetValue(testExprRef)) is false, return (normal, V, empty). */
        if (ToBoolean(GetValue(testExprRef)) = false) {
          return normalEmptyCompletion(V)
        }
      };
      /* b. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* c. If stmt.value is not empty, let V = stmt.value */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V = getCompletionValue(stmt)
      };
      /* d. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !((getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* f. If the second Expression is present, then */
      if (!(Expression2 = null)) {
        /* i. Let incExprRef be the result of evaluating the second Expression. */
        incExprRef := JS_Interpreter_Expr(Expression2, scope);
        /* ii. Call GetValue(incExprRef). (This value is not used.) */
        GetValue(incExprRef)
      }
    }
  }
};

function JS_Interpreter_CaseBlock(caseBlock, input, scope) {
  /* production CaseBlock : { CaseClauses opt } */
  if (l_nth(caseBlock, 1) = null) {
    casesA := l_nth(caseBlock, 0);
    return JS_Interpreter_CaseBlock_CaseClauses(casesA, input, scope)
  } else {
    /* production CaseBlock : { CaseClauses opt DefaultClause CaseClauses opt } */
    clausesA := l_nth(caseBlock, 0);
    defaultClause := l_nth(caseBlock, 1);
    clausesB := l_nth(caseBlock, 2);
    return JS_Interpreter_CaseBlock_ClausesA_DefaultClause_ClausesB(clausesA, defaultClause, clausesB, input, scope)
  }
};

function JS_Interpreter_CaseBlock_CaseClauses(caseClauses, input, scope) {
  /* 1. Let V = empty. */
  V := 'empty;
  /* 2. Let A be the list of CaseClause items in source text order. */
  A := caseClauses;
  /* 3. Let searching be true. */
  searching := true;
  /* 4. Repeat, while searching is true */
  i := 0;
  repeat {
    /* a. Let C be the next CaseClause in A. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (C = "None") {
      return normalEmptyCompletion(V)
    };
    /* b. Let clauseSelector be the result of evaluating C. */
    clauseSelector := JS_Interpreter_SwitchCase(C, scope);
    /* c. If input is equal to clauseSelector as defined by the === operator, then */
    if (StrictEqualityComparison(GetValue(clauseSelector), GetValue(input))) {
      /* i. Set searching to false. */
      searching := false;
      /* ii. If C has a StatementList, then */
      if (hasStatementList(C)) {
        /* 1. Evaluate C‘s StatementList and let R be the result. */
        R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
        /* 2. If R is an abrupt completion, then return R. */
        if (isAnAbruptCompletion(R)) {
          return R
        };
        /* 3. Let V = R.value. */
        V := getCompletionValue(R)
      }
    }
  } until searching = false;
  /* 5. Repeat */
  i := 0;
  repeat {
    /* a. Let C be the next CaseClause in A. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (C = "None") {
      return normalEmptyCompletion(V)
    };
    /* b. If C has a StatementList, then */
    if (hasStatementList(C)) {
      /* i. Evaluate C‘s StatementList and let R be the result. */
      R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
      /* ii. If R.value is not empty, then let V = R.value. */
      if (!(getCompletionValue(R) = 'empty)) {
        V := getCompletionValue(R)
      };
      /* iii. If R is an abrupt completion, then return (R.type, V, R.target). */
      if (isAnAbruptCompletion(R)) {
        return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
      }
    }
  }
};

function JS_Interpreter_CaseBlock_ClausesA_DefaultClause_ClausesB(clausesA, DefaultClause, clausesB, input, scope) {
  /* 1. Let V = empty. */
  V := 'empty;
  /* 2. Let A be the list of CaseClause items in the first CaseClauses, in source text order. */
  A := clausesA;
  /* 3. Let B be the list of CaseClause items in the second CaseClauses, in source text order. */
  B := clausesB;
  /* 4. Let found be false. */
  found := false;
  /* 5. Repeat letting C be in order each CaseClause in A */
  i := 0;
  repeat {
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (!(C = "None")) {
      /* a. If found is false, then */
      if (found = false) {
        /* i. Let clauseSelector be the result of evaluating C. */
        clauseSelector := JS_Interpreter_SwitchCase(C, scope);
        /* ii. If input is equal to clauseSelector as defined by the === operator, then set found to true. */
        if (StrictEqualityComparison(GetValue(clauseSelector), GetValue(input))) {
          found := true
        }
      };
      /* b. If found is true, then */
      if (found = true) {
        /* i. If C has a StatementList, then */
        if (hasStatementList(C)) {
          /* 1. Evaluate C‘s StatementList and let R be the result. */
          R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
          /* 2. If R.value is not empty, then let V = R.value. */
          if (!(getCompletionValue(R) = 'empty)) {
            V := getCompletionValue(R)
          };
          /* 3. R is an abrupt completion, then return (R.type, V, R.target). */
          if (isAnAbruptCompletion(R)) {
            return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
          }
        }
      }
    }
  } until C = "None";
  /* 6. Let foundInB be false. */
  foundInB := false;
  /* 7. If found is false, then */
  i := 0;
  if (found = false) {
    /* a. Repeat, while foundInB is false and all elements of B have not been processed */
    repeat {
      /* i. Let C be the next CaseClause in B. */
      C := getNextCaseClause(B, i);
      i := i + 1;
      if (!(C = "None")) {
        /* ii. Let clauseSelector be the result of evaluating C. */
        clauseSelector := JS_Interpreter_SwitchCase(C, scope);
        /* iii. If input is equal to clauseSelector as defined by the === operator, then */
        if (StrictEqualityComparison(GetValue(clauseSelector), GetValue(input))) {
          /* 1. Set foundInB to true. */
          foundInB := true;
          /* 2. If C has a StatementList, then */
          if (hasStatementList(C)) {
            /* a  Evaluate C‘s StatementList and let R be the result. */
            R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
            /* b  If R.value is not empty, then let V = R.value. */
            if (!(getCompletionValue(R) = 'empty)) {
              V := getCompletionValue(R)
            };
            /* c  R is an abrupt completion, then return (R.type, V, R.target). */
            if (isAnAbruptCompletion(R)) {
              return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
            }
          }
        }
      }
    } until (foundInB = true) || (C = "None")
  };
  /* 8. If foundInB is false and the DefaultClause has a StatementList, then */
  if ((foundInB = false) && hasStatementList(DefaultClause)) {
    /* a. Evaluate the DefaultClause’s StatementList and let R be the result. */
    R := JS_Interpreter_StmtList(getCaseClauseStatementList(DefaultClause), scope);
    /* b. If R.value is not empty, then let V = R.value. */
    if (!(getCompletionValue(R) = 'empty)) {
      V := getCompletionValue(R)
    };
    /* c. If R is an abrupt completion, then return (R.type, V, R.target). */
    if (isAnAbruptCompletion(R)) {
      return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
    }
  };
  /* 9. Repeat (Note that if step 7.a.i has been performed this loop does not start at the beginning of B) */
  repeat {
    /* a. Let C be the next CaseClause in B. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(B, i);
    i := i + 1;
    if (C = "None") {
      return normalEmptyCompletion(V)
    };
    /* b. If C has a StatementList, then */
    if (hasStatementList(C)) {
      /* i. Evaluate C‘s StatementList and let R be the result. */
      R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
      /* ii. If R.value is not empty, then let V = R.value. */
      if (!(getCompletionValue(R) = 'empty)) {
        V := getCompletionValue(R)
      };
      /* iii. If R is an abrupt completion, then return (R.type, V, R.target). */
      if (isAnAbruptCompletion(R)) {
        return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
      }
    }
  }
};

function JS_Interpreter_SwitchCase(switchCase, scope) {
  match switchCase with
  | { type: "SwitchCase", test: Expression } -> {
    return JS_Interpreter_Expr(Expression, scope)
  }
}
