import "ES5_interpreter/section 8/section_8.esl";


function initJSONPrototype(global, objectPrototype, strict) {
  prototype := NewECMAScriptObjectFull(objectPrototype, "Object", true);
  setAllInternalMethodsOfJSON(prototype)

};

function initJSONLib(global, objectPrototype, strict) {
  objArrayPrototype := initJSONPrototype(global, objectPrototype, strict);

  descriptor := newDataPropertyDescriptorFull(objArrayPrototype, false, false, false);

  return objArrayConstructor
};

/**
 * 15.12.3 stringify ( value [ , replacer [ , space ] ] )
 *
 * The stringify function returns a String in JSON format representing
 * an ECMAScript value. It can take three parameters. The first parameter
 * is required. The value parameter is an ECMAScript value, which is usually
 * an object or array, although it can also be a String, Boolean, Number or
 * null. The optional replacer parameter is either a function that alters
 * the way objects and arrays are stringified, or an array of Strings and
 * Numbers that acts as a white list for selecting the object properties
 * that will be stringified. The optional space parameter is a String or
 * Number that allows the result to have white space injected into it to
 * improve human readability.
 *
 * These are the steps in stringifying an object:
 */
function stringify (global, this, strict, args) {
  value := l_nth(args, 0);
  replacer := l_nth(args, 1);
  space := l_nth(args, 2);

  /* 1. Let stack be an empty List. */
  stack := [];
  /* 2. Let indent be the empty String. */
  indent := "";
  /* 3. Let PropertyList and ReplacerFunction be undefined. */
  PropertyList := 'undefined;
  ReplacerFunction := 'undefined;
  /* 4. If Type(replacer) is Object, then */
  if (Type(replacer) = "Object") {
    /* a. If IsCallable(replacer) is true, then */
    if (IsCallable(replacer) = true) {
      /* i. Let ReplacerFunction be replacer. */
      ReplacerFunction := replacer
    } else {
      /* b. Else if the [[Class]] internal property of replacer is "Array", then */
      if (replacer.Class = "Array") {
        /* i. Let PropertyList be an empty internal List */
        PropertyList := [];
        /* ii. For each value v of a property of replacer that has an array
               index property name. The properties are enumerated in the
               ascending array index order of their names. */
        arrayLen := {replacer.Get}(replacer, "length");
        len := ToUint32(arrayLen);
        k := 0.;
        while (k < len) {

          v := {replacer.Get}(replacer, ToString(k));

          if (!(nextElement = 'undefined) && !(nextElement = 'null)) {

            /* 1. Let item be undefined. */
            item := 'undefined;
            /* 2. If Type(v) is String then let item be v. */
            if (Type(v) = "String") {
              item := v
            }
            /* 3. Else if Type(v) is Number then let item be ToString(v). */
            else {
              if (Type(v) = "Number") {
                item := ToString(v)
              }
              /* 4. Else if Type(v) is Object then, */
              else {
                if (Type(v) = "Object") {
                  /* a. If the [[Class]] internal property of v is "String" or
                        "Number" then let item be ToString(v). */
                  if (v.Class = "String" || v.Class = "Number") {
                    item := ToString(v)
                  }
                }
              }
            };
            /* 5. If item is not undefined and item is not currently an element
                  of PropertyList then, */
            if (!(item = 'undefined) && !(item in_list PropertyList)) {
              /* a. Append item to the end of PropertyList. */
              PropertyList := l_add(PropertyList, item)
            }
          };

          k := k + 1.
        }
      }
    }
  };
  /* 5. If Type(space) is Object then, */
  if (Type(space) = "Object") {
    /* a. If the [[Class]] internal property of space is "Number" then, */
    if (space.Class = "Number") {
      /* i. Let space be ToNumber(space). */
      space := ToNumber(space)
    } else {
    /* b. Else if the [[Class]] internal property of space is "String" then, */
      if (space.Class = "String") {
        /* i. Let space be ToString(space). */
        space := ToString(space)
      }
    }
  };
  /* 6. If Type(space) is Number */
  if (Type(space) = "Number") {
    /* a. Let space be min(10, ToInteger(space)). */
    space := min(10, ToInteger(space))
    /* b. Set gap to a String containing space space characters. This will be
          the empty String if space is less than 1. */
    /* TODO */
  }
  /* 7. Else if Type(space) is String */
  else {
    if (Type(space) = "String") {
      /* a. If the number of characters in space is 10 or less, set gap to space
            otherwise set gap to a String consisting of the first 10 characters of space. */
      /* TODO */
    }
    /* 8. Else */
    else {
      /* a. Set gap to the empty String. */
      gap := ""
    }
  };
  /* 9. Let wrapper be a new object created as if by the expression new Object(),
        where Object is the standard built-in constructor with that name. */
  wrapper := NewObject();
  /* 10. Call the [[DefineOwnProperty]] internal method of wrapper with arguments
         the empty String, the Property Descriptor {[[Value]]: value, [[Writable]]:
         true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
  descriptor := newDataPropertyDescriptorFull(value, true, true, true);
  {wrapper.DefineOwnProperty}(wrapper, "", descriptor, false);
  /* 11. Return the result of calling the abstract operation Str with the empty
         String and wrapper. */
  return Str("", wrapper, ReplacerFunction)
};

/* The abstract operation Str(key, holder) has access to ReplacerFunction
   from the invocation of the stringify method. Its algorithm is as follows: */
function Str(key, holder, ReplacerFunction) {
  /* 1. Let value be the result of calling the [[Get]] internal method
        of holder with argument key. */
  value := {holder.Get}(holder, key);
  /* 2. If Type(value) is Object, then */
  if (Type(value) = "Object") {
    /* a. Let toJSON be the result of calling the [[Get]] internal
          method of value with argument "toJSON". */
    toJSON := {value.Get}(value, "toJSON");
    /* b. If IsCallable(toJSON) is true */
    if (IsCallable(toJSON) = true) {
      /* i. Let value be the result of calling the [[Call]] internal
            method of toJSON passing value as the this value and with
            an argument list consisting of key. */
      value := {toJSON.Call}(toJSON, value, [key])
    }
  };
  /* 3. If ReplacerFunction is not undefined, then */
  if (!(ReplacerFunction = 'undefined)) {
    /* a. Let value be the result of calling the [[Call]] internal
          method of ReplacerFunction passing holder as the this value
          and with an argument list consisting of key and value. */
    value := {ReplacerFunction.Call}(ReplacerFunction, holder, [key, value])
  };
  /* 4. If Type(value) is Object then, */
  if (Type(value) = "Object") {
    /* a. If the [[Class]] internal property of value is "Number" then, */
    if (value.Class = "Number") {
      /* i. Let value be ToNumber(value). */
      value := ToNumber(value)
    }
    /* b. Else if the [[Class]] internal property of value is "String" then, */
    else {
      if (value.Class = "String") {
        /* i. Let value be ToString(value). */
        value := ToString(value)
        /* c. Else if the [[Class]] internal property of value is "Boolean" then, */
      } else {
        if (value.Class = "Boolean") {
          /* i. Let value be the value of the [[PrimitiveValue]] internal property of value. */
          value := value.PrimitiveValue
        }
      }
    }
  };
  /* 5. If value is null then return "null". */
  if (value = 'null) {
    return 'null
  };
  /* 6. If value is true then return "true". */
  if (value = true) {
    return "true"
  };
  /* 7. If value is false then return "false". */
  if (value = false) {
    return "false"
  };
  /* 8. If Type(value) is String, then return the result of calling
        the abstract operation Quote with argument value. */
  if (Type(value) = "String") {
    return Quote(value)
  };
  /* 9. If Type(value) is Number */
  if (Type(value) = "Number") {
    /* a. If value is finite then return ToString(value). */
    if (bla) { /*TODO*/
      return ToString(value)
    }
    /* b. Else, return "null". */
    else {
      return "null"
    }
  };
  /* 10. If Type(value) is Object, and IsCallable(value) is false */
  if ((Type(value) = "Object") && (IsCallable(value) = false)) {
    /* a. If the [[Class]] internal property of value is "Array" then */
    if (value.Class = "Array") {
      /* i. Return the result of calling the abstract operation JA with argument value. */
      return JA(value, stack, indent, gap, space)
    }
    /* b. Else, return the result of calling the abstract operation JO with argument value. */
    else {
      return JO(value, stack, indent, gap, PropertyList, ReplacerFunction, space)
    }
  };
  /* 11. Return undefined. */
  return 'undefined
};




/**
 * The abstract operation Quote(value) wraps a String value in double quotes
 * and escapes characters within it.
 */
function Quote(value) {
  /* 1. Let product be the double quote character. */
  product := ""; /* TODO quote char */
  /* 2. For each character C in value */
  /* TODO */
    /* a. If C is the double quote character or the backslash character */
    if (C = "" || C = "") { /* TODO quote char */
      /* i. Let product be the concatenation of product and the backslash character. */
      product := s_concat([product, ""]);
      /* ii. Let product be the concatenation of product and C. */
      product := s_concat([product, C])
    }
    /* b. Else if C is backspace, formfeed, newline, carriage return, or tab */
    else {
      if (C = "b" || C = "f" || C = "n" || C = "r" || C = "t") { /* TODO */
        /* i. Let product be the concatenation of product and the backslash character. */
        product := s_concat([product, ""]); /* TODO backlash char */
        /* ii. Let abbrev be the character corresponding to the value of C as follows: */
          /*  backspace        "b" */
          /*  formfeed         "f" */
          /*  newline          "n" */
          /*  carriage return  "r" */
          /*  tab              "t" */
        if (C = "b") {
          abbrev := "b"
        };
        if (C = "f") {
          abbrev := "f"
        };
        if (C = "n") {
          abbrev := "n"
        };
        if (C = "r") {
          abbrev := "r"
        };
        if (C = "t") {
          abbrev := "t"
        };
        /* iii. Let product be the concatenation of product and abbrev. */
        product := s_concat([product, abbrev])
      }
      /* c. Else if C is a control character having a code unit value less than the space character */
      else {
        if (ToInteger(C) < ToInteger(" ")) { /* TODO */
          /* i. Let product be the concatenation of product and the backslash character. */
          product := s_concat([product, ""]); /* TODO backlash char */
          /* ii. Let product be the concatenation of product and "u". */
          product := s_concat([product, "u"]);
          /* iii. Let hex be the result of converting the numeric code unit value of
                  C to a String of four hexadecimal digits. */
          /* TODO */

          /* iv. Let product be the concatenation of product and hex. */
          product := s_concat([product, hex])
        }
        /* d. Else */
        else {
          /* i. Let product be the concatenation of product and C. */
          product := s_concat([product, C])
        }
      }
    };
  /* 3. Let product be the concatenation of product and the double quote character. */
  product := s_concat([product, ""]); /* TODO quote char */
  /* 4. Return product. */
  return product
};




/**
 * The abstract operation JO(value) serializes an object. It has access to
 * the stack, indent, gap, PropertyList, ReplacerFunction, and space of the
 * invocation of the stringify method.
 */
function JO(value, stack, indent, gap, PropertyList, ReplacerFunction, space) {
  /* 1. If stack contains value then throw a TypeError exception because
        the structure is cyclical. */
  if (value in_list stack) {
    throw TypeErrorException()
  };
  /* 2. Append value to stack. */
  stack := l_add(stack, value);
  /* 3. Let stepback be indent. */
  stepback := indent;
  /* 4. Let indent be the concatenation of indent and gap. */
  indent := s_concat([indent, gap]);
  /* 5. If PropertyList is not undefined, then */
  if (!(PropertyList = 'undefined)) {
    /* a. Let K be PropertyList. */
    K := PropertyList
  }
  /* 6. Else */
  else {
    /* a. Let K be an internal List of Strings consisting of the names of
          all the own properties of value whose [[Enumerable]] attribute
          is true. The ordering of the Strings should be the same as that
          used by the Object.keys standard built-in function. */
    K := []; /* TODO check if this code is correct */
    namedOwnProperties := getOwnProperties(value);
    lnamedOwnProperties := int_to_float (l_len namedOwnProperties);
    index := 0.;
    while(index < lnamedOwnProperties) {
      P := l_nth(namedOwnProperties, index);
      if (P.Enumerable = true) {
        K := l_add(K, P)
      };
      index := index + 1.
    }
  };
  /* 7. Let partial be an empty List. */
  partial := [];
  /* 8. For each element P of K. */
  i := 0.;
  kLen := l_len K;
  while (i < kLen) {
    /* a. Let strP be the result of calling the abstract operation Str
          with arguments P and value. */
    strP := Str(P, value, ReplacerFunction);
    /* b. If strP is not undefined */
    if (!(strP = 'undefined)) {
      /* i. Let member be the result of calling the abstract operation
            Quote with argument P. */
      member := Quote(P);
      /* ii. Let member be the concatenation of member and the colon character. */
      member := s_concat([member, ":"]);
      /* iii. If gap is not the empty String */
      if (!(gap = "")) {
        /* 1. Let member be the concatenation of member and the space character. */
        member := s_concat([member, " "])
      };
      /* iv. Let member be the concatenation of member and strP. */
      member := s_concat([member, strP]);
      /* v. Append member to partial. */
      partial := l_add(partial, member)
    };
    i := i + 1.
  };
  /* 9. If partial is empty, then */
  if ((l_len partial) = 0.) {
    /* a. Let final be "{}". */
    final := "{}"
  }
  /* 10. Else */
  else {
    /* a. If gap is the empty String */
    if (gap = "") {
      /* i. Let properties be a String formed by concatenating all the
            element Strings of partial with each adjacent pair of Strings
            separated with the comma character. A comma is not inserted either
            before the first String or after the last String. */
      j := 0.;
      pLen := l_len partial;
      properties := "";
      while (j < pLen) {
        el := l_nth(partial, j);
        properties := s_concat([properties, el]);
        if (j < pLen - 1.) {
           properties := s_concat([properties, ","])
        };
        j := j + 1.
      };
      /* ii. Let final be the result of concatenating "{", properties, and "}". */
      final := s_concat(["{", properties, "}"])
    }
    /* b. Else gap is not the empty String */
    else {
      /* i. Let separator be the result of concatenating the comma character,
            the line feed character, and indent. */
      separator := s_concat([",", "n", indent]); /* TODO \n */
      /* ii. Let properties be a String formed by concatenating all the element
             Strings of partial with each adjacent pair of Strings separated
             with separator. The separator String is not inserted either before
             the first String or after the last String. */
      j := 0.;
      pLen := l_len partial;
      properties := "";
      while (j < pLen) {
        el := l_nth(partial, j);
        properties := s_concat([properties, el]);
        if (j < pLen - 1.) {
           properties := s_concat([properties, separator])
        };
        j := j + 1.
      };
      /* iii. Let final be the result of concatenating "{", the line feed
              character, indent, properties, the line feed character, stepback, and "}". */
      final := s_concat(["{", "n", indent, properties, "n", stepback, "}"]) /* TODO \n */
    }
  };
  /* 11. Remove the last element of stack. */
  /* TODO */
  /* 12. Let indent be stepback. */
  indent := stepback;
  /* 13. Return final. */
  return final
};



/**
 * The abstract operation JA(value) serializes an array. It has access to the
 * stack, indent, gap, and space of the invocation of the stringify method. The
 * representation of arrays includes only the elements between zero and
 * array.length – 1 inclusive. Named properties are excluded from the
 * stringification. An array is stringified as an open left bracket, elements
 * separated by comma, and a closing right bracket.
 */
function JA(value, stack, indent, gap, space) {
  /* 1. If stack contains value then throw a TypeError exception because
        the structure is cyclical. */
  if (value in_list stack) {
    throw TypeErrorException()
  };
  /* 2. Append value to stack. */
  stack := l_add(stack, value);
  /* 3. Let stepback be indent. */
  stepback := indent;
  /* 4. Let indent be the concatenation of indent and gap. */
  indent := s_concat([indent, gap]);
  /* 5. Let partial be an empty List. */
  partial := [];
  /* 6. Let len be the result of calling the [[Get]] internal method of
        value with argument "length". */
  len := {value.Get}(value, "length");
  /* 7. Let index be 0. */
  index := 0.;
  /* 8. Repeat while index < len */
  while (index < len) {
    /* a. Let strP be the result of calling the abstract operation Str
          with arguments ToString(index) and value. */
    strP := Str(ToString(index), value, 'undefined);
    /* b. If strP is undefined */
    if (strP = 'undefined) {
      /* i. Append "null" to partial. */
      partial := l_add(partial, 'null)
    }
    /* c. Else */
    else {
      /* i. Append strP to partial. */
      partial := l_add(partial, strP)
    };
    /* d. Increment index by 1. */
    index := index + 1.
  };
  /* 9. If partial is empty ,then */
  if ((l_len partial) = 0.) {
    /* a. Let final be "[]". */
    final := "[]"
  }
  /* 10. Else */
  else {
    /* a. If gap is the empty String */
    if (gap = "") {
      /* i. Let properties be a String formed by concatenating all the element
            Strings of partial with each adjacent pair of Strings separated with
            the comma character. A comma is not inserted either before the first
            String or after the last String. */
      j := 0.;
      pLen := l_len partial;
      properties := "";
      while (j < pLen) {
        el := l_nth(partial, j);
        properties := s_concat([properties, el]);
        if (j < pLen - 1.) {
           properties := s_concat([properties, ","])
        };
        j := j + 1.
      };
      /* ii. Let final be the result of concatenating "[", properties, and "]". */
      final := s_concat(["[", properties, "]"])
    }
    /* b. Else */
    else {
      /* i. Let separator be the result of concatenating the comma character,
            the line feed character, and indent. */
      separator := s_concat([",", "n", indent]); /* TODO \n */
      /* ii. Let properties be a String formed by concatenating all the element
             Strings of partial with each adjacent pair of Strings separated with
             separator. The separator String is not inserted either before the
             first String or after the last String. */
      j := 0.;
      pLen := l_len partial;
      properties := "";
      while (j < pLen) {
        el := l_nth(partial, j);
        properties := s_concat([properties, el]);
        if (j < pLen - 1.) {
           properties := s_concat([properties, separator])
        };
        j := j + 1.
      };
      /* iii. Let final be the result of concatenating "[", the line feed character,
              indent, properties, the line feed character, stepback, and "]". */
      final := s_concat(["[", "n", indent, properties, "n", stepback, "]"]) /* TODO \n */
    }
  };
  /* 11. Remove the last element of stack. */
  /* TODO */
  /* 12. Let indent be stepback. */
  indent := stepback;
  /* 13. Return final. */
  return final
};




function main() {

}