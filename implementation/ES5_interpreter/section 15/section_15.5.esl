import "ES5_interpreter/section 9/section_9.esl";
import "ES5_interpreter/section 8/section_8.7.esl";
import "ES5_interpreter/section 8/section_8.10.esl";
import "ES5_interpreter/section 8/section_8.12.esl";
import "ES5_interpreter/section 10/section_10.2.esl";
import "ES5_interpreter/section 10/section_10.3.esl";
import "ES5_interpreter/section 10/section_10.4.esl";
import "ES5_interpreter/section 10/section_10.5.esl";
import "ES5_interpreter/section 13/section_13.esl";
import "ES5_interpreter/section 15/section_15.11.esl";
/* import "ES5_interpreter/ES5_Reference_Interpreter.esl"; */

/* This method is not supposed to be here. As soon
   as it is placed in the right section, it should
   be replaced by an import of that section. */
function Type(V) {
  v_type := typeof V;
  if (v_type = __$Int) { return "Number" };
  if (v_type = __$Flt) { return "Number" };
  if (v_type = __$Bool) { return "Boolean" };
  if (v_type = __$Str) { return "String" };
  if (v_type = __$Obj) { return "Object" };
  if (v_type = __$List) { return "List" };
  if (v_type = __$Null) { return "Null" };
  if (v_type = __$Symbol) {
    if (V = 'undefined) { return "Undefined" };
    if (V = 'NaN) { return "Number" };
    if ((V = '+0) || (V = '-0)) { return "Number" };
    if ((V = '+Infinity) || (V = 'Infinity) || (V = '-Infinity)) { return "Number" }
  };
  if (v_type = __$Tuple) {
    ft := fst V;
    if (ft = "R") { return "Reference" };
    if (ft = "C") { return "Completion" }
  };

  throw SyntaxErrorException()
};

function IsPrimitiveValue (v) {
  v_type := Type(v); 
  if (v_type = "Object") {
    return false
  } else {
    return true
  } 
};


/* Placeholder */
function getStringPrototypeObject(global) {
  refString := newPropertyReference(global, "String", true);
  print "RefString After";
  print refString;
  print global;
  print global.String;
  StringConstructor := GetValue(refString);
  print "StringConstructor Found";
  print StringConstructor.prototype;
  refStringPrototype := newPropertyReference(StringConstructor, "prototype", false);
  print "refStringPrototype Found";
  print refStringPrototype;
  StringPrototype := GetValue(refStringPrototype);
  print "StringPrototype found";

  return StringPrototype

};

function ToPrimitive(input, PreferredType) {
  if (Type(input) = "Object") {
    return DefaultValue(input, PreferredType)
  };

  return input
};

function ToInteger(V) {
  number := ToNumber(V);
  return number
};
function max(a, b) {
  if (a > b) {
    return a
  } else {
    return b
  }
};
function min(a, b) {
  if (a < b) {
    return a
  } else {
    return b
  }
};
function abs(a) {
  if (a < 0.) {
    return a*-1
  } else {
    return a
  }
};

function initStringLib(global, functionPrototype, objectPrototype, strict){
  stringPrototype := initalNewString(objectPrototype);

  concatFunctionObject:= CreateFunctionObject( [ "args" ], "StringPrototypeconcat", global, strict);
  stringPrototype.concat := newDataPropertyDescriptor( concatFunctionObject );
  stringPrototype.Get := "Get";

  toStringFunctionObject:= CreateFunctionObject( [ "args" ], "StringPrototypeToString", global, strict);
  stringPrototype.toString := newDataPropertyDescriptor( toStringFunctionObject );

  StringConstructor := CreateFunctionObject( [ "args" ], "StringConstructor", global, strict);
  StringConstructor.prototype := newDataPropertyDescriptorFull( stringPrototype, false, false, false );
  StringConstructor.Get := "Get";

  global.String := newDataPropertyDescriptor( StringConstructor);
  return global


};


/* 15.5 String Objects */


/* 15.5.1.1 String ( [ value ] ) */

function String (global, this, args) {
  value := l_nth(args, 0);
  if (value = 'undefined) {
    return ""
  } else {
    return ToString(value)
  }
};


/* 15.5.2.1 new String ( [ value ] ) */

function initalNewString (objectPrototype){
  ret := {
    /* The [[Prototype]] internal property of the newly constructed object is set to the standard built-in String
     prototype object that is the initial value of String.prototype (15.5.3.1). */
    Prototype: objectPrototype,
    /* The [[Class]] internal property of the newly constructed object is set to "String". */
    Class: "String",
    /* The [[Extensible]] internal property of the newly constructed object is set to true. */
    Extensible: true,
    Put: "Put",
    Get: "Get",
    HasProperty: "HasProperty",
    DefineOwnProperty: "DefineOwnProperty",
    GetOwnProperty: "GetOwnPropertyString",
    Delete: "Delete",
    PrimitiveValue: ""
  };
  return ret
};


function StringConstructor (global, this, args) {
  value := l_nth(args, 0);
  print "Before StringPrototype";
  StringPrototype := getStringPrototypeObject(global);
  print "Found StringPrototype";
  ret := {
    /* The [[Prototype]] internal property of the newly constructed object is set to the standard built-in String
     prototype object that is the initial value of String.prototype (15.5.3.1). */
    Prototype: getStringPrototypeObject(global),
    /* The [[Class]] internal property of the newly constructed object is set to "String". */
    Class: "String",
    /* The [[Extensible]] internal property of the newly constructed object is set to true. */
    Extensible: true,
    Put: "Put",
    Get: "Get",
    HasProperty: "HasProperty",
    DefineOwnProperty: "DefineOwnProperty",
    GetOwnProperty: "GetOwnPropertyString",
    Delete: "Delete"
  };
  /* The [[PrimitiveValue]] internal property of the newly constructed object is set to ToString(value),
     or to the empty String if value is not supplied. */
  if (value = 'undefined) {
    ret.PrimitiveValue := ""
  } else {
    ret.PrimitiveValue := ToString(value)
  };

  ret.properties := {};

  return ret
};


/* 15.5.3.1 String.prototype  */


/*

{
  Value: ""
  Writable: false,
  Enumerable: false,
  Configurable: false
}

*/

/* 15.5.3.2 String.fromCharCode ( [char0 [, char1 [, ... ]]]) */


/* 15.5.4 Properties of the String Prototype Object */
/* Verificar o true */
/* function String.prototype(){
  ret := {
    Prototype: "Object.Prototype",
    Class: "String",
    Extensible: true,
    PrimitiveValue: ""
  };
  return ret
};
*/

/* 15.5.4.1 String.prototype.constructor */

/* 15.5.4.2 String.prototype.toString() */
function StringPrototypeToString (global, this, args) { 
  return this.PrimitiveValue
};



/* 15.5.4.4 String.prototype.charAt (pos) */
/*  Returns a String containing the character at position pos in the String resulting from converting this object to a String.
If there is no character at that position, the result is the empty String. The result is a String value, not a String object.

If pos is a value of Number type that is an integer, then the result of x.charAt( pos) is equal to the result of x.substring( pos, pos+1).

When the charAt method is called with one argument pos, the following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let position be ToInteger(pos).

    Let size be the number of characters in S.

    If position < 0 or position ≥ size, return the empty String.

    Return a String of length 1, containing one character from S, namely the character at position position,
    where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on.

NOTE The charAt function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method. */

function StringPrototypecharAt(global, this, args){
  pos := l_nth(args, 0);
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let position be ToInteger(pos). */
  position := ToInteger(pos);
  /* Let size be the number of characters in S. */
  size := s_len S;
  /* If position < 0 or position ≥ size, return the empty String. */
  if ((position < 0) || (position >= size)){
    return ""
  };
  /* Return a String of length 1, containing one character from S, namely the character at position position
  where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on.*/
  return newString(global, this, [ s_nth (S, position)]) /* To Do */
};

/* 15.5.4.5 String.prototype.charCodeAt (pos) */

/*Returns a Number (a nonnegative integer less than 2^16) representing the code unit value of the character at position pos in the String resulting from converting this object to a String. If there is no character at that position, the result is NaN.

When the charCodeAt method is called with one argument pos, the following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let position be ToInteger(pos).

    Let size be the number of characters in S.

    If position < 0 or position ≥ size, return NaN.

    Return a value of Number type, whose value is the code unit value of the character at position position
     in the String S, where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on.

NOTE The charCodeAt function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypecharCodeAt (global, this, args){
  pos := l_nth(args,0);
  /*Call CheckObjectCoercible passing the this value as its argument.*/
  CheckObjectCoercible(this);
  /*Let S be the result of calling ToString, giving it the this value as its argument.*/
  S := int_of_float(ToString(this));
  /*Let position be ToInteger(pos).*/
  position := int_of_float(ToInteger(pos));
  /*Let size be the number of characters in S.*/
  size := s_len S;
  /* If position < 0 or position ≥ size, return NaN. */
  if (position < 0 || position >= size){
    return 'NaN
  }
  /*     Return a value of Number type, whose value is the code unit value of the character at position position
       in the String S, where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on. */
  /* To Do */
};

/*15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , … ] ] ] )  */
/*
When the concat method is called with zero or more arguments string1, string2, etc., it returns a String consisting of the characters of this object (converted to a String) followed by the characters of each of string1, string2, etc. (where each argument is converted to a String). The result is a String value, not a String object. The following steps are taken:

   Call CheckObjectCoercible passing the this value as its argument.

   Let S be the result of calling ToString, giving it the this value as its argument.

   Let args be an internal list that is a copy of the argument list passed to this function.

   Let R be S.

   Repeat, while args is not empty

       Remove the first element from args and let next be the value of that element.

       Let R be the String value consisting of the characters in the previous value of R followed by the characters of ToString(next).

   Return R.

The length property of the concat method is 1.

NOTE The concat function is intentionally generic; it does not require that its this value be a String object.
Therefore it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypeconcat(global, this, args){
  /*Call CheckObjectCoercible passing the this value as its argument.*/
  CheckObjectCoercible(this);
  /*Let S be the result of calling ToString, giving it the this value as its argument.*/
  print("Inside String Prototype Concat ");
  S := ToString(this);
  print(s_concat ["Inside String Prototype Concat: ", S]);
  /* Let args be an internal list that is a copy of the argument list passed to this function. */
  /* TO DO, both require args name) */
  args_ := args;
  /* Let R be S. */
  R := S;
  /* Repeat, while args is not empty */
  while (!(args_ = [])){
    /* Remove the first element from args and let next be the value of that element. */
    next  := hd args_;
    args_ := tl args_;
    /* Let R be the String value consisting of the characters in the previous value of R followed by the characters of ToString(next). */
    R := s_concat([R, ToString(next)])
  };
  /* Return R. */
  return R
  /* The length property of the concat method is 1. */
  /* To Do */
};

/* 15.5.4.7 String.prototype.indexOf (searchString, position) */

/*  If searchString appears as a substring of the result of converting this object to a String, at one or more positions that are greater than or equal to position, then the index of the smallest such position is returned; otherwise, -1 is returned. If position is undefined, 0 is assumed, so as to search all of the String.

The indexOf method takes two arguments, searchString and position, and performs the following steps:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let searchStr be ToString(searchString).

    Let pos be ToInteger(position). (If position is undefined, this step produces the value 0).

    Let len be the number of characters in S.

    Let start be min(max(pos, 0), len).

    Let searchLen be the number of characters in searchStr.

    Return the smallest possible integer k not smaller than start such that k+ searchLen is not greater than len,
    and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same as the character at position j of searchStr);
    but if there is no such integer k, then return the value -1.

The length property of the indexOf method is 1.

NOTE The indexOf function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypeindexOf (global, this, args){
  searchString := l_nth(args,0);
  position := l_nth(args,1);
  /*Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /*Let S be the result of calling ToString, giving it the this value as its argument.*/
  debug;
  S := ToString(this);
  /* Let searchStr be ToString(searchString). */
  searchStr := ToString(searchString);
  /* Let pos be ToInteger(position). (If position is undefined, this step produces the value 0). */
  pos := int_of_float (ToInteger(position));
  /* Let len be the number of characters in S. */
  len := s_len S;
  /* Let start be min(max(pos, 0), len). */
  start := min(max(pos,0), len);
  /* Let searchLen be the number of characters in searchStr. */
  searchLen := s_len searchStr;
  /*     Return the smallest possible integer k not smaller than start such that k+ searchLen is not greater than len,
      and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same as the character at position j of searchStr);
      but if there is no such integer k, then return the value -1. */
  return null /* TO DO */
  /* The length property of the indexOf method is 1. */
  /* TO DO  */
};

/* 15.5.4.8 String.prototype.lastIndexOf (searchString, position) */
/*
If searchString appears as a substring of the result of converting this object to a String at one or more positions that are smaller than or equal to position, then the index of the greatest such position is returned; otherwise, -1 is returned. If position is undefined, the length of the String value is assumed, so as to search all of the String.

The lastIndexOf method takes two arguments, searchString and position, and performs the following steps:

   Call CheckObjectCoercible passing the this value as its argument.

   Let S be the result of calling ToString, giving it the this value as its argument.

   Let searchStr be ToString(searchString).

   Let numPos be ToNumber(position). (If position is undefined, this step produces the value NaN).

   If numPos is NaN, let pos be +∞; otherwise, let pos be ToInteger(numPos).

   Let len be the number of characters in S.

   Let start min(max(pos, 0), len).

   Let searchLen be the number of characters in searchStr.

   Return the largest possible nonnegative integer k not larger than start such that k+ searchLen is not greater than len,
   and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same as the character at position j of searchStr;
   but if there is no such integer k, then return the value -1.

The length property of the lastIndexOf method is 1.

NOTE The lastIndexOf function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypelastIndexOf(global, this, args){
  searchString := l_nth(args,0);
  position := l_nth(args,1);
  /*Call CheckObjectCoercible passing the this value as its argument.*/
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let searchStr be ToString(searchString). */
  searchStr := ToString(searchString);
  /*  Let numPos be ToNumber(position). (If position is undefined, this step produces the value NaN). */
  numPos := ToNumber(position);
  /*  If numPos is NaN, let pos be +∞; otherwise, let pos be ToInteger(numPos).*/
  if (numPos = 'NaN) {
    pos := '+Infinity
  } else{
    pos := int_of_float (ToInteger(numPos))
  };
  /* Let len be the number of characters in S.*/
  len := s_len S;
  /* Let start min(max(pos, 0), len). */
  start := min(max(pos, 0), len);
  /* Let searchLen be the number of characters in searchStr. */
  searchLen := s_len searchStr;
  /*   Return the largest possible nonnegative integer k not larger than start such that k+ searchLen is not greater than len,
     and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same as the character at position j of searchStr;
     but if there is no such integer k, then return the value -1. */
  return null /* To Do */
  /* The length property of the lastIndexOf method is 1. */
  /* To Do */
};
/* 15.5.4.13 String.prototype.slice (start, end)  */
/*
The slice method takes two arguments, start and end, and returns a substring of the result of converting this object to a String,
 starting from character position start and running to, but not including, character position end (or through the end of the String if end is undefined).
If start is negative, it is treated as sourceLength+start where sourceLength is the length of the String.
If end is negative, it is treated as sourceLength+end where sourceLength is the length of the String.
 The result is a String value, not a String object. The following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let len be the number of characters in S.

    Let intStart be ToInteger(start).

    If end is undefined, let intEnd be len; else let intEnd be ToInteger(end).

    If intStart is negative, let from be max(len + intStart,0); else let from be min(intStart,len).

    If intEnd is negative, let to be max(len +intEnd,0); else let to be min(intEnd, len).

    Let span be max(to – from,0).

    Return a String containing span consecutive characters from S beginning with the character at position from.

The length property of the slice method is 2.

NOTE The slice function is intentionally generic; it does not require that its this value be a String object. Therefore it can be transferred to other kinds of objects for use as a method. */

function StringPrototypeSlice (global, this, args){
  start := l_nth(args, 0);
  end := l_nth(args, 1);
  /*Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument. */
  S := ToString(this);
  /* Let len be the number of characters in S. */
  len := s_len str;
  /* Let intStart be ToInteger(start). */
  intStart := int_of_float (ToInteger(start));
  /* If end is undefined, let intEnd be len; else let intEnd be ToInteger(end). */
  if (end = 'undefined){
    intEnd := len
  } else{
    intEnd := int_of_float (ToInteger(end))
  };
  /* If intStart is negative, let from be max(len + intStart,0); else let from be min(intStart,len). */
  if (intStart < 0){
    from := max(len + intStart,0)
  } else{
    from := min(intStart, len)
  };
  /* Let span be max(to – from,0). */
  span := max(to - from, 0);
  /* Return a String containing span consecutive characters from S beginning with the character at position from.*/
  return null /* TO DO */
  /* The length property of the slice method is 2. */
  /* TO DO */

};

/* 15.5.4.14 String.prototype.split (separator, limit)
/*
Returns an Array object into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of separator; these occurrences are not part of any substring in the returned array, but serve to divide up the String value. The value of separator may be a String of any length or it may be a RegExp object (i.e., an object whose [[Class]] internal property is "RegExp"; see 15.10).

The value of separator may be an empty String, an empty regular expression, or a regular expression that can match an empty String. In this case, separator does not match the empty substring at the beginning or end of the input String, nor does it match the empty substring at the end of the previous separator match. (For example, if separator is the empty String, the String is split up into individual characters; the length of the result array equals the length of the String, and each substring contains one character.) If separator is a regular expression, only the first match at a given position of the this String is considered, even if backtracking could yield a non-empty-substring match at that position. (For example, "ab".split(/a*?/) evaluates to the array ["a","b"], while "ab".split(/a* /) evaluates to the array["","b"].)

If the this object is (or converts to) the empty String, the result depends on whether separator can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.

If separator is a regular expression that contains capturing parentheses, then each time separator is matched the results (including any undefined results) of the capturing parentheses are spliced into the output array. For example,

"A<B>bold</B>and<CODE>coded</CODE>".split(/<(\/)?([^<>]+)>/)

evaluates to the array

["A", undefined, "B", "bold", "/", "B", "and", undefined,
"CODE", "coded", "/", "CODE", ""]

If separator is undefined, then the result array contains just one String, which is the this value (converted to a String). If limit is not undefined, then the output array is truncated so that it contains no more than limit elements.

When the split method is called, the following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let A be a new array created as if by the expression new Array()where Array is the standard built-in constructor with that name.

    Let lengthA be 0.

    If limit is undefined, let lim = 232–1; else let lim = ToUint32(limit).

    Let s be the number of characters in S.

    Let p = 0.

    If separator is a RegExp object (its [[Class]] is "RegExp"), let R = separator; otherwise let R = ToString(separator).

    If lim = 0, return A.

    If separator is undefined, then

        Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.

        Return A.

    If s = 0, then

        Call SplitMatch(S, 0, R) and let z be its MatchResult result.

        If z is not failure, return A.

        Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.

        Return A.

    Let q = p.

    Repeat, while q ≠ s

        Call SplitMatch(S, q, R) and let z be its MatchResult result.

        If z is failure, then let q = q+1.

        Else, z is not failure

            z must be a State. Let e be z's endIndex and let cap be z's captures array.

            If e = p, then let q = q+1.

            Else, e ≠ p

                Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive) through q (exclusive).

                Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA), Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.

                Increment lengthA by 1.

                If lengthA = lim, return A.

                Let p = e.

                Let i = 0.

                Repeat, while i is not equal to the number of elements in cap.

                    Let i = i+1.

                    Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA), Property Descriptor {[[Value]]: cap[i], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.

                    Increment lengthA by 1.

                    If lengthA = lim, return A.

                Let q = p.

    Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive) through s (exclusive).

    Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA), Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.

    Return A.

The abstract operation SplitMatch takes three parameters, a String S, an integer q, and a String or RegExp R, and performs the following in order to return a MatchResult (see 15.10.2.1):

    If R is a RegExp object (its [[Class]] is "RegExp"), then

        Call the [[Match]] internal method of R giving it the arguments S and q, and return the MatchResult result.

    Type(R) must be String. Let r be the number of characters in R.

    Let s be the number of characters in S.

    If q+r > s then return the MatchResult failure.

    If there exists an integer i between 0 (inclusive) and r (exclusive) such that the character at position q+i of S is different from the character at position i of R, then return failure.

    Let cap be an empty array of captures (see 15.10.2.1).

    Return the State (q+r, cap). (see 15.10.2.1)

The length property of the split method is 2.

NOTE 1 The split method ignores the value of separator.global for separators that are RegExp objects.

NOTE 2 The split function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.

*/

/* TO DO  -> Requires 15.10*/


/* 15.5.4.15 String.prototype.substring (start, end) */

/*  The substring method takes two arguments, start and end, and returns a substring of the result of converting this object to a String, starting from character position start and running to, but not including, character position end of the String (or through the end of the String is end is undefined). The result is a String value, not a String object.

If either argument is NaN or negative, it is replaced with zero; if either argument is larger than the length of the String, it is replaced with the length of the String.

If start is larger than end, they are swapped.

The following steps are taken:

    Call CheckObjectCoercible passing the this value as its argument.

    Let S be the result of calling ToString, giving it the this value as its argument.

    Let len be the number of characters in S.

    Let intStart be ToInteger(start).

    If end is undefined, let intEnd be len; else let intEnd be ToInteger(end).

    Let finalStart be min(max(intStart, 0), len).

    Let finalEnd be min(max(intEnd, 0), len).

    Let from be min(finalStart, finalEnd).

    Let to be max(finalStart, finalEnd).

    Return a String whose length is to - from, containing characters from S, namely the characters with indices from through to −1, in ascending order.

The length property of the substring method is 2.

NOTE The substring function is intentionally generic; it does not require that its this value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
*/

function StringPrototypesubstring (global, this, args){
  start := l_nth(args,0);
  end := l_nth(args,1);
  /* Call CheckObjectCoercible passing the this value as its argument. */
  CheckObjectCoercible(this);
  /* Let S be the result of calling ToString, giving it the this value as its argument.*/
  S := ToString(this);
  /* Let len be the number of characters in S. */
  len := s_len S;
  /* Let intStart be ToInteger(start). */
  intStart := int_of_float (ToInteger(start));
  /* If end is undefined, let intEnd be len; else let intEnd be ToInteger(end). */
  if (end = 'undefined){
    intEnd := len
  } else {
    intEnd := in_of_float (ToInteger(end))
  };
  /* Let finalStart be min(max(intStart, 0), len).*/
  finalStart := min(max(intStart, 0), len);
  /* Let finalEnd be min(max(intEnd, 0), len). */
  finalEnd := min(max(intEnd, 0), len);
  /* Let from be min(finalStart, finalEnd). */
  from := min(finalStart, finalEnd);
  /* Let to be max(finalStart, finalEnd). */
  to := max(finalStart, finalEnd);
  /* Return a String whose length is to - from, containing characters from S, namely the characters with indices from through to −1, in ascending order. */
  return null /* TO DO */

  /* The length property of the substring method is 2. */
  /* to do */
};

/*
/* 15.5.5.2 [[GetOwnProperty]] ( P ) */
/*
String objects use a variation of the [[GetOwnProperty]] internal method used for other native ECMAScript objects (8.12.1).
This special internal method is used to add access for named properties corresponding to individual characters of String objects.

Assume S is a String object and P is a String.

When the [[GetOwnProperty]] internal method of S is called with property name P, the following steps are taken:

   Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on S with argument P.

   If desc is not undefined return desc.

   If ToString(abs(ToInteger(P))) is not the same value as P, return undefined.

   Let str be the String value of the [[PrimitiveValue]] internal property of S.

   Let index be ToInteger(P).

   Let len be the number of characters in str.

   If len ≤ index, return undefined.

   Let resultStr be a String of length 1, containing one character from str,
   specifically the character at position index, where the first (leftmost) character
   in str is considered to be at position 0, the next one at position 1, and so on.

   Return a Property Descriptor { [[Value]]: resultStr, [[Enumerable]]: true,
    [[Writable]]: false, [[Configurable]]: false }
*/

function GetOwnPropertyString (S, P) {
  /* Assume S is a String object and P is a String. */
  /* Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on S with argument P. */
  desc := GetOwnProperty (S, P);
  /*   If desc is not undefined return desc. */
  if (!(desc = 'undefined)){
    return desc
  };
  /* If ToString(abs(ToInteger(P))) is not the same value as P, return undefined. */
  if (!((ToString(abs(ToInteger(P)))) = P)){
    return 'undefined
  };
  /* Let str be the String value of the [[PrimitiveValue]] internal property of S. */
  str := S.PrimitiveValue;
  /* Let index be ToInteger(P).*/
  index := int_of_float (ToInteger(P));
  /* Let len be the number of characters in str. */
  len := s_len str;
  /* If len ≤ index, return undefined. */
  print len;
  if (len <= index){
    return 'undefined
  };
  /*    Let resultStr be a String of length 1, containing one character from str,
     specifically the character at position index, where the first (leftmost) character
     in str is considered to be at position 0, the next one at position 1, and so on. */
  resultStr := newString(null, null, [ s_nth (str, index)]);
  /* Return a Property Descriptor { [[Value]]: resultStr, [[Enumerable]]: true,
   [[Writable]]: false, [[Configurable]]: false } */
   return newDataPropertyDescriptorFull( resultStr, false, true, false)
};



/* Testing */

function main () {
  globalObject := NewObject();
  functionPrototype := NewObject();
  objectPrototype := NewObject();
  strict := true;
  initStringLib(globalObject, functionPrototype, objectPrototype, strict);
  print "BeforeString";
  sto := StringConstructor(globalObject, null, [ "xpto" ]);
  print "StringCreated";
  return StringPrototypeconcat(null, sto, ["2", "as"])

}
