function initMapPrototype(global, objectPrototype, strict) {
  prototype := NewECMAScriptObjectFull(objectPrototype, "Object", true);
  setAllInternalMethodsOfArray(prototype);

  setJSProperty(prototype, "length", newDataPropertyDescriptorFull(0., true, false, false));

  /* 23.1.3.1 Map.prototype.clear ( ) */
  clearObject := CreateBuiltInFunctionObject([], "mapClear", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(clearObject, true, false, true);
  setJSProperty(prototype, "clear", descriptor);    

  /* 23.1.3.6 Map.prototype.get ( key ) */
  getObject := CreateBuiltInFunctionObject(["items"], "mapGetObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(getObject, true, false, true);
  setJSProperty(prototype, "get", descriptor); 

  /* 23.1.3.7 Map.prototype.has ( key ) */
  hasObject := CreateBuiltInFunctionObject(["items"], "mapHasObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(hasObject, true, false, true);
  setJSProperty(prototype, "has", descriptor);   

  /* 23.1.3.9 Map.prototype.set ( key , value ) */
  setObject := CreateBuiltInFunctionObject(["items"], "mapSetObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(setObject, true, false, true);
  setJSProperty(prototype, "set", descriptor);    

  return prototype
};


function getMapPrototype (strict) { 
  refMap := newPropertyReference(|global|, "Map", strict);
  MapObject := GetValue(refMap);
  refMapProto := newPropertyReference(MapObject, "prototype", strict);
  objectMapProto := GetValue(refMapProto);
  return objectMapProto
}; 


function initMapObject(global, objectPrototype, strict) {
  objMapPrototype := initMapPrototype(global, objectPrototype, strict);
  objMapConstructor := CreateFunctionObject(["items"], "MapConstructor", global, strict, 0.);

  descriptor := newDataPropertyDescriptorFull(objMapConstructor, true, false, true);
  setJSProperty(objMapPrototype, "constructor", descriptor);

  descriptor := newDataPropertyDescriptorFull(objMapPrototype, false, false, false);
  setJSProperty(objMapConstructor, "prototype", descriptor);

  return objMapConstructor
};


function MapConstructor(global, this, strict, items) {
  mapPrototype := getMapPrototype(strict);

  print "inside Map constructor with prototype";
  print mapPrototype.JSProperties; 

  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfArray(newlyConstructedObject);

  /* The [[Prototype]] internal property of the newly constructed object
      is set to the original Array prototype object, the one that is the
      initial value of Array.prototype (15.4.3.1). */
  setInternalProperty(newlyConstructedObject, "Prototype", mapPrototype);
  /* The [[Extensible]] internal property of the newly constructed object
      is set to true. */
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  /* The [[Class]] internal property of the newly constructed object is
      set to "Array". */
  setInternalProperty(newlyConstructedObject, "Class", "Object");

  newlyConstructedObject.MapData := []; 

  return newlyConstructedObject
}; 


function mapClear(global, this, strict, args) {
  /* Let M be the this value. */
  M := this;
  
  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  
  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */
  if (!("MapData" in_obj M)) {
    throw TypeErrorConstructorInternal()
  };
  
  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData;
  
  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries, */
  i := 0;
  len := l_len entries;
  while (i < len) {
    p := l_nth(entries, i); 
    
    /* Set p.[[key]] to empty. */
    p.key := 'empty;
    
    /* Set p.[[value]] to empty. */
    p.value := 'empty;
    i := i + 1
  };
  
  /* Return undefined */
  return 'undefined
};


function mapGetObject(global, this, strict, args) {

  print "inside get function";

  key := l_nth(args, 0);

  /* Let M be the this value. */
  M := this; 

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData; 

  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0; 
  len := l_len entries;

  while (i < len) { 
    p := l_nth(entries, i); 

    /* If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true, return p.[[value]]. */
    if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) { 
      /* return p.[[value]] */
      return p.value 
    }; 

    i := i + 1
  }; 

  return 'undefined 
}; 


function mapSetObject(global, this, strict, args) {

  print "inside set function"; 
  print this; 

  key := l_nth(args, 0);
  value := l_nth (args, 1); 
  
  /* Let M be the this value. */
  M := this; 

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData; 

  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0; 
  len := l_len entries;

  while (i < len) { 
    p := l_nth(entries, i); 

    /* If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true, then */
    if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) {
      /* Set p.[[value]] to value. */
      p.value := value; 

      /* Return M. */
      return M
    }; 

    i := i+1
  }; 

  /* If key is −0, let key be +0. */
  
  /* Let p be the Record {[[key]]: key, [[value]]: value}. */ 
  p := { key: key, value: value }; 

  /* Append p as the last element of entries. */
  M.MapData := l_add(M.MapData, p);

  /* Return M. */
  return M
};

function mapHasObject(global, this, strict, args) {
  
  key := l_nth(args, 0);

  /* Let M be the this value. */
  M := this; 

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData; 

  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0; 
  len := l_len entries;

  while (i < len) { 
    p := l_nth(entries, i); 

    /* If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true */
    if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) { 
      /* return true. */
      return true 
    }; 

    i := i + 1
  }; 

  /* Return false. */
  return false 
}