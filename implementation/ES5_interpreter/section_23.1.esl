function initMapIteratorPrototype (global, objectPrototype, strict) { 
  prototype := NewECMAScriptObjectFull(objectPrototype, "Object", true);
  setAllInternalMethodsOfObject(prototype);

  nextObject := CreateBuiltInFunctionObject([], "MapIteratorPrototypeNext", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(nextObject, true, false, true);
  setJSProperty(prototype, "next", descriptor);

  |MapIteratorPrototype| := prototype; 
  return null
}; 


function initMapPrototype(global, objectPrototype, strict) {
  prototype := NewECMAScriptObjectFull(objectPrototype, "Object", true);
  setAllInternalMethodsOfObject(prototype);

  setJSProperty(prototype, "length", newDataPropertyDescriptorFull(0., true, false, false));

  /* 23.1.3.1 Map.prototype.clear ( ) */
  clearObject := CreateBuiltInFunctionObject([], "mapClear", global, strict, null);
  descriptor := newDataPropertyDescriptorFull(clearObject, true, false, true);
  setJSProperty(prototype, "clear", descriptor);    

  /* 23.1.3.3 Map.prototype.delete ( key )*/
  deleteObject := CreateBuiltInFunctionObject(["items"], "mapDeleteObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(deleteObject, true, false, true);
  setJSProperty(prototype, "delete", descriptor); 

  /* 23.1.3.6 Map.prototype.get ( key ) */
  getObject := CreateBuiltInFunctionObject(["items"], "mapGetObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(getObject, true, false, true);
  setJSProperty(prototype, "get", descriptor); 

  /* 23.1.3.7 Map.prototype.has ( key ) */
  hasObject := CreateBuiltInFunctionObject(["items"], "mapHasObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(hasObject, true, false, true);
  setJSProperty(prototype, "has", descriptor);   

  /* 23.1.3.9 Map.prototype.set ( key , value ) */
  setObject := CreateBuiltInFunctionObject(["items"], "mapSetObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(setObject, true, false, true);
  setJSProperty(prototype, "set", descriptor);  

  /* 23.1.3.10get Map.prototype.size */
  sizeObject := CreateBuiltInFunctionObject([], "mapSizeObject", global, strict, 0.);
  descriptor := newGetAccessorPropertyDescriptor(sizeObject);
  setJSProperty(prototype, "size", descriptor); 

  /* 23.1.3.11 Map.prototype.values ( ) */
  valuesObject := CreateBuiltInFunctionObject([], "mapValuesObject", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(valuesObject, true, false, true);
  setJSProperty(prototype, "values", descriptor); 

  return prototype
};


function getMapPrototype (strict) { 
  refMap := newPropertyReference(|global|, "Map", strict);
  MapObject := GetValue(refMap);
  refMapProto := newPropertyReference(MapObject, "prototype", strict);
  objectMapProto := GetValue(refMapProto);
  return objectMapProto
}; 


function initMapObject(global, objectPrototype, strict) {
  objMapPrototype := initMapPrototype(global, objectPrototype, strict);
  objMapConstructor := CreateFunctionObject(["items"], "MapConstructor", global, strict, 0.);

  descriptor := newDataPropertyDescriptorFull(objMapConstructor, true, false, true);
  setJSProperty(objMapPrototype, "constructor", descriptor);

  descriptor := newDataPropertyDescriptorFull(objMapPrototype, false, false, false);
  setJSProperty(objMapConstructor, "prototype", descriptor);

  return objMapConstructor
};


function MapConstructor(global, this, strict, items) {
  mapPrototype := getMapPrototype(strict);

  print "inside Map constructor with prototype";
  print mapPrototype.JSProperties; 

  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfObject(newlyConstructedObject);

  /* The [[Prototype]] internal property of the newly constructed object
      is set to the original Array prototype object, the one that is the
      initial value of Array.prototype (15.4.3.1). */
  setInternalProperty(newlyConstructedObject, "Prototype", mapPrototype);
  /* The [[Extensible]] internal property of the newly constructed object
      is set to true. */
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  /* The [[Class]] internal property of the newly constructed object is
      set to "Array". */
  setInternalProperty(newlyConstructedObject, "Class", "Object");

  newlyConstructedObject.MapData := []; 

  return newlyConstructedObject
}; 


function mapClear(global, this, strict, args) {
  /* Let M be the this value. */
  M := this;
  
  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  
  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */
  if (!("MapData" in_obj M)) {
    throw TypeErrorConstructorInternal()
  };
  
  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData;
  
  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries, */
  i := 0;
  len := l_len entries;
  while (i < len) {
    p := l_nth(entries, i); 
    
    /* Set p.[[key]] to empty. */
    p.key := 'empty;
    
    /* Set p.[[value]] to empty. */
    p.value := 'empty;
    i := i + 1
  };
  
  /* Return undefined */
  return 'undefined
};


function mapDeleteObject(global, this, strict, args) {

  key := l_nth(args, 0);

  /* 1. Let M be the this value. */
  M := this;
  
  /* 2. If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  };

  /* 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception. */
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* 4. Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData;


  /* 5. Repeat for each Record {[[key]], [[value]]} p that is an element of entries, */
  i := 0; 
  len := l_len(entries);

  while(i < len) {
    p := l_nth(entries, i);

      /* a. If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true, then */
      if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) {
        
        /* i. Set p.[[key]] to empty. */
        p.key := 'empty;
        
        /* ii. Set p.[[value]] to empty. */
        p.value := 'empty;
        
        /* iii. Return true. */
        return true
      };

    i := i+1
  };
  
  
  /* 6.Return false. */
  return false
}; 



function mapGetObject(global, this, strict, args) {

  print "inside get function";

  key := l_nth(args, 0);

  /* Let M be the this value. */
  M := this; 

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData; 

  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0; 
  len := l_len entries;

  while (i < len) { 
    p := l_nth(entries, i); 

    /* If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true, return p.[[value]]. */
    if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) { 
      /* return p.[[value]] */
      return p.value 
    }; 

    i := i + 1
  }; 

  return 'undefined 
}; 


function mapSetObject(global, this, strict, args) {

  print "inside set function"; 
  print this; 

  key := l_nth(args, 0);
  value := l_nth (args, 1); 
  
  /* Let M be the this value. */
  M := this; 

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData; 

  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0; 
  len := l_len entries;

  while (i < len) { 
    p := l_nth(entries, i); 

    /* If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true, then */
    if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) {
      /* Set p.[[value]] to value. */
      p.value := value; 

      /* Return M. */
      return M
    }; 

    i := i+1
  }; 

  /* If key is −0, let key be +0. */
  
  /* Let p be the Record {[[key]]: key, [[value]]: value}. */ 
  p := { key: key, value: value }; 

  /* Append p as the last element of entries. */
  M.MapData := l_add(M.MapData, p);

  /* Return M. */
  return M
};

function mapSizeObject(global, this, strict, args) {

  /* Let M be the this value. */
  M := this;

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  };

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData;

  /* Let count be 0. */
  count := 0;

  /* For each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0;
  len := l_len entries;

  while (i < len) {
    p := l_nth(entries, i);

    /* If p.[[key]] is not empty, set count to count+1. */
    if (!(p.key = 'empty)) {
      count := count + 1
    };

    i := i + 1
  };

  /* Return count. */
  return (int_to_float count)
};

function mapHasObject(global, this, strict, args) {
  
  key := l_nth(args, 0);

  /* Let M be the this value. */
  M := this; 

  /* If Type(M) is not Object, throw a TypeError exception. */
  if (!(Type(M) = "Object")) {
    throw TypeErrorConstructorInternal()
  }; 

  /* If M does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj M)) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* Let entries be the List that is the value of M’s [[MapData]] internal slot. */
  entries := M.MapData; 

  /* Repeat for each Record {[[key]], [[value]]} p that is an element of entries */
  i := 0; 
  len := l_len entries;

  while (i < len) { 
    p := l_nth(entries, i); 

    /* If p.[[key]] is not empty and SameValueZero(p.[[key]], key) is true */
    if ((!(p.key = 'empty)) &&& (SameValue(p.key, key) = true)) { 
      /* return true. */
      return true 
    }; 

    i := i + 1
  }; 

  /* Return false. */
  return false 
}; 


/*
23.1.3.11 Map.prototype.values ( )
*/
function mapValuesObject(global, this, strict, args) { 

  /* 1. Let M be the this value. */
  M := this; 

  /* 2. Return CreateMapIterator(M, "value").*/
  return createMapIterator(M, "value")
};



/*
23.1.5.2 CreateMapIterator Abstract Operation
*/
function createMapIterator (map, kind) { 

  /* 1. If Type(map) is not Object, throw a TypeError exception. */
  if (!(Type(map) = "Object")) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* 2. If map does not have a [[MapData]] internal slot, throw a TypeError exception. */  
  if (!("MapData" in_obj map)) { 
    throw TypeErrorConstructorInternal()
  };

  /* 3. Let iterator be ObjectCreate(%MapIteratorPrototype%, «‍[[Map]], [[MapNextIndex]], [[MapIterationKind]]»). */
  iterator := createMapIteratorObject(); 

  /* 4. Set iterator’s [[Map]] internal slot to map. */
  iterator.Map := map; 

  /* 5. Set iterator’s [[MapNextIndex]] internal slot to 0. */
  iterator.MapNextIndex := 0; 

  /* 6. Set iterator’s [[MapIterationKind]] internal slot to kind.*/
  iterator.MapIterationKind := kind; 

  /* 7. Return iterator. */
  return iterator
};


function createMapIteratorObject() {

  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfObject(newlyConstructedObject);

  setInternalProperty(newlyConstructedObject, "Prototype", |MapIteratorPrototype|);
  
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  
  setInternalProperty(newlyConstructedObject, "Class", "Object");

 
  return newlyConstructedObject
};


function isMapIteratorInstance(obj) {
  return ("Map" in_obj obj) &&& ("MapNextIndex" in_obj obj) &&& ("MapIterationKind" in_obj obj)
};


/* 23.1.5.2.1 %MapIteratorPrototype%.next ( ) */
function MapIteratorPrototypeNext (global, this, strict, args) { 
  /* 1. Let O be the this value. */
  O := this; 

  /* 2. If Type(O) is not Object, throw a TypeError exception.*/
  if (!(Type(O) = "Object")) { 
    throw TypeErrorConstructorInternal()
  }; 

  /* 3. If O does not have all of the internal slots of a Map Iterator Instance (23.1.5.3), throw a TypeError exception. */
  if (!isMapIteratorInstance(O)) {
    throw TypeErrorCon
  }; 

  /* 4. Let m be the value of the [[Map]] internal slot of O. */
  m := O.Map; 

  /* 5. Let index be the value of the [[MapNextIndex]] internal slot of O. */
  index := O.MapNextIndex; 

  /* 6. Let itemKind be the value of the [[MapIterationKind]] internal slot of O.*/
  itemKind := O.MapIterationKind; 

  /* 7. If m is undefined, return CreateIterResultObject(undefined, true).*/
  if (m = 'undefined) {
    return CreateIterResultObject(undefined, true)
  }; 

  /* 8. Assert: m has a [[MapData]] internal slot.*/

  /* 9. Let entries be the List that is the value of the [[MapData]] internal slot of m.*/
  entries := m.MapData; 

  /* 10. Repeat while index is less than the total number of elements of entries. The number of elements must be redetermined each time this method is evaluated.*/
  len := l_len entries; 

  while (index < len) {
    /* a. Let e be the Record {[[key]], [[value]]} that is the value of entries[index].*/
    e := l_nth(entries, index);

    /* b. Set index to index+1. */
    index := index+1; 

    /* c. Set the [[MapNextIndex]] internal slot of O to index. */
    O.MapNextIndex := index; 

    /* d. If e.[[key]] is not empty, then */
    if (!(e.key = 'empty)) {
      if (itemKind = "key") {
        result := e.key
      } elif (itemKind = "value") {
        result := e.value 
      } else {
        /* Assert: itemKind is "key+value".*/
        /* Let result be CreateArrayFromList(«e.[[key]], e.[[value]]»). */
        result :=  CreateArrayFromList( [e.key, e.value ] )
      };
      return CreateIterResultObject(result, false)
    };
    
    index := index + 1
  }; 

  /* 11. Set the [[Map]] internal slot of O to undefined. */
  O.Map := 'undefined; 

  /* 12. Return CreateIterResultObject(undefined, true).*/
  return CreateIterResultObject('undefined, true)
}