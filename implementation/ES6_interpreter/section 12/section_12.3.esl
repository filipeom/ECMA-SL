/* Auxiliary functions to function calls on ES6 */

/**
 * 12.3.4.3 Runtime Semantics: EvaluateDirectCall (func, thisValue, arguments, tailPosition)
 *
 * The abstract operation EvaluateDirectCall takes as arguments a value func, a
 * value thisValue, a syntactic grammar production arguments, and a Boolean
 * argument tailPosition. It performs the following steps:
 */
function EvaluateDirectCall(func, thisValue, arguments, tailPosition, scope) {
  /* 1. Let argList be ArgumentListEvaluation(arguments). */
  argList := JS_Interpreter_Arguments(arguments, scope);

  /* 2. ReturnIfAbrupt(argList). */
  @ReturnIfAbrupt(argList);

  funcType := Type(func);
  print "DEBUG EvaluateDirectCall 0";

  /* 3. If Type(func) is not Object, */
  if (!(funcType = "Object")) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };

  print "DEBUG EvaluateDirectCall 1";
  print func;

  /* 4. If IsCallable(func) is false, */
  if (IsCallable(func) = false) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };

    print "DEBUG EvaluateDirectCall 2";
  /* 5. If tailPosition is true, */
  if (tailPosition = true) {
    /* perform PrepareForTailCall() */
    /* TODO */
  };
  /* 6. Let result be Call(func, thisValue, argList). */
  result := Call(scope, null, func, thisValue, argList);

   /* TODO */
  /* 7. Assert: If tailPosition is true, the above call will not return here,
     but instead evaluation will continue as if the following return has
     already occurred. */
  /* 8. Assert: If result is not an abrupt completion then Type(result) is an
     ECMAScript language type. */

  /* 9. Return result. */
  return result
};

function ArgumentListEvaluation(Arguments, scope) {
  return JS_Interpreter_Arguments(Arguments, scope)
};

/* 12.3.5 The super Keyword */
function SuperPropertyEvaluationA(scope, Expression) {
    /* 1. Let propertyNameReference be the result of evaluating Expression. */
    propertyNameReference := JS_Interpreter_Expr(Expression);

    /* 2. Let propertyNameValue be GetValue(propertyNameReference). */
    propertyNameValue := GetValue(propertyNameReference);

    /* 3. Let propertyKey be ToPropertyKey(propertyNameValue). */
    propertyKey := ToPropertyKey(propertyNameValue);

    /* 4. ReturnIfAbrupt(propertyKey). */
    @ReturnIfAbrupt(propertyKey);

    /* 5. If the code matched by the syntactic production that is being 
        evaluated is strict mode code, let strict be true, else let strict be false */
    /* strict = ???? */

    /* 6. Return MakeSuperPropertyReference(propertyKey, strict). */
    return MakeSuperPropertyReference(propertyKey, strict)
};

function SuperPropertyEvaluationB(IdentifierName, propertyKey) {
    /* 1. Let propertyKey be StringValue of IdentifierName. */
    propertyKey := StringValue(IdentifierName);

    /* 2. If the code matched by the syntactic production that is being 
        evaluated is strict mode code, let strict be true, else let strict be false */
    /* strict = ???? */

    /* 3. Return MakeSuperPropertyReference(propertyKey, strict). */
    return MakeSuperPropertyReference(propertyKey, strict)
};

function SuperPropertyEvaluationAlt(scope, propExpression){
    lex := getLexicalEnvironment(scope);
    newTarget := GetNewTargetAlt(scope, lex);
    if (newTarget = 'undefined){
        throw ReferenceErrorConstructorInternal()
    };
    func := GetSuperConstructorAlt(newTarget);
    propertyNameReference := JS_Interpreter_Expr(propExpression, scope);
    propertyNameValue := GetValue(propertyNameReference);
    propertyNameString := ToPropertyKey(propertyNameValue);
    if (isContainedInStrictCode(scope)) {
      strict := true
    } else {
      strict := false
    };
    return newPropertyReference(func, propertyNameString, strict)
};

function SuperCallEvaluation(scope, Arguments) {
    /* 1. Let newTarget be GetNewTarget(). */
    lex := getLexicalEnvironment(scope);
    print "debug43";
    newTarget := GetNewTargetAlt(scope, lex);

    /* 2. If newTarget is undefined, throw a ReferenceError exception. */
    if (newTarget = 'undefined){
        throw ReferenceErrorConstructorInternal()
    };

    /* 3. Let func be GetSuperConstructor(). */
    func := GetSuperConstructorAlt(newTarget);

    /* 4. ReturnIfAbrupt(func). */
    @ReturnIfAbrupt(func);

    /* 5. Let argList be ArgumentListEvaluation of Arguments. */
    argList := JS_Interpreter_Arguments(Arguments, scope);

    /* 6. ReturnIfAbrupt(argList). */
    @ReturnIfAbrupt(argList);

    /* 7. Let result be Construct(func, argList, newTarget). */
    {func.Call}(null, null, func, newTarget, argList);
    print "debug44";
    print newTarget;
    print newTarget.JSProperties;
    /* 8. ReturnIfAbrupt(result). */
    /* @ReturnIfAbrupt(result); */

    /* 9. Let thisER be GetThisEnvironment( ). */
    /* thisER := GetThisEnvironmentAlt(scope, lex) */

    /* 10. Return thisER.BindThisValue(result). */
    /* return BindThisValue(thisER, result) */
    return newTarget
};

/**
 * 12.3.5.2 Runtime Semantics: GetSuperConstructor
 *
 * The abstract operation GetSuperConstructor performs the following steps: 
 */
function GetSuperConstructor(scope) {
    /* 1. Let envRec be GetThisEnvironment( ). */
    envRec := GetThisEnvironment(scope);
    /* 2. Assert: envRec is a function Environment Record. */
    /* TODO */
    /* 3. Let activeFunction be envRec.[[FunctionObject]]. */
    activeFunction := envRec.FunctionObject;
    /* 4. Let superConstructor be activeFunction.[[GetPrototypeOf]](). */
    superConstructor := GetPrototypeOf(activeFunction);
    /* 5. ReturnIfAbrupt(superConstructor). */
    @ReturnIfAbrupt(superConstructor);
    /* 6. If IsConstructor(superConstructor) is false, */
    if (IsConstructor(superConstructor) = false) {
        /* throw a TypeError exception */
        throw TypeErrorConstructorInternal()
    };
    /* 7. Return superConstructor. */
    return superConstructor
};

function GetSuperConstructorAlt (this){
    thisProto := this.Prototype;
    superProto := thisProto.Prototype;
    constructor := getJSProperty(superProto, "constructor");
    return constructor.Value
};

/**
 * 12.3.5.3 Runtime Semantics: MakeSuperPropertyReference (propertyKey, strict)
 *
 * The abstract operation MakeSuperPropertyReference with arguments propertyKey
 * and strict performs the following steps:
 */
function MakeSuperPropertyReference(propertyKey, strict, scope) {
  /* 1. Let env be GetThisEnvironment( ). */
  env := GetThisEnvironment(scope);
  /* 2. If env.HasSuperBinding() is false, */
  if (HasSuperBinding(env) = false) {
    /* throw a ReferenceError exception */
    throw ReferenceErrorConstructorInternal
  };
  /* 3. Let actualThis be env.GetThisBinding(). */
  actualThis := GetThisBinding(env);
  /* 4. ReturnIfAbrupt(actualThis). */
  @ReturnIfAbrupt(actualThis);
  /* 5. Let baseValue be env.GetSuperBase(). */
  baseValue := GetSuperBase(env);
  /* 6. Let bv be RequireObjectCoercible(baseValue). */
  bv := RequireObjectCoercible(baseValue);
  /* 7. ReturnIfAbrupt(bv). */
  @ReturnIfAbrupt(bv);
  /* 8. Return a value of type Reference that is a Super Reference whose base
     value is bv, whose referenced name is propertyKey, whose thisValue is
     actualThis, and whose strict reference flag is strict. */
  return newSuperReference(bv, propertyKey, actualThis, strict)
};

function MakeSuperPropertyReferenceAlt(scope) {
  func := scope.Function.HomeObject.Prototype;

  return newPropertyReference(func, "constructor", false)
}
