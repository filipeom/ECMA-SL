/* Auxiliary functions to function calls on ES6 */

/**
 * 12.3.4.3 Runtime Semantics: EvaluateDirectCall (func, thisValue, arguments, tailPosition)
 *
 * The abstract operation EvaluateDirectCall takes as arguments a value func, a
 * value thisValue, a syntactic grammar production arguments, and a Boolean
 * argument tailPosition. It performs the following steps:
 */
function EvaluateDirectCall(func, thisValue, arguments, tailPosition, scope) {
  /* 1. Let argList be ArgumentListEvaluation(arguments). */
  argList := JS_Interpreter_Arguments(arguments, scope);

  /* 2. ReturnIfAbrupt(argList). */
  @ReturnIfAbrupt(argList);

  funcType := Type(func);
  print "DEBUG EvaluateDirectCall 0";

  /* 3. If Type(func) is not Object, */
  if (!(Type(func) = "Object")) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };

  print "DEBUG EvaluateDirectCall 1";
  print func;

  /* 4. If IsCallable(func) is false, */
  if (IsCallable(func) = false) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };

    print "DEBUG EvaluateDirectCall 2";
  /* 5. If tailPosition is true, */
  if (tailPosition = true) {
    /* perform PrepareForTailCall() */
    /* TODO */
  };
  /* 6. Let result be Call(func, thisValue, argList). */
  result := Call(scope, null, func, thisValue, argList);

   /* TODO */
  /* 7. Assert: If tailPosition is true, the above call will not return here,
     but instead evaluation will continue as if the following return has
     already occurred. */
  /* 8. Assert: If result is not an abrupt completion then Type(result) is an
     ECMAScript language type. */

  /* 9. Return result. */
  return result
};

function ArgumentListEvaluation(Arguments, scope) {
  return JS_Interpreter_Arguments(Arguments, scope)
};

/* 12.3.5 The super Keyword */

/* 12.3.5.1 Runtime Semantics: Evaluation */

/* SuperCall : super Arguments */
function SuperCall(Arguments, scope) {
  /* 1. Let newTarget be GetNewTarget(). */
  newTarget := GetNewTarget(scope);
  /* 2. If newTarget is undefined, throw a ReferenceError exception. */
  if (newTarget = 'undefined) {
    throw ReferenceErrorConstructorInternal()
  };
  /* 3. Let func be GetSuperConstructor(). */
  func := GetSuperConstructor(scope);
  /* 4. ReturnIfAbrupt(func). */
  @ReturnIfAbrupt(func);
  /* 5. Let argList be ArgumentListEvaluation of Arguments. */
  argList := ArgumentListEvaluation(Arguments, scope);
  /* 6. ReturnIfAbrupt(argList). */
  @ReturnIfAbrupt(argList);
  /* 7. Let result be Construct(func, argList, newTarget). */
  result := Construct(scope, null, func, argList, newTarget);
  /* 8. ReturnIfAbrupt(result). */
  @ReturnIfAbrupt(result);
  /* 9. Let thisER be GetThisEnvironment( ). */
  thisER := GetThisEnvironment(scope);
  /* 10. Return thisER.BindThisValue(result). */
  return {thisER.BindThisValue}(thisER, result)
};

/* 12.3.5.2 Runtime Semantics: GetSuperConstructor ( )
 * 
 * The abstract operation GetSuperConstructor performs the following steps:
 */
function GetSuperConstructor(scope) {
  /* 1. Let envRec be GetThisEnvironment( ). */
  envRec := GetThisEnvironment(scope);
  /* 2. Assert: envRec is a function Environment Record. */
  assert(Type(envRec) = "EnvironmentRecord");
  /* 3. Let activeFunction be envRec.[[FunctionObject]]. */
  activeFunction := envRec.FunctionObject;
  /* 4. Let superConstructor be activeFunction.[[GetPrototypeOf]](). */
  superConstructor := {activeFunction.GetPrototypeOf}(activeFunction);
  /* 5. ReturnIfAbrupt(superConstructor). */
  @ReturnIfAbrupt(superConstructor);
  /* 6. If IsConstructor(superConstructor) is false, throw a TypeError exception. */
  if (IsConstructor(superConstructor) = false) {
    throw TypeErrorConstructorInternal()
  };
  /* 7. Return superConstructor. */
  return superConstructor
}
