function DefineMethodAlt(scope, object, method, functionPrototype){
    FunctionBody := method.body;
    FormalParameterListopt := method.params;
    F := CreateFunctionObject(FormalParameterListopt, FunctionBody, getVariableEnvironment(scope), false, null);
    return { closure: F } 
};

/**
 * 14.3.8 Runtime Semantics: DefineMethod
 *
 * With parameters object and optional parameter functionPrototype. 
 */
function DefineMethodProperty(scope, object, propertyName, func, functionPrototype){
  
  /* 1. Let propKey be the result of evaluating PropertyName. */
  propKey := propertyName.name;

  /* 2. ReturnIfAbrupt(propKey). */
  @ReturnIfAbrupt(propKey);

  /* 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false. */
  /* strict := isStrictModeCode(getFunctionCode(functionPrototype), scope); */

  /* 4. Let scope be the running execution context’s LexicalEnvironment. */
  scope := getLexicalEnvironment(scope);

  /* 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method. */
  if (!(functionPrototype = null)) {
	  kind := "Normal"
  } else {
	  kind := "Method"
  };

  /* 6. Let closure be FunctionCreate(kind, StrictFormalParameters, 
     FunctionBody, scope, strict). If functionPrototype was passed as a 
     parameter then pass its value as the functionPrototype optional 
     argument of FunctionCreate. */
  closure := CreateFunctionObject(func.params, func.body, scope, false, null);

  /* 7. Perform MakeMethod(closure, object). */
  MakeMethod(closure, object);

  /* 8. Return the Record{[[key]]: propKey, [[closure]]: closure}. */
  return {key: propKey, closure: closure}
};

function MethodPropertyDefinitionEvaluation(scope, object, enumerable, methodPropertyDefinition){
    
    match methodPropertyDefinition with
    | { type: "MethodDefinition", kind: "method", key: key, value: func} -> {
        /* 1. Let methodDef be DefineMethod of MethodDefinition with argument object. */
        methodDef := DefineMethodProperty(scope, object, key, func, null);
        
        /* 2. ReturnIfAbrupt(methodDef). */
        @ReturnIfAbrupt(methodDef);

        /* 3. Perform SetFunctionName(methodDef.[[closure]], methodDef.[[key]]). */
        SetFunctionName(methodDef.closure, methodDef.key, null);

        /* 4. Let desc be the Property Descriptor{[[Value]]: methodDef.[[closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}. */
        desc := newDataPropertyDescriptorFull(methodDef.closure, true, enumerable, true);

        /* 5. Return DefinePropertyOrThrow(object, methodDef.[[key]], desc). */
        return DefinePropertyOrThrow(object, methodDef.key, desc)
    }
    | {type: "MethodDefinition", kind: "get", key: key, value: func} -> {
        /* 1. Let propKey be the result of evaluating PropertyName. */
        propKey := key.name;

        /* 2. ReturnIfAbrupt(propKey). */
        @ReturnIfAbrupt(propKey);

        /* 3. If the function code for this MethodDefinition is strict mode code,
              let strict be true. Otherwise let strict be false. */
        /* strict := isStrictModeCode(getFunctionCode(func), scope); */

        /* 4. Let scope be the running execution context’s LexicalEnvironment. */
        scope := getLexicalEnvironment(scope);

        /* 5. Let formalParameterList be the production FormalParameters : [empty] */
        formalParameterList := ['empty]; /* Pode não estar correto!!! */

        /* 6. Let closure be FunctionCreate(Method, formalParameterList, 
            FunctionBody, scope, strict). */
        closure := CreateFunctionObject(func.params, func.body, scope, false, null);

        /* 7. Perform MakeMethod(closure, object). */
        MakeMethod(closure, object);

        /* 8. Perform SetFunctionName(closure, propKey, "get"). */
        SetFunctionName(closure, propKey, "get");

        /* 9. Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: 
            enumerable, [[Configurable]]: true} */
        desc := newGetAccessorPropertyDescriptorFull(closure, enumerable, true);

        /* 10. Return DefinePropertyOrThrow(object, propKey, desc). */
        return DefinePropertyOrThrow(object, propKey, desc)
    }
    | {type: "MethodDefinition", kind: "set", key: key, value: func} -> {
        /* 1. Let propKey be the result of evaluating PropertyName. */
        propKey := key.name;

        /* 2. ReturnIfAbrupt(propKey). */
        @ReturnIfAbrupt(propKey);

        /* 3. If the function code for this MethodDefinition is strict mode code,
              let strict be true. Otherwise let strict be false. */
        /* strict := isStrictModeCode(getFunctionCode(func), scope); */

        /* 4. Let scope be the running execution context’s LexicalEnvironment. */
        scope := getLexicalEnvironment(scope);

        /* 5. Let closure be FunctionCreate(Method, formalParameterList, 
            FunctionBody, scope, strict). */
        closure := CreateFunctionObject(func.params, func.body, scope, false, null);

        /* 6. Perform MakeMethod(closure, object). */
        MakeMethod(closure, object);

        /* 7. Perform SetFunctionName(closure, propKey, "get"). */
        SetFunctionName(closure, propKey, "set");

        /* 8. Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: 
            enumerable, [[Configurable]]: true} */
        desc := newSetAccessorPropertyDescriptorFull(closure, enumerable, true);

        /* 9. Return DefinePropertyOrThrow(object, propKey, desc). */
        return DefinePropertyOrThrow(object, propKey, desc)

    }

}

