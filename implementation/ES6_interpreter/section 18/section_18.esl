/* 15.1 The Global Object */

/* The unique global object is created before control enters any execution context.
Unless otherwise specified, the standard built-in properties of the global object have attributes {[[Writable]]:
true, [[Enumerable]]: false, [[Configurable]]: true}. */

/* The global object does not have a [[Construct]] internal property; it is not possible to use the global object as a
constructor with the new operator. */

/* The global object does not have a [[Call]] internal property; it is not possible to invoke the global object as a
function. */

/* The values of the [[Prototype]] and [[Class]] internal properties of the global object are implementation-
dependent. */

/* In addition to the properties defined in this specification the global object may have additional host defined
properties. This may include a property whose value is the global object itself; for example, in the HTML
document object model the window property of the global object is the global object itself. */

function initGlobalObject(strict) {
  globalObject := NewECMAScriptObjectFull('null, "Object", true);
  |global| := globalObject;

  setAllInternalMethodsOfOrdinaryObject(globalObject);

  ObjectPrototype := initObjectPrototype();
  FunctionPrototype := initFunctionPrototype(ObjectPrototype, globalObject, strict);
  ObjectConstructor := initObjectConstructor(ObjectPrototype, FunctionPrototype, globalObject, strict);
  |objectConstructor| := ObjectConstructor;
  FunctionConstructor := initFunctionConstructor(FunctionPrototype, globalObject, strict);

  setInternalProperty(globalObject, "Prototype", ObjectPrototype);

  createBuiltInProperty(globalObject, "Object", ObjectConstructor);
  createBuiltInProperty(globalObject, "Function", FunctionConstructor);

  fillObjectPrototype(ObjectPrototype, ObjectConstructor, globalObject, strict);
  fillFunctionPrototype(FunctionPrototype, FunctionConstructor, globalObject, strict);
  fillObjectConstructor(ObjectConstructor, globalObject, strict);
  fillFunctionConstructor(FunctionConstructor, globalObject, strict);


  /* 15.1.1 Value Properties of the Global Object */
  /* 15.1.1.1 NaN */
  /* The value of NaN is NaN (see 8.5). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false,
    [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(globalObject, "NaN", NaN, false, false, false);
  /* 15.1.1.2 Infinity */
  /* The value of Infinity is +Infinity (see 8.5). This property has the attributes { [[Writable]]: false, [[Enumerable]]:
    false, [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(globalObject, "Infinity", Infinity, false, false, false);
  /* 15.1.1.3 undefined */
  /* The value of undefined is undefined (see 8.1). This property has the attributes { [[Writable]]: false,
    [[Enumerable]]: false, [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(globalObject, "undefined", 'undefined, false, false, false);

  /* 15.1.2 Function Properties of the Global Object */
  /* 15.1.2.1 eval (x) */
  eval := CreateBuiltInFunctionObject(["x"], "GlobalObjectEval", globalObject, strict, null);
  createBuiltInProperty(globalObject, "eval", eval);
  /* 15.1.2.2 parseInt (string , radix) */
  parseInt := CreateBuiltInFunctionObject(["string", "radix"], "GlobalObjectParseInt", globalObject, strict, null);
  createBuiltInProperty(globalObject, "parseInt", parseInt);
  /* 15.1.2.3 parseFloat (string) */
  parseFloat := CreateBuiltInFunctionObject(["string"], "GlobalObjectParseFloat", globalObject, strict, null);
  createBuiltInProperty(globalObject, "parseFloat", parseFloat);
  /* 15.1.2.4 isNaN (number) */
  isNaN := CreateBuiltInFunctionObject(["number"], "GlobalObjectIsNaN", globalObject, strict, null);
  createBuiltInProperty(globalObject, "isNaN", isNaN);
  /* 15.1.2.5 isFinite (number) */
  isFinite := CreateBuiltInFunctionObject(["number"], "GlobalObjectIsFinite", globalObject, strict, null);
  createBuiltInProperty(globalObject, "isFinite", isFinite);
  /* 15.1.3 URI Handling Function Properties */ /* TODO */
  /* 15.1.3.1 decodeURI (encodedURI) */
  decodeURI := CreateBuiltInFunctionObject(["encodedURI"], "GlobalObjectDecodeURI", globalObject, strict, null);
  createBuiltInProperty(globalObject, "decodeURI", decodeURI);
  /* 15.1.3.2 decodeURIComponent (encodedURIComponent) */
  decodeURIComponent := CreateBuiltInFunctionObject(["encodedURIComponent"], "GlobalObjectDecodeURIComponent", globalObject, strict, null);
  createBuiltInProperty(globalObject, "decodeURIComponent", decodeURIComponent);
  /* 15.1.3.3 encodeURI (uri) */
  encodeURI := CreateBuiltInFunctionObject(["uri"], "GlobalObjectEncodeURI", globalObject, strict, null);
  createBuiltInProperty(globalObject, "encodeURI", encodeURI);
  /* 15.1.3.4 encodeURIComponent (uriComponent) */
  encodeURIComponent := CreateBuiltInFunctionObject(["uriComponent"], "GlobalObjectEncodeURIComponent", globalObject, strict, null);
  createBuiltInProperty(globalObject, "encodeURIComponent", encodeURIComponent);

  /* 15.1.4 Constructor Properties of the Global Object */
  /* 15.1.4.1 Object ( . . . ) */
  /* 15.1.4.2 Function ( . . . ) */

  /* 15.1.4.3 Array ( . . . ) */
  ArrayObject := initArrayObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Array", ArrayObject);
  initArrayIteratorPrototype(globalObject, ObjectPrototype, strict);

  /* 15.1.4.4 String ( . . . ) */
  StringObject := initStringObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "String", StringObject);
  initStringIteratorPrototype(globalObject, ObjectPrototype, strict);
  /* 15.1.4.5 Boolean ( . . . ) */
  BooleanObject := initBooleanObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Boolean", BooleanObject);
  /* 15.1.4.7 Date ( . . . ) */
  DateObject := initDateObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Date", DateObject);
  /* 15.1.4.8 RegExp ( . . . ) */
  RegExpObject := initRegExpObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "RegExp", RegExpObject);
  /* 15.1.4.9 Error ( . . . ) */
  ErrorObject := initErrorObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Error", ErrorObject);
  /* 15.1.4.10 EvalError ( . . . ) */
  EvalErrorObject := initEvalErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "EvalError", EvalErrorObject);
  /* 15.1.4.11 RangeError ( . . . ) */
  RangeErrorObject := initRangeErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "RangeError", RangeErrorObject);
  /* 15.1.4.12 ReferenceError ( . . . ) */
  ReferenceErrorObject := initReferenceErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "ReferenceError", ReferenceErrorObject);
  /* 15.1.4.13 SyntaxError ( . . . ) */
  SyntaxErrorObject := initSyntaxErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "SyntaxError", SyntaxErrorObject);
  /* 15.1.4.14 TypeError ( . . . ) */
  TypeErrorObject := initTypeErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "TypeError", TypeErrorObject);
  /* 15.1.4.15 URIError ( . . . ) */
  URIErrorObject := initURIErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "URIError", URIErrorObject);

  /* 15.1.5 Other Properties of the Global Object*/
  /* 15.1.5.1 Math */
  MathObject := initMathObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Math", MathObject);
  /* 15.1.5.2 JSON */
  JsonObject := initJsonObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "JSON", JsonObject);

  /* 25.4.3.1 Promise */
  PromiseObject := initPromiseObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Promise", PromiseObject);
  
  /* 20.1 Number Objects */
  NumberObject := initNumberObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Number", NumberObject);

  /* 23.1 Map */
  MapObject := initMapObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Map", MapObject);
  initMapIteratorPrototype(globalObject, ObjectPrototype, strict);
  
  symbolObject := initSymbolObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Symbol", symbolObject);

  /* 23.2 Set */
  SetObject := initSetObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Set", SetObject);
  initSetIteratorPrototype(globalObject, ObjectPrototype, strict);

  /* 23.3 WeakMap Objects */
  WeakMapObject := initWeakMapObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "WeakMap", WeakMapObject);
  
  /* 23.4 WeakSet Objects */
  WeakSetObject := initWeakSetObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "WeakSet", WeakSetObject);

  /* 26.2 Proxy Objects */
  ProxyObject := initProxyObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Proxy", ProxyObject);

  /* Extras */
  ConsoleObject := initConsoleObject(globalObject, getObjectPrototype(strict), strict);
  createBuiltInProperty(globalObject, "console", ConsoleObject);

  return globalObject
};

/* 15.1.2.1 eval (x) */
function GlobalObjectEval(externalScope, ref, this, strict, params) {
  x := l_nth(params, 0);
  /* When the eval function is called with one argument x, the following steps are taken: */

  /* 1. If Type(x) is not String, return x. */
  if (!(Type(x) = "String")) {
    return x
  };
  /* 2. Let prog be the ECMAScript code that is the result of parsing x as a Program. If the parse fails, throw a
        SyntaxError exception (but see also clause 16). */
  prog := parseAsProgram(x, strict);
  /* 3. Let evalCtx be the result of establishing a new execution context (10.4.2) for the eval code prog. */
  evalCtx := EnteringEvalCode(prog, ref, externalScope);
  /* 4. Let result be the result of evaluating the program prog. */
  result := JS_Interpreter_Program(prog, evalCtx);
  /* 5. Exit the running execution context evalCtx, restoring the previous execution context. */
  /* 6. If result.type is normal and its completion value is a value V, then return the value V. */
  if ((getCompletionType(result) = 'normal) &&& !(getCompletionValue(result) = 'empty)) {
    return getCompletionValue(result)
  };
  /* 7. If result.type is normal and its completion value is empty, then return the value undefined. */
  if ((getCompletionType(result) = 'normal) &&& (getCompletionValue(result) = 'empty)) {
    return 'undefined
  };
  /* 8. Otherwise, result.type must be throw. Throw result.value as an exception. */
  throw getCompletionValue(result)
};

/* 15.1.2.1.1 Direct Call to Eval */
/* A direct call to the eval function is one that is expressed as a CallExpression that meets the following two
   conditions: */
/* The Reference that is the result of evaluating the MemberExpression in the CallExpression has an environment
   record as its base value and its reference name is "eval". */
/* The result of calling the abstract operation GetValue with that Reference as the argument is the standard built-
   in function defined in 15.1.2.1. */

/* 15.1.2.2 parseInt (string , radix) */
/* TODO: RE-CHECK THIS, IT WAS COPIED FROM ES5 - MAYBE THERE IS DIFFERENCES ON ES6 */
function GlobalObjectParseInt(globalObject, this, strict, params) {
  string := l_nth(params, 0);
  radix := l_nth(params, 1);
  /* The parseInt function produces an integer value dictated by interpretation of the contents of the string
      argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0,
      it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix
      of 16 is assumed. If radix is 16, the number may also optionally begin with the character pairs 0x or 0X. */

  /* When the parseInt function is called, the following steps are taken: */

  /* 1. Let inputString be ToString(string). */
  inputString := ToString(string);
  /* 2. Let S be a newly created substring of inputString consisting of the first character that is not a
        StrWhiteSpaceChar and all characters following that character. (In other words, remove leading white
        space.) If inputString does not contain any such characters, let S be the empty string. */
  S := removeLeadingWhitespace(inputString);
  /* 3. Let sign be 1. */
  sign := 1.;
  /* 4. If S is not empty and the first character of S is a minus sign -, let sign be -1. */
  if (!(S = "") &&& (s_nth_u(S, 0) = "-")) {
    sign := -(1.)
  };
  /* 5. If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove the first character
        from S. */
  if (!(S = "") &&& ((s_nth_u(S, 0) = "+") ||| (s_nth_u(S, 0) = "-"))) {
    S := s_substr_u(S, 1, s_len_u(S) - 1)
  };
  /* 6. Let R = ToInt32(radix). */
  R := ToInt32(radix);
  /* 7. Let stripPrefix be true. */
  stripPrefix := true;
  /* 8. If R <> 0, then */
  if (!(R = 0.)) {
    /* a. If R < 2 or R > 36, then return NaN. */
    if (R < 2. ||| R > 36.) {
      return NaN
    };
    /* b. If R <> 16, let stripPrefix be false. */
    if (!(R = 16.)) {
      stripPrefix := false
    }
  }
  /* 9. Else, R = 0 */
  else {
    /* a. Let R = 10. */
    R := 10.
  };
  /* 10. If stripPrefix is true, then */
  if (stripPrefix = true) {
    /* a. If the length of S is at least 2 and the first two characters of S are either "0x" or "0X", then remove
          the first two characters from S and let R = 16. */
    if (s_len_u(S) >= 2 &&& (s_substr_u(S, 0, 2) = "0x" ||| s_substr_u(S, 0, 2) = "0X")) {
      S := s_substr_u(S, 2, s_len_u(S) - 2);
      R := 16.
    }
  };
  /* 11. If S contains any character that is not a radix-R digit, then let Z be the substring of S consisting of all
         characters before the first such character; otherwise, let Z be S. */
  if (containsInvalidDigit(S, R)) {
    Z := stripInvalidChars(S, R)
  } else {
    Z := S
  };
  /* 12. If Z is empty, return NaN. */
  if (Z = "") {
    return NaN
  };
  /* 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters
         A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20
         significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the
         implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent
         approximation to the mathematical integer value that is represented by Z in radix-R notation.) */
  mathInt := mathIntegerOf(Z, R);
  /* 14. Let number be the Number value for mathInt. */
  number := mathInt;
  /* 15. Return sign x number. */
  return sign * number
};

/* 15.1.2.3 parseFloat (string) */
function GlobalObjectParseFloat(globalObject, this, strict, params) {
  string := l_nth(params, 0);
  /* The parseFloat function produces a Number value dictated by interpretation of the contents of the string
     argument as a decimal literal. */

  /* When the parseFloat function is called, the following steps are taken: */

  /* 1. Let inputString be ToString(string). */
  inputString := ToString(string);
  return float_of_string inputString
  /* 2. Let trimmedString be a substring of inputString consisting of the leftmost character that is not a
        StrWhiteSpaceChar and all characters to the right of that character. (In other words, remove leading white
        space.) If inputString does not contain any such characters, let trimmedString be the empty string. */
  /* 3. If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see
        9.3.1), return NaN. */
  /* 4. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies
        the syntax of a StrDecimalLiteral. */
  /* 5. Return the Number value for the MV of numberString. */

  /* NOTE parseFloat may interpret only a leading portion of string as a Number value; it ignores any characters that
          cannot be interpreted as part of the notation of an decimal literal, and no indication is given that any such characters were
          ignored. */
};

/* 15.1.2.3 parseFloat (string) */
function GlobalObjectParseFloatAlt(globalObject, this, strict, params) {
  string := l_nth(params, 0);
  /* 1. Let inputString be ToString(string). */
  inputString := ToString(string);
  /* 2. ReturnIfAbrupt(inputString). */
  @ReturnIfAbrupt(inputString);
  /* 3. Let trimmedString be a substring of inputString
  consisting of the leftmost code unit that is not a StrWhiteSpaceChar
  and all code units to the right of that code unit.
  (In other words, remove leading white space.) 
  If inputString does not contain any such code units, let trimmedString be the empty string. */
  trimmedString := inputString;
  len := s_len_u(inputString);
  while (s_nth(inputString, index) = " ") {
    if (len = 0) {
      trimmedString := ""
      /* TODO break */
    };
    trimmedString := s_substr_u(trimmedString, 1, len - 1);
    len := len - 1
  };
  /* TODO */
  /* 4. If neither trimmedString nor any prefix of trimmedString satisfies
  the syntax of a StrDecimalLiteral (see 7.1.3.1), return NaN. */
  /* 5. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself,
  that satisfies the syntax of a StrDecimalLiteral. */

  /* 6. TODO Let mathFloat be MV of numberString. */
  
  /* 7. If mathFloat=0, then */
  if (mathFloat = 0) {
    /* a. If the first code unit of trimmedString is "-", return −0. */
    if (s_nth(0, trimmedString) =  "-") {
      return -(0.)
    };
    /* b. Return +0. */
    return 0.
  };
  /* 8. Return the Number value for mathFloat. */
  return mathFloat
};

/* 15.1.2.4 isNaN (number) */
function GlobalObjectIsNaN(globalObject, this, strict, params) {
  number := l_nth(params, 0);
  /* Returns true if the argument coerces to NaN, and otherwise returns false. */

  /* 1. If ToNumber(number) is NaN, return true. */
  if (ToNumber(number) = NaN) {
    return true
  };
  /* 2. Otherwise, return false. */
  return false

  /* NOTE A reliable way for ECMAScript code to test if a value X is a NaN is an expression of the form X !== X. The
          result will be true if and only if X is a NaN. */
};

/* 15.1.2.5 isFinite (number) */
function GlobalObjectIsFinite(globalObject, this, strict, params) {
  number := l_nth(params, 0);
  /* Returns false if the argument coerces to NaN, +Infinity, or -Infinity, and otherwise returns true. */

  /* 1. If ToNumber(number) is NaN, +Infinity, or -Infinity, return false.*/
  if ((ToNumber(number) = NaN) ||| (ToNumber(number) = Infinity) ||| (ToNumber(number) = -Infinity)) {
    return false
  };
  /* 2. Otherwise, return true. */
  return true
};

/* 15.1.3 URI Handling Function Properties */ /* TODO */
/* 15.1.3.1 decodeURI (encodedURI) */
/* 15.1.3.2 decodeURIComponent (encodedURIComponent) */
/* 15.1.3.3 encodeURI (uri) */
/* 15.1.3.4 encodeURIComponent (uriComponent) */

/* Auxiliary functions */
function parseAsProgram(progStr, strict) {
  if (strict) {
    progStr := s_concat ["\"use strict\";", progStr]
  };
  prog := extern parseJS(progStr);
  progObj := {prog}();
  progObj.codeType := "eval";

  return progObj
};

function optimizeInitGlobalObject(strict) {
  if ((typeof strict = __$Bool) &&& strict) {
    loc_global := extern loadInitialHeap("globalHeap_strict.json")
  } else {
    loc_global := extern loadInitialHeap("globalHeap.json")
  };

  |global| := loc_global;

  return loc_global
};

function removeLeadingWhitespace(string) {
  T := trim string;
  /* Remove leading spaces */
  if (!(T = "")) {
    len := s_len_u T;
    i := 0;
    j := 0;
    while (i < len) {
      c := s_nth_u(T, j);
      if (isSpaceCharacter(c)) {
        j := j + 1
      } else {
        i := len
      };
      i := i + 1
    };
    T := s_substr_u(T, j, (len - j))
  };

  return T
};

function containsInvalidDigit(string, radix) {
  radixInt := int_of_float radix;
  str_len := s_len_u string;
  i := 0;

  while (i < str_len) {
    char := s_nth_u(string, i);
    index := indexOfChar(char);

    if (index = -1 ||| index >= radixInt) {
      return true
    };

    i:= i + 1
  };

  return false
};

function isSpaceCharacter(c) {
  /* Table 2 — Whitespace Characters
      Code Unit            Value Name          Formal Name
      \u0009               Tab                 <TAB>
      \u000B               Vertical Tab        <VT>
      \u000C               Form Feed           <FF>
      \u0020               Space               <SP>
      \u00A0               No-break space      <#x0a>
      \uFEFF               Byte Order Mark     <BOM>
      Other category “Zs”  Any other Unicode   <USP>
                           “space separator” */

  /* https://www.compart.com/en/unicode/category/Zs */
  /*
   * \u0020 \u00A0 \u1680 \u2000 \u2001 \u2002
   * \u2003 \u2004 \u2005 \u2006 \u2007 \u2008
   * \u2009 \u200A \u202F \u205F \u3000
   */

  /* Table 3 — Line Terminator Characters
    Code Unit Value       Name                  Formal Name
    \u000A                Line Feed             <LF>
    \u000D                Carriage Return       <CR>
    \u2028                Line separator        <LS>
    \u2029                Paragraph separator   <PS> */
  spaces := ["\t", "\v", "\f", " ", "\u{00A0}", "\u{FEFF}", "\u{1680}", "\u{2000}",
    "\u{2001}", "\u{2002}", "\u{2003}", "\u{2004}", "\u{2005}", "\u{2006}", "\u{2007}",
    "\u{2008}", "\u{2009}", "\u{200A}", "\u{202F}", "\u{205F}", "\u{3000}", "\n", "\r",
    "\u{2028}", "\u{2029}"];
  foreach (s : spaces) {
    if (s = c) {
      return true
    }
  };
  return false
};

function indexOfChar(char) {
  chars := [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
    "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"
  ];
  i := 0;

  while(i < 36) {
    if (to_lower_case char = l_nth(chars, i)) {
      return i
    };

    i:= i + 1
  };

  return -1
};

function mathIntegerOf(string, radix) {
  str_len := s_len_u string;
  i := str_len;
  value := 0.;

  while(i > 0) {
    char := s_nth_u(string, i - 1);
    charValue := indexOfChar(char);

    value := value + ((radix ** (int_to_float (str_len - i))) * (int_to_float charValue));

    i:= i - 1
  };

  return value
};

function stripInvalidChars(string, radix) {
  radixInt := int_of_float radix;
  str_len := s_len_u string;
  i := 0;

  while (i < str_len) {
    char := s_nth_u(string, i);
    index := indexOfChar(char);

    if (index = -1 ||| index >= radixInt) {
      return s_substr_u(string, 0, i)
    };

    i:= i + 1
  };

  return string
}
