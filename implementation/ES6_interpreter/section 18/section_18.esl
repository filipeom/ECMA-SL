/* 15.1 The Global Object */

/* The unique global object is created before control enters any execution context.
Unless otherwise specified, the standard built-in properties of the global object have attributes {[[Writable]]:
true, [[Enumerable]]: false, [[Configurable]]: true}. */

/* The global object does not have a [[Construct]] internal property; it is not possible to use the global object as a
constructor with the new operator. */

/* The global object does not have a [[Call]] internal property; it is not possible to invoke the global object as a
function. */

/* The values of the [[Prototype]] and [[Class]] internal properties of the global object are implementation-
dependent. */

/* In addition to the properties defined in this specification the global object may have additional host defined
properties. This may include a property whose value is the global object itself; for example, in the HTML
document object model the window property of the global object is the global object itself. */

function initGlobalObject(strict) {
  globalObject := NewECMAScriptObjectFull('null, "Object", true);
  |global| := globalObject;

  setAllInternalMethodsOfObject(globalObject);

  ObjectPrototype := initObjectPrototype();
  FunctionPrototype := initFunctionPrototype(ObjectPrototype, globalObject, strict);
  ObjectConstructor := initObjectConstructor(ObjectPrototype, FunctionPrototype, globalObject, strict);
  |objectConstructor| := ObjectConstructor;
  FunctionConstructor := initFunctionConstructor(FunctionPrototype, globalObject, strict);

  setInternalProperty(globalObject, "Prototype", ObjectPrototype);

  createBuiltInProperty(globalObject, "Object", ObjectConstructor);
  createBuiltInProperty(globalObject, "Function", FunctionConstructor);

  fillObjectPrototype(ObjectPrototype, ObjectConstructor, globalObject, strict);
  fillFunctionPrototype(FunctionPrototype, FunctionConstructor, globalObject, strict);
  fillObjectConstructor(ObjectConstructor, globalObject, strict);
  fillFunctionConstructor(FunctionConstructor, globalObject, strict);


  /* 15.1.1 Value Properties of the Global Object */
  /* 15.1.1.1 NaN */
  /* The value of NaN is NaN (see 8.5). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false,
    [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(globalObject, "NaN", NaN, false, false, false);
  /* 15.1.1.2 Infinity */
  /* The value of Infinity is +Infinity (see 8.5). This property has the attributes { [[Writable]]: false, [[Enumerable]]:
    false, [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(globalObject, "Infinity", Infinity, false, false, false);
  /* 15.1.1.3 undefined */
  /* The value of undefined is undefined (see 8.1). This property has the attributes { [[Writable]]: false,
    [[Enumerable]]: false, [[Configurable]]: false }. */
  createBuiltInPropertyWithFullDescriptor(globalObject, "undefined", 'undefined, false, false, false);

  /* 15.1.2 Function Properties of the Global Object */
  /* 15.1.2.1 eval (x) */
  eval := CreateBuiltInFunctionObject(["x"], "GlobalObjectEval", globalObject, strict, null);
  createBuiltInProperty(globalObject, "eval", eval);
  /* 15.1.2.2 parseInt (string , radix) */
  parseInt := CreateBuiltInFunctionObject(["string", "radix"], "GlobalObjectParseInt", globalObject, strict, null);
  createBuiltInProperty(globalObject, "parseInt", parseInt);
  /* 15.1.2.3 parseFloat (string) */
  parseFloat := CreateBuiltInFunctionObject(["string"], "GlobalObjectParseFloat", globalObject, strict, null);
  createBuiltInProperty(globalObject, "parseFloat", parseFloat);
  /* 15.1.2.4 isNaN (number) */
  isNaN := CreateBuiltInFunctionObject(["number"], "GlobalObjectIsNaN", globalObject, strict, null);
  createBuiltInProperty(globalObject, "isNaN", isNaN);
  /* 15.1.2.5 isFinite (number) */
  isFinite := CreateBuiltInFunctionObject(["number"], "GlobalObjectIsFinite", globalObject, strict, null);
  createBuiltInProperty(globalObject, "isFinite", isFinite);
  /* 15.1.3 URI Handling Function Properties */ /* TODO */
  /* 15.1.3.1 decodeURI (encodedURI) */
  decodeURI := CreateBuiltInFunctionObject(["encodedURI"], "GlobalObjectDecodeURI", globalObject, strict, null);
  createBuiltInProperty(globalObject, "decodeURI", decodeURI);
  /* 15.1.3.2 decodeURIComponent (encodedURIComponent) */
  decodeURIComponent := CreateBuiltInFunctionObject(["encodedURIComponent"], "GlobalObjectDecodeURIComponent", globalObject, strict, null);
  createBuiltInProperty(globalObject, "decodeURIComponent", decodeURIComponent);
  /* 15.1.3.3 encodeURI (uri) */
  encodeURI := CreateBuiltInFunctionObject(["uri"], "GlobalObjectEncodeURI", globalObject, strict, null);
  createBuiltInProperty(globalObject, "encodeURI", encodeURI);
  /* 15.1.3.4 encodeURIComponent (uriComponent) */
  encodeURIComponent := CreateBuiltInFunctionObject(["uriComponent"], "GlobalObjectEncodeURIComponent", globalObject, strict, null);
  createBuiltInProperty(globalObject, "encodeURIComponent", encodeURIComponent);

  /* 15.1.4 Constructor Properties of the Global Object */
  /* 15.1.4.1 Object ( . . . ) */
  /* 15.1.4.2 Function ( . . . ) */

  /* 15.1.4.3 Array ( . . . ) */
  ArrayObject := initArrayObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Array", ArrayObject);
  initArrayIteratorPrototype(globalObject, ObjectPrototype, strict);

  /* 15.1.4.4 String ( . . . ) */
  StringObject := initStringObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "String", StringObject);
  initStringIteratorPrototype(globalObject, ObjectPrototype, strict);
  /* 15.1.4.5 Boolean ( . . . ) */
  BooleanObject := initBooleanObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Boolean", BooleanObject);
  /* 15.1.4.7 Date ( . . . ) */
  DateObject := initDateObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Date", DateObject);
  /* 15.1.4.8 RegExp ( . . . ) */
  RegExpObject := initRegExpObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "RegExp", RegExpObject);
  /* 15.1.4.9 Error ( . . . ) */
  ErrorObject := initErrorObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Error", ErrorObject);
  /* 15.1.4.10 EvalError ( . . . ) */
  EvalErrorObject := initEvalErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "EvalError", EvalErrorObject);
  /* 15.1.4.11 RangeError ( . . . ) */
  RangeErrorObject := initRangeErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "RangeError", RangeErrorObject);
  /* 15.1.4.12 ReferenceError ( . . . ) */
  ReferenceErrorObject := initReferenceErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "ReferenceError", ReferenceErrorObject);
  /* 15.1.4.13 SyntaxError ( . . . ) */
  SyntaxErrorObject := initSyntaxErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "SyntaxError", SyntaxErrorObject);
  /* 15.1.4.14 TypeError ( . . . ) */
  TypeErrorObject := initTypeErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "TypeError", TypeErrorObject);
  /* 15.1.4.15 URIError ( . . . ) */
  URIErrorObject := initURIErrorObject(globalObject, getErrorPrototype(strict), strict);
  createBuiltInProperty(globalObject, "URIError", URIErrorObject);

  /* 15.1.5 Other Properties of the Global Object*/
  /* 15.1.5.1 Math */
  MathObject := initMathObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Math", MathObject);
  /* 15.1.5.2 JSON */
  JsonObject := initJsonObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "JSON", JsonObject);

  /* 25.4.3.1 Promise */
  PromiseObject := initPromiseObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Promise", PromiseObject);
  
  /* 20.1 Number Objects */
  NumberObject := initNumberObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Number", NumberObject);

  /* 23.1 Map */
  MapObject := initMapObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Map", MapObject);
  initMapIteratorPrototype(globalObject, ObjectPrototype, strict);
  
  symbolObject := initSymbolObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Symbol", symbolObject);

  /* 23.2 Set */
  SetObject := initSetObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "Set", SetObject);
  initSetIteratorPrototype(globalObject, ObjectPrototype, strict);

  /* 23.3 WeakMap Objects */
  WeakMapObject := initWeakMapObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "WeakMap", WeakMapObject);
  
  /* 23.4 WeakSet Objects */
  WeakSetObject := initWeakSetObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "WeakSet", WeakSetObject);

  /* 24.1 ArrayBuffer Objects */  
  ArrayBufferObject := initArrayBufferObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "ArrayBuffer", ArrayBufferObject);

  /* 24.2 DataView Objects */  
  DataViewObject := initDataViewObject(globalObject, ObjectPrototype, strict);
  createBuiltInProperty(globalObject, "DataView", DataViewObject);

  /* Extras */
  ConsoleObject := initConsoleObject(globalObject, getObjectPrototype(strict), strict);
  createBuiltInProperty(globalObject, "console", ConsoleObject);

  test262Object := initTest262Object(globalObject, getObjectPrototype(strict), strict);
  createBuiltInProperty(globalObject, "$262", test262Object);

  return globalObject
};

/* 15.1.2.1 eval (x) */
function GlobalObjectEval(externalScope, ref, this, strict, params) {
  x := getOptionalParam(params, 0);
  /* When the eval function is called with one argument x, the following steps are taken: */

  /* 1. If Type(x) is not String, return x. */
  if (!(Type(x) = "String")) {
    return x
  };
  /* 2. Let prog be the ECMAScript code that is the result of parsing x as a Program. If the parse fails, throw a
        SyntaxError exception (but see also clause 16). */
  prog := parseAsProgram(x, strict);
  /* 3. Let evalCtx be the result of establishing a new execution context (10.4.2) for the eval code prog. */
  evalCtx := EnteringEvalCode(prog, ref, externalScope);
  /* 4. Let result be the result of evaluating the program prog. */
  result := JS_Interpreter_Program(prog, evalCtx);
  /* 5. Exit the running execution context evalCtx, restoring the previous execution context. */
  /* 6. If result.type is normal and its completion value is a value V, then return the value V. */
  if ((getCompletionType(result) = 'normal) &&& !(getCompletionValue(result) = 'empty)) {
    return getCompletionValue(result)
  };
  /* 7. If result.type is normal and its completion value is empty, then return the value undefined. */
  if ((getCompletionType(result) = 'normal) &&& (getCompletionValue(result) = 'empty)) {
    return 'undefined
  };
  /* 8. Otherwise, result.type must be throw. Throw result.value as an exception. */
  throw getCompletionValue(result)
};

/* 15.1.2.1.1 Direct Call to Eval */
/* A direct call to the eval function is one that is expressed as a CallExpression that meets the following two
   conditions: */
/* The Reference that is the result of evaluating the MemberExpression in the CallExpression has an environment
   record as its base value and its reference name is "eval". */
/* The result of calling the abstract operation GetValue with that Reference as the argument is the standard built-
   in function defined in 15.1.2.1. */

/* 15.1.2.2 parseInt (string , radix) */
function GlobalObjectParseInt(globalObject, this, strict, params) {
  string := getOptionalParam(params, 0);
  radix := getOptionalParam(params, 1);
  /* The parseInt function produces an integer value dictated by interpretation of the contents of the string
      argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0,
      it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix
      of 16 is assumed. If radix is 16, the number may also optionally begin with the character pairs 0x or 0X. */

  /* When the parseInt function is called, the following steps are taken: */

  /* 1. Let inputString be ToString(string). */
  input := ToString(string);
  return int_of_string input /* TODO missing use of radix?? */
  /* 2. Let S be a newly created substring of inputString consisting of the first character that is not a
        StrWhiteSpaceChar and all characters following that character. (In other words, remove leading white
        space.) If inputString does not contain any such characters, let S be the empty string. */
  /* 3. Let sign be 1. */
  /* 4. If S is not empty and the first character of S is a minus sign -, let sign be -1. */
  /* 5. If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove the first character
        from S. */
  /* 6. Let R = ToInt32(radix). */
  /* 7. Let stripPrefix be true. */
  /* 8. If R <> 0, then */
    /* a. If R < 2 or R > 36, then return NaN. */
    /* b. If R <> 16, let stripPrefix be false. */
  /* 9. Else, R = 0 */
    /* a. Let R = 10. */
  /* 10. If stripPrefix is true, then */
    /* a. If the length of S is at least 2 and the first two characters of S are either "0x" or "0X", then remove
          the first two characters from S and let R = 16. */
  /* 11. If S contains any character that is not a radix-R digit, then let Z be the substring of S consisting of all
         characters before the first such character; otherwise, let Z be S. */
  /* 12. If Z is empty, return NaN. */
  /* 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters
         A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20
         significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the
         implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent
         approximation to the mathematical integer value that is represented by Z in radix-R notation.) */
  /* 14. Let number be the Number value for mathInt. */
  /* 15. Return sign x number. */
};

/* 15.1.2.2 parseInt (string , radix) */
function GlobalObjectParseIntAlt(globalObject, this, strict, params) {
  string := getOptionalParam(0, params);
  radix := getOptionalParam(1, params);
  /* 1. Let inputString be ToString(string). */
  inputString := ToString(string);
  /* 2. ReturnIfAbrupt(string). */
  @ReturnIfAbrupt(string);
  /* 3. Let S be a newly created substring of inputString consisting
  of the first code unit that is not a StrWhiteSpaceChar and all code 
  units following that code unit. 
  (In other words, remove leading white space.) 
  If inputString does not contain any such code unit, let S be the empty string. */
  S := inputString;
  len := s_len_u(inputString);
  while (s_nth(inputString, index) = " ") {
    if (len = 0) {
      S := ""
      /* TODO break */
    };
    S := s_substr_u(S, 1, len - 1);
    len := len - 1
  };
  /* 4. Let sign be 1. */
  sign := 1;
  /* 5. PARSING ERROR If S is not empty and the first code unit of S is 0x002D
  (HYPHEN-MINUS), let sign be −1. */
  /* if (!(S = "")) &&& s_nth(0, S) = "-" {
    sign := -1
  };*/
  /* 6. PARSING ERROR If S is not empty and the first code unit of S is 0x002B (PLUS SIGN)
  or 0x002D (HYPHEN-MINUS), remove the first code unit from S. */
  /* if (!(S = "")) &&& s_nth(0, S) = "+" || s_nth(0, S) = "-" {
    S := s_substr_u(1, S)
  }; */
  /* 7. Let R = ToInt32(radix). */
  R := ToInt32(radix);
  /* 8. ReturnIfAbrupt(R). */
  @ReturnIfAbrupt(R);
  /* 9. Let stripPrefix be true. */
  stripPrefix := true;
  /* 10. If R ≠ 0, then */
  if (!(R = 0)) {
    /* a. If R < 2 or R > 36, return NaN. */
    if (R < 2 || R > 36) {
      return NaN
    };
    /* b.If R ≠ 16, let stripPrefix be false. */
    if (!(R = 16)) {
      stripPrefix = false
    }
  /* 11. Else R = 0, */
  } else {
    /* a. Let R = 10. */
    R := 10
  };
  /* 12. If stripPrefix is true, then */
  if (stripPrefix = true) {
    /* a. If the length of S is at least 2 and the first
    two code units of S are either "0x" or "0X", remove the
    first two code units from S and let R = 16. */
    len := s_len_u(S);
    if (len >= 2 &&& (s_nth(0, S) = "0x" || s_nth(0, S) ="0X") &&& (s_nth(1, S) = "0x" || s_nth(1, S) ="0X")) {
      S := s_nth(2, len);
      R := 16
    }
  }
  /* 13. TODO If S contains a code unit that is not a radix-R digit,
  let Z be the substring of S consisting of all code units before
  the first such code unit; otherwise, let Z be S. */
  /* 14. If Z is empty, return NaN. */
  /* 15. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the mathematical integer value that is represented by Z in radix-R notation.) */
  /* 16. If mathInt = 0, then */
  /* a. If sign = −1, return −0. */
  /* b. Return +0. */
  /* 17. Let number be the Number value for mathInt. */
  /* 18. Return sign × number. */
};

/* 15.1.2.3 parseFloat (string) */
function GlobalObjectParseFloat(globalObject, this, strict, params) {
  string := getOptionalParam(params, 0);
  /* The parseFloat function produces a Number value dictated by interpretation of the contents of the string
     argument as a decimal literal. */

  /* When the parseFloat function is called, the following steps are taken: */

  /* 1. Let inputString be ToString(string). */
  inputString := ToString(string);
  return float_of_string inputString
  /* 2. Let trimmedString be a substring of inputString consisting of the leftmost character that is not a
        StrWhiteSpaceChar and all characters to the right of that character. (In other words, remove leading white
        space.) If inputString does not contain any such characters, let trimmedString be the empty string. */
  /* 3. If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see
        9.3.1), return NaN. */
  /* 4. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies
        the syntax of a StrDecimalLiteral. */
  /* 5. Return the Number value for the MV of numberString. */

  /* NOTE parseFloat may interpret only a leading portion of string as a Number value; it ignores any characters that
          cannot be interpreted as part of the notation of an decimal literal, and no indication is given that any such characters were
          ignored. */
};

/* 15.1.2.3 parseFloat (string) */
function GlobalObjectParseFloatAlt(globalObject, this, strict, params) {
  string := getOptionalParam(params, 0);
  /* 1. Let inputString be ToString(string). */
  inputString := ToString(string);
  /* 2. ReturnIfAbrupt(inputString). */
  @ReturnIfAbrupt(inputString);
  /* 3. Let trimmedString be a substring of inputString
  consisting of the leftmost code unit that is not a StrWhiteSpaceChar
  and all code units to the right of that code unit.
  (In other words, remove leading white space.) 
  If inputString does not contain any such code units, let trimmedString be the empty string. */
  trimmedString := inputString;
  len := s_len_u(inputString);
  while (s_nth(inputString, index) = " ") {
    if (len = 0) {
      trimmedString := ""
      /* TODO break */
    };
    trimmedString := s_substr_u(trimmedString, 1, len - 1);
    len := len - 1
  };
  /* TODO */
  /* 4. If neither trimmedString nor any prefix of trimmedString satisfies
  the syntax of a StrDecimalLiteral (see 7.1.3.1), return NaN. */
  /* 5. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself,
  that satisfies the syntax of a StrDecimalLiteral. */

  /* 6. TODO Let mathFloat be MV of numberString. */
  
  /* 7. If mathFloat=0, then */
  if (mathFloat = 0) {
    /* a. If the first code unit of trimmedString is "-", return −0. */
    if (s_nth(0, trimmedString) =  "-") {
      return -(0.)
    };
    /* b. Return +0. */
    return 0.
  };
  /* 8. Return the Number value for mathFloat. */
  return mathFloat
};

/* 15.1.2.4 isNaN (number) */
function GlobalObjectIsNaN(globalObject, this, strict, params) {
  number := getOptionalParam(params, 0);
  /* Returns true if the argument coerces to NaN, and otherwise returns false. */

  /* 1. If ToNumber(number) is NaN, return true. */
  if (ToNumber(number) = NaN) {
    return true
  };
  /* 2. Otherwise, return false. */
  return false

  /* NOTE A reliable way for ECMAScript code to test if a value X is a NaN is an expression of the form X !== X. The
          result will be true if and only if X is a NaN. */
};

/* 15.1.2.5 isFinite (number) */
function GlobalObjectIsFinite(globalObject, this, strict, params) {
  number := getOptionalParam(params, 0);
  /* Returns false if the argument coerces to NaN, +Infinity, or -Infinity, and otherwise returns true. */

  /* 1. If ToNumber(number) is NaN, +Infinity, or -Infinity, return false.*/
  if ((ToNumber(number) = NaN) ||| (ToNumber(number) = Infinity) ||| (ToNumber(number) = -Infinity)) {
    return false
  };
  /* 2. Otherwise, return true. */
  return true
};

/* 15.1.3 URI Handling Function Properties */ /* TODO */
/* 15.1.3.1 decodeURI (encodedURI) */
/* 15.1.3.2 decodeURIComponent (encodedURIComponent) */
/* 15.1.3.3 encodeURI (uri) */
/* 15.1.3.4 encodeURIComponent (uriComponent) */

/* Auxiliary functions */
function parseAsProgram(progStr, strict) {
  if (strict) {
    progStr := s_concat ["\"use strict\";", progStr]
  };
  prog := extern parseJS(progStr);
  progObj := {prog}();
  progObj.codeType := "eval";

  return progObj
};

function optimizeInitGlobalObject(strict) {
  if ((typeof strict = __$Bool) &&& strict) {
    loc_global := extern loadInitialHeap("globalHeap_strict.json")
  } else {
    loc_global := extern loadInitialHeap("globalHeap.json")
  };

  |global| := loc_global;

  return loc_global
}
