/* 20.1 Number Objects */
function initNumberObject(global, objectPrototype, strict) {
  numberPrototype := initNumberPrototype(global, objectPrototype, strict);
  numberConstructor := initNumberConstructor(numberPrototype, global, strict);
  return numberConstructor
};


/* 20.1.3 Properties of the Number Prototype Object */
function initNumberPrototype(global, objectPrototype, strict) {
  numberPrototypeObject := NewECMAScriptObject();
  setAllInternalMethodsOfObject(numberPrototypeObject);

  /* The value of the [[Prototype]] internal slot of the Number prototype object is the intrinsic object %ObjectPrototype% */
  setInternalProperty(numberPrototypeObject, "Prototype", objectPrototypeObject);

  /* TODO 20.1.3.1 Number.prototype.constructor */
  createBuiltInProperty(numberPrototypeObject, "constructor", NumberConstructor);

  /* 20.1.3.2 Number.prototype.toExponential ( fractionDigits ) */
  toExponential := CreateBuiltInFunctionObject(["items"], "NumberPrototypeToExponential", global, strict, null);
  setJSProperty(toExponential, "length", newDataPropertyDescriptorFull(1, true, false, false));
  createBuiltInProperty(numberPrototypeObject, "toExponential", toExponential);

  /* 20.1.3.3 Number.prototype.toFixed ( fractionDigits ) */
  toFixed := CreateBuiltInFunctionObject(["items"], "NumberPrototypeToFixed", global, strict, null);
  setJSProperty(toFixed, "length", newDataPropertyDescriptorFull(1, true, false, false));
  createBuiltInProperty(numberPrototypeObject, "toFixed", toFixed);

  /* 20.1.3.4 Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ]) */
  toLocaleString := CreateBuiltInFunctionObject(["items"], "NumberPrototypeToLocaleString", global, strict, null);
  setJSProperty(toFixed, "length", newDataPropertyDescriptorFull(0, true, false, false));
  createBuiltInProperty(numberPrototypeObject, "toLocaleString", toLocaleString);

  /* 20.1.3.5 Number.prototype.toPrecision ( precision ) */
  toPrecision := CreateBuiltInFunctionObject(["items"], "NumberPrototypeToPrecision", global, strict, null);
  setJSProperty(toFixed, "length", newDataPropertyDescriptorFull(1, true, false, false));
  createBuiltInProperty(numberPrototypeObject, "toPrecision", toPrecision);

  /* 20.1.3.6 Number.prototype.toString ( [ radix ] ) */
  toString := CreateBuiltInFunctionObject([ "radix" ], "NumberProtoypeToString", global, strict, 0.);
  createBuiltInProperty(numberPrototypeObject, "toString", toString);

  /* 20.1.3.7 Number.prototype.valueOf ( ) */
  valueOf := CreateBuiltInFunctionObject([], "NumberPrototypeValueOf", global, strict, null);
  createBuiltInProperty(numberPrototypeObject, "valueOf", valueOf);

  return prototype
};


function getNumberPrototype(strict) {
  refNumber := newPropertyReference(|global|, "Number", strict);
  NumberObject := GetValue(refNumber);
  refNumberProto := newPropertyReference(NumberObject, "prototype", strict);
  objectNumberProto := GetValue(refNumberProto);
  return objectNumberProto
};


/* 20.1.1.1 Number ( [ value ] ) */
function NumberConstructor(global, this, strict, items) {
  NewTarget := this;

  /* 1. If no arguments were passed to this function invocation, let n be +0. */
  if (value = null) {
    return 0.

  /* 2. Else, let n be ToNumber(value). */
  } else {
    n := ToNumber(value);

    /* 3. ReturnIfAbrupt(n). */
    @ReturnIfAbrupt(n);

    /* 4. If NewTarget is undefined, return n. */
    if (NewTarget = 'undefined) {
      return n
    };

    /* 5. Let O be OrdinaryCreateFromConstructor(NewTarget, "%NumberPrototype%", «[[NumberData]]» ). */
    O := OrdinaryCreateFromConstructorNumber(NewTarget, this, strict, items);

    /* 6. ReturnIfAbrupt(O). */
    @ReturnIfAbrupt(O);

    /* 7. Set the value of O’s [[NumberData]] internal slot to n. */
    O.NumberData := n;

    /* 8. Return O. */
    return O
  }
};


/* 20.1.1 The Number Constructor */
function initNumberConstructor(NumberPrototype, globalObject, strict) {
  /* 20.1.2 Properties of the Number Constructor */
  NumberConstructor := CreateFunctionObject(["value"], "NumberConstructor", globalObject, strict, 0.);

  /* The value of the [[Prototype]] internal slot of the Number constructor is the intrinsic object %FunctionPrototype% */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "prototype", NumberPrototype, false, false, false);

  /* TODO 20.1.2.1 Number.EPSILON */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "EPSILON", EPSILON, false, false, false);

  /* 20.1.2.2 Number.isFinite ( number ) */
  isFiniteObject := CreateBuiltInFunctionObject(["items"], "numberConstructorIsfinite", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(isFiniteObject, true, false, true);
  setJSProperty(prototype, "isFinite", descriptor);

  /* TODO 20.1.2.3 Number.isInteger ( number ) */
  isIntegerObject := CreateBuiltInFunctionObject(["items"], "numberConstructorIsInteger", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(isIntegerObject, true, false, true);
  setJSProperty(prototype, "isInteger", descriptor);

  /* 20.1.2.4 Number.isNaN ( number ) */
  isNaNObject := CreateBuiltInFunctionObject(["items"], "numberConstructorIsNaN", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(isNaNObject, true, false, true);
  setJSProperty(prototype, "isNaN", descriptor);

  /* 20.1.2.5 Number.isSafeInteger ( number ) */
  isSafeIntegerObject := CreateBuiltInFunctionObject(["items"], "numberConstructorIsSafeInteger", global, strict, 0.);
  descriptor := newDataPropertyDescriptorFull(isSafeIntegerObject, true, false, true);
  setJSProperty(prototype, "isSafeInteger", descriptor);

  /* 20.1.2.6 TODO Number.MAX_SAFE_INTEGER */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "MAX_SAFE_INTEGER", MAX_SAFE_INTEGER, false, false, false);

  /* 20.1.2.7 Number.MAX_VALUE */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "MAX_VALUE", MAX_VALUE, false, false, false);

  /* 20.1.2.8 TODO Number.MIN_SAFE_INTEGER */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "MIN_SAFE_INTEGER", MIN_SAFE_INTEGER, false, false, false);

  /* 20.1.2.9 Number.MIN_VALUE */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "MIN_VALUE", MIN_VALUE, false, false, false);

  /* 20.1.2.10 Number.NaN */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "NaN", NaN, false, false, false);

  /* 20.1.2.11 Number.NEGATIVE_INFINITY */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "NEGATIVE_INFINITY", -Infinity, false, false, false);

  /* TODO 20.1.2.12 Number.parseFloat ( string ) */
  /* The value of the Number.parseFloat data property is the same built-in function object that is the value 
  of the parseFloat property of the global object defined in 18.2.4. */

  /* TODO 20.1.2.13 Number.parseInt ( string, radix ) */
  /* The value of the Number.parseInt data property is the same built-in function object that is the value
   of the parseInt property of the global object defined in 18.2.5. */

  /* 20.1.2.14 Number.POSITIVE_INFINITY */
  createBuiltInPropertyWithFullDescriptor(NumberConstructor, "POSITIVE_INFINITY", Infinity, false, false, false);

  return NumberConstructor
};


/* 20.1.2.2 Number.isFinite ( number ) */
function numberConstructorIsFinite(global, this, strict, args) {
  number := l_nth(args, 0);
  /* 1. If Type(number) is not Number, return false. */
  if (!(Type(number) = "Number")) {
    return false
  };
  /* 2. If number is NaN, +∞, or −∞, return false. */
  if (number = NaN || number = Infinity || number = -Infinity) {
    return false
  };
  /* 3. Otherwise, return true. */
  return true
};


/* 20.1.2.3 Number.isInteger ( number ) */
function numberConstructorIsInteger(global, this, strict, args) {
  number := l_nth(args, 0);

  /* If Type(number) is not Number, return false. */
  if (!(Type(number) = "Number")) {
    return false
  };

  /* If number is NaN, +∞, or −∞, return false. */
  if (number = NaN || number = Infinity || number = -Infinity) {
    return false
  };

  /* Let integer be ToInteger(number). */
  integer := ToInteger(number);

  /* If integer is not equal to number, return false. */
  if (!(integer = number)) {
    return false
  };

  /* Otherwise, return true. */
  return true
};


/* 20.1.2.4 Number.isNaN ( number ) */
function numberConstructorIsNaN(global, this, strict, args) {
  number := l_nth(args, 0);
  /* 1. If Type(number) is not Number, return false. */
  if (!(Type(number) = "Number")) {
    return false
  };
  /* 2. If number is NaN, return true. */
  if (number = NaN) {
    return true
  };
  /* 3. Otherwise, return false. */
  return false
};


/* 20.1.2.5 Number.isSafeInteger ( number ) */
function numberConstructorIsSafeInteger(global, this, strict, args) {
  number := l_nth(args, 0);
  /* 1. If Type(number) is not Number, return false. */
  if (!(Type(number) = "Number")) {
    return false
  };
  /* 2. If number is NaN, +∞, or −∞, return false. */
  if (number = NaN || number = Infinity || number = -Infinity) {
    return false
  };
  /* 3. Let integer be ToInteger(number). */
  integer := ToInteger(number);
  /* 4. If integer is not equal to number, return false. */
  if (!(integer = number)) {
    return false
  };
  /* 5. TODO If abs(integer) ≤ 2^53 − 1, return true. */
  if (abs(integer) <=  (2^53 - 1)) {
    return true
  };
  /* 6. Otherwise, return false. */
  return false
};


/* 20.1.3.2 Number.prototype.toExponential ( fractionDigits ) */
function NumberPrototypeToExponential(global, this, strict, args) {
  fractionDigits := l_nth(args, 0);
  /* 1. Let x be thisNumberValue(this value). */
  x := thisNumberValue(this);
  /* 2. ReturnIfAbrupt(x). */
  ReturnIfAbrupt(x);
  /* 3. Let f be ToInteger(fractionDigits). */
  f := ToInteger(fractionDigits);
  /* 4. Assert: f is 0, when fractionDigits is undefined. */
  if (fractionDigits = 'undefined) {
    assert f = 0
  };
  /* 5. ReturnIfAbrupt(f). */
  ReturnIfAbrupt(f);
  /* 6. TODO If x is NaN, return the String "NaN". */
  if (x = NaN) {
    return "NaN"
  };
  /* 7. Let s be the empty String. */
  s := "";
  /* 8. If x < 0, then */
  if (x < 0) {
    /* a. Let s be "-". */
    s := "-";
    /* b. Let x = –x. */
    x := -x
  };
  /* 9. If x = +∞, then */
  if (x = Infinity) {
    /* a. TODO Return the concatenation of the Strings s and "Infinity". */
    return s + "Infinity"
  };
  /* 10. If f < 0 or f > 20, throw a RangeError exception.
  /* However, an implementation is permitted to extend the behaviour of toExponential
  for values of f less than 0 or greater than 20. In this case toExponential would not
  necessarily throw RangeError for such values. */
  if (f < 0 || f > 20) {
    throw RangeErrorConstructorInternal()
  };
  /* 11. If x = 0, then */
  if (x = 0) {
    /* a. TODO Let m be the String consisting of f+1 occurrences of the code unit 0x0030 (DIGIT ZERO). */
    /* b. Let e = 0. */
  /* 12. Else x ≠ 0, */
  } else {
    /* a. If fractionDigits is not undefined, then */
    if (!(fractionDigits = 'undefined)) {
      /* i. TODO Let e and n be integers such that 10f ≤ n < 10f+1 and for which the exact mathematical
      value of n × 10e–f – x is as close to zero as possible. If there are two such sets of e and n,
      pick the e and n for which n × 10e–f is larger. */
    /* b. Else fractionDigits is undefined, */
    } else {
      /* i. TODO Let e, n, and f be integers such that f ≥ 0, 10f ≤ n < 10f+1,
      the Number value for n × 10e–f is x, and f is as small as possible.
      Note that the decimal representation of n has f+1 digits, n is not divisible by 10,
      and the least significant digit of n is not necessarily uniquely determined by these criteria. */
    }
    /* c. TODO Let m be the String consisting of the digits of the decimal representation of n
    (in order, with no leading zeroes). */
  };
  /* 13. If f ≠ 0, then */
  if (!(f = 0)) {
    /* a. TODO Let a be the first element of m, and let b be the remaining f elements of m. */
    a := l_nth(m, 0)
    /* b. TODO Let m be the concatenation of the three Strings a, ".", and b. */
  };
  /* 14. If e = 0, then */
  if (e = 0) {
    /* Let c = "+". */
    c := "+";
    /* Let d = "0". */
    d := "0"
  /* 15. Else */
  } else {
    /* a. If e > 0, let c = "+". */
    if (e > 0) {
      c := "+"
    /* b. Else e ≤ 0, */
    } else {
      /* i. Let c = "-". */
      c := "-";
      /* ii. Let e = –e. */
      e := -e
    }
    /* c. TODO Let d be the String consisting of the digits of the decimal representation of e
    (in order, with no leading zeroes). */
  }
  /* 16. TODO Let m be the concatenation of the four Strings m, "e", c, and d. */
  /* 17. TODO Return the concatenation of the Strings s and m. */
};


/* 20.1.3.3 Number.prototype.toFixed ( fractionDigits ) */
function NumberPrototypeToFixed(global, this, strict, args) {
  /* 1. Let x be thisNumberValue(this value). */
  x := thisNumberValue(this.value);
  /* 2. ReturnIfAbrupt(x). */
  ReturnIfAbrupt(x);
  /* 3. Let f be ToInteger(fractionDigits).
  (If fractionDigits is undefined, this step produces the value 0). */
  f := ToInteger(fractionDigits);
  /* 4. ReturnIfAbrupt(f). */
  ReturnIfAbrupt(f);
  /* 5. If f < 0 or f > 20, throw a RangeError exception.
  However, an implementation is permitted to extend the
  behaviour of toFixed for values of f less than 0 or
  greater than 20. In this case toFixed would not necessarily
  throw RangeError for such values. */
  if (x < 0 || f > 20) {
    throw RangeErrorConstructorInternal()
  };
  /* 6. If x is NaN, return the String "NaN". */
  if (x = NaN) {
    return "NaN"
  };
  /* 7. Let s be the empty String. */
  s := "";
  /* 8. If x < 0, then */
  if (x < 0) {
  /* a. Let s be "-". */
  s := "-";
  /* b. Let x = –x. */
  x := -x
  };
  /* 9. TODO If x ≥ 10^21, then */
  if (x >= 10^21) {
    /* a. Let m = ToString(x). */
    /* 10. Else x < 1021, */
  } else {
    /* a. Let n be an integer for which the exact mathematical value of n ÷ 10f – x is as close to zero as possible. If there are two such n, pick the larger n. */
    /* b. If n = 0, let m be the String "0". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes). */
    /* c. If f ≠ 0, then */
    if (!(f = 0)) {
      /* i. TODO Let k be the number of elements in m. */
      /* ii. If k ≤ f, then */
      if (k <= f) {
        /* 1. TODO Let z be the String consisting of f+1–k occurrences of the code unit 0x0030 (DIGIT ZERO). */
        /* 2. TODO Let m be the concatenation of Strings z and m. */
        /* 3. Let k = f + 1. */
        k := f + 1
      }
      /* TODO iii. Let a be the first k–f elements of m, and let b be the remaining f elements of m. */
    }
  }
  /* iv. TODO Let m be the concatenation of the three Strings a, ".", and b. */
  /* 11. TODO Return the concatenation of the Strings s and m. */
};


/* 20.1.3.4 Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ]) */
function NumberPrototypeToLocaleString(global, this, strict, args) {
  return
};


/* 20.1.3.5 Number.prototype.toPrecision ( precision ) */
function NumberPrototypeToPrecision(global, this, strict, args) {
  precision := l_nth(args, 0);
  /* 1. Let x be thisNumberValue(this value). */
  x := thisNumberValue(this);
  /* 2. ReturnIfAbrupt(x). */
  ReturnIfAbrupt(x);
  /* 3. If precision is undefined, return ToString(x). */
  if (precision = 'undefined) {
    return ToString(x)
  };
  /* 4. Let p be ToInteger(precision). */
  p := ToInteger(precision);
  /* 5. ReturnIfAbrupt(p). */
  ReturnIfAbrupt(p);
  /* 6. If x is NaN, return the String "NaN". */
  if (x = NaN) {
    return "NaN"
  };
  /* 7. Let s be the empty String. */
  s := "";
  /* 8. If x < 0, then */
  if (x < 0) {
    /* a. TODO Let s be code unit 0x002D (HYPHEN-MINUS). */
    /* b. Let x = –x. */
    x := -x
  };
  /* 9. If x = +∞, then */
  if (x = Infinity) {
    /* a. TODO Return the String that is the concatenation of s and "Infinity". */
  };
  /* 10. If p < 1 or p > 21, throw a RangeError exception. However, an implementation is permitted
  to extend the behaviour of toPrecision for values of p less than 1 or greater
  than 21. In this case toPrecision would not necessarily throw RangeError for such values. */
  if (p < 1 || p > 21) {
    throw RangeErrorConstructorInternal()
  };
  /* 11. If x = 0, then */
  if (x = 0) {
    /* a. TODO Let m be the String consisting of p occurrences of the code unit 0x0030 (DIGIT ZERO). */
    /* b. Let e = 0. */
    e := 0
  /* 12. Else x ≠ 0, */
  } else {
    /* a. TODO Let e and n be integers such that 10 p–1 ≤ n < 10 p and for which
    the exact mathematical value of n × 10 e–p+1 – x is as close to zero as possible.
    If there are two such sets of e and n, pick the e and n for which n × 10 e–p+1 is larger. */

    /* b. TODO Let m be the String consisting of the digits of the decimal representation of n
    (in order, with no leading zeroes). */

    /* c. If e < –6 or e ≥ p, then */
    if (e < -6 || e >= p) {
      /* i. Assert: e ≠ 0 */
      assert (!(e = 0));
      /* ii. TODO Let a be the first element of m, and let b be the remaining p–1 elements of m. */
      /* iii. TODO Let m be the concatenation of a, code unit 0x002E (FULL STOP), and b. */
      /* iv. If e > 0, then */
      if (e > 0) {
        /* 1. Let c be code unit 0x002B (PLUS SIGN). */
        c := "+"
      /* v. Else e < 0, */
      } else {
        /* 1. Let c be code unit 0x002D (HYPHEN-MINUS). */
        c := "-";
        /* 2. Let e = –e. */
        e := -e
      }
      /* vi. TODO Let d be the String consisting of the digits of the decimal representation of e
      (in order, with no leading zeroes). */
      /* TODO vii. Return the concatenation of s, m, code unit 0x0065 (LATIN SMALL LETTER E), c, and d. */
    }
  };
  /* TODO 13. If e = p–1, return the concatenation of the Strings s and m. */
  if (e = (p - 1)) {
    return
  };
  /* 14. If e ≥ 0, then */
  if (e >= 0) {
    /* a. TODO Let m be the concatenation of the first e+1 elements of m, the code unit 0x002E (FULL STOP), and the remaining p– (e+1) elements of m. */
  /* 15. Else e < 0, */
  } else {
    /* a. TODO Let m be the String formed by the concatenation of code unit 0x0030 (DIGIT ZERO), 
    code unit 0x002E (FULL STOP), –(e+1) occurrences of code unit 0x0030 (DIGIT ZERO), and the String m. */
  }
  /* 16. TODO Return the String that is the concatenation of s and m. */
};


/* 20.1.3.6 Number.prototype.toString ( [ radix ] ) */
function numberPrototypeToString(global, this, strict, args) {
  radix := l_nth(args, 0);

  /* 1. Let x be thisNumberValue(this value). */
  x := thisNumberValue(this);
  /* 2. ReturnIfAbrupt(x). */
  ReturnIfAbrupt(x);
  /* 3. If radix is not present, let radixNumber be 10. */
  if (radix = null) {
    radixNumber := 10
  /* 4. Else if radix is undefined, let radixNumber be 10. */
  } elif (radix = 'undefined) {
    radixNumber := 10
  /* 5. Else let radixNumber be ToInteger(radix). */
  } else {
    radixNumber := ToInteger(radix)
  };
  /* 6. ReturnIfAbrupt(radixNumber). */
  ReturnIfAbrupt(radixNumber);
  /* 7. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception. */
  if (radixNumber < 2 || radixNumber > 36) {
    throw RangeErrorConstructorInternal()
  };
  /* 8. If radixNumber = 10, return ToString(x). */
  if (radixNumber = 10) {
    return ToString(x)
  };
  /* 9. TODO Return the String representation of this Number value using the radix specified by radixNumber.
  Letters a-z are used for digits with values 10 through 35. The precise algorithm is implementation-dependent,
  however the algorithm should be a generalization of that specified in 7.1.12.1. */
  return
};


/* 20.1.3.7 Number.prototype.valueOf ( ) */
function NumberProtoypeValueOf(global, this, strict, items) {
  /* 1. Let x be thisNumberValue(this value). */
  x := thisNumberValue(this);
  /* 2. Return x. */
  return x
};


/* 20.1.3 Abstract Operation thisNumberValue(value) */
function thisNumberValue(value) {
  /* 1. If Type(value) is Number, return value. */
  if (Type(value) = "Number") {
    return value
  };

  /* 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then */
  if (Type(Value) = "Object" &&& "NumberData" in_obj value) {

    /* a. Assert: value’s [[NumberData]] internal slot is a Number value. */
    assert Type(value.NumberData) = "Number";

    /* b. Return the value of value’s [[NumberData]] internal slot. */
    return value.NumberData
  };

  /* 3. Throw a TypeError exception. */
  throw TypeErrorConstructorInternal()
};


/* OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto, internalSlotsList ) */
function OrdinaryCreateFromConstructorNumber(global, this, strict, items) {
  numberPrototype := getNumberPrototype(strict);

  newlyConstructedObject := NewECMAScriptObject();
  setAllInternalMethodsOfObject(newlyConstructedObject);

  setInternalProperty(newlyConstructedObject, "Prototype", numberPrototype);
  setInternalProperty(newlyConstructedObject, "Extensible", true);
  setInternalProperty(newlyConstructedObject, "Class", "Object");

  return newlyConstructedObject
}
