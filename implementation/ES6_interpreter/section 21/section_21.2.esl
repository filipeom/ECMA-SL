/*
 * Author: Leonor Barreiros
 */

/* 21.2 RegExp (Regular Expression) Objects */

/**
 * A RegExp object contains a regular expression and the associated flags.
 *
 * NOTE The form and functionality of regular expressions is modelled after the regular 
 * expression facility in the Perl 5 programming language.
 */

function initRegExpObject(globalObject, ObjectPrototype, strict) 

};

function initRegExpPrototype(objectPrototypeObject) {

};

function initRegExpConstructor(RegExpPrototype, globalObject, strict) {

};

function fillRegExpPrototype(regExpPrototypeObject, RegExpConstructor, globalObject, strict) {

};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.1 Patterns */

/**
 * The RegExp constructor applies the following grammar to the input pattern String. 
 * An error occurs if the grammar cannot interpret the String as an expansion of Pattern.
 */

/* 21.2.1.1 Static Semantics: Early Errors */

/**
 * RegExpUnicodeEscapeSequence :: u{ HexDigits }
 * It is a Syntax Error if the MV of HexDigits > 1114111.
 */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.2 Pattern Semantics */

/**
 * This sub-section is not in this file (for now). Using the ES5 version 
 * ("ES6_interpreter/section 15/section_15.10.esl").
 * If there are any differences between the ES5 and ES6 standards, they will be highlighted as such,
 * and they will also be in the ES5 version file.
 */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.3 The RegExp Constructor */

/**
 * The RegExp constructor is the %RegExp% intrinsic object and the initial value of the RegExp property of 
 * the global object. When RegExp is called as a function rather than as a constructor, it creates and 
 * initializes a new RegExp object. Thus the function call RegExp(...) is equivalent to the object creation 
 * expression new RegExp(...) with the same arguments.
 *
 * The RegExp constructor is designed to be subclassable. It may be used as the value of an extends clause 
 * of a class definition. Subclass constructors that intend to inherit the specified RegExp behaviour must 
 * include a super call to the RegExp constructor to create and initialize subclass instances with the necessary
 * internal slots.
 */

/* 21.2.3.1 RegExp ( pattern, flags ) */
/**
 * NOTE If pattern is supplied using a StringLiteral, the usual escape sequence substitutions are performed 
 * before the String is processed by RegExp. If pattern must contain an escape sequence to be recognized by
 * RegExp, any U+005C (REVERSE SOLIDUS) code points must be escaped within the StringLiteral to prevent them
 * being removed when the contents of the StringLiteral are formed.
 */

/* 21.2.3.2 Abstract Operations for the RegExp Constructor */

/* 21.2.3.2.1 Runtime Semantics: RegExpAlloc ( newTarget ) */
function RegExpAlloc(newTarget){
   /* 1. Let obj be OrdinaryCreateFromConstructor(newTarget, "%RegExpPrototype%", «‍[[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]]»). */
   /* 2. ReturnIfAbrupt(obj). */
   /* 3. Let status be DefinePropertyOrThrow(obj, "lastIndex", PropertyDescriptor {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}). */
   /* 4. Assert: status is not an abrupt completion. */
   /* 5. Return obj. */
};

/* 21.2.3.2.2 Runtime Semantics: RegExpInitialize ( obj, pattern, flags ) */
function RegExpInitialize(obj, pattern, flags){
   /* 1. If pattern is undefined, let P be the empty String. */
   /* 2. Else, let P be ToString(pattern). */
   /* 3. ReturnIfAbrupt(P). */
   /* 4. If flags is undefined, let F be the empty String. */
   /* 5. Else, let F be ToString(flags). */
   /* 6. ReturnIfAbrupt(F). */
   /* 7. If F contains any code unit other than "g", "i", "m", "u", or "y" or if it contains the same code unit more than once, throw a SyntaxError exception. */
   /* 8. If F contains "u", let BMP be false; else let BMP be true. */
   /* 9. If BMP is true, then */
      /* a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is Pattern. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error conditions exist. */
      /* b. Let patternCharacters be a List whose elements are the code unit elements of P. */
   /* 10. Else */
      /* a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error conditions exist. */
      /* b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16 decoding to P’s sequence of elements. */
   /* 11. Set the value of obj’s [[OriginalSource]] internal slot to P. */
   /* 12. Set the value of obj’s [[OriginalFlags]] internal slot to F. */
   /* 13. Set obj’s [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern’s List of SourceCharacter values and F as the flag parameters. */ 
   /* 14. Let setStatus be Set(obj, "lastIndex", 0, true). */
   /* 15. ReturnIfAbrupt(setStatus). */
   /* 16. Return obj. */
};

/* 21.2.3.2.3 Runtime Semantics: RegExpCreate ( P, F ) */
function RegExpCreate(P, F){
   /* 1. Let obj be RegExpAlloc(%RegExp%). */
   /* 2. ReturnIfAbrupt(obj). */
   /* 3. Return RegExpInitialize(obj, P, F). */
};
/* 21.2.3.2.4 Runtime Semantics: EscapeRegExpPattern ( P, F ) */
function EscapeRegExpPattern(P, F){
   /* 1. Let S be a String in the form of a Pattern (Pattern[U] if F contains "u") equivalent to P interpreted as UTF-16 encoded Unicode code points (6.1.4), in which certain code points are escaped as described below. S may or may not be identical to P; however, the internal procedure that would result from evaluating S as a Pattern (Pattern[U] if F contains "u") must behave identically to the internal procedure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for P and F must produce identical results. */
   /* 2. The code points / or any LineTerminator occurring in the pattern shall be escaped in S as necessary to ensure that the String value formed by concatenating the Strings "/", S, "/", and F can be parsed (in an appropriate lexical context) as a RegularExpressionLiteral that behaves identically to the constructed regular expression. For example, if P is "/", then S could be "\/" or "\u002F", among other possibilities, but not "/", because /// followed by F would be parsed as a SingleLineComment rather than a RegularExpressionLiteral. If P is the empty String, this specification can be met by letting S be "(?:)". */
   /* 3. Return S. */
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.4 Properties of the RegExp Constructor */

/**
 * The value of the [[Prototype]] internal slot of the RegExp constructor is the intrinsic object 
 * %FunctionPrototype% (19.2.3).
 * Besides the length property (whose value is 2), the RegExp constructor has the following properties:
 */
/* 21.2.4.1 RegExp.prototype */
/**
 * The initial value of RegExp.prototype is the intrinsic object %RegExpPrototype% (21.2.5). This property 
 * has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.
 */
/* 21.2.4.2 get RegExp [ @@species ] */
/**
 * RegExp[@@species] is an accessor property whose set accessor function is undefined. Its get accessor 
 * function performs the following steps:
 *
 * The value of the name property of this function is "get [Symbol.species]".
 * NOTE RegExp prototype methods normally use their this object’s constructor to create a derived object. 
 * However, a subclass constructor may over-ride that default behaviour by redefining its @@species property.
 */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.5 Properties of the RegExp Prototype Object */
/**
 * The RegExp prototype object is the intrinsic object %RegExpPrototype%. The RegExp prototype object is an
 * ordinary object. It is not a RegExp instance and does not have a [[RegExpMatcher]] internal slot or any 
 * of the other internal slots of RegExp instance objects.
 *
 * The value of the [[Prototype]] internal slot of the RegExp prototype object is the intrinsic object 
 * %ObjectPrototype% (19.1.3).
 *
 * NOTE The RegExp prototype object does not have a valueOf property of its own; however, it inherits the 
 * valueOf property from the Object prototype object.
 */

/* 21.2.5.1 RegExp.prototype.constructor */
/**
 * The initial value of RegExp.prototype.constructor is the intrinsic object %RegExp%. 21.2.5.2 
 * RegExp.prototype.exec ( string )
 */

/* 21.2.5.2 RegExp.prototype.exec ( string ) */
/**
 * Performs a regular expression match of string against the regular expression and returns an Array object 
 * containing the results of the match, or null if string did not match.
 */
function RegExpPrototypeexec(global, this, strict, args){
   string := l_nth(args, 0);

   /* 1. Let R be the this value. */
   R := this;

   /* 2. If Type(R) is not Object, throw a TypeError exception. */
   if (!(Type(R) = "Object")){
      throw TypeErrorConstructorInternal()
   };

   /* 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception. */
   if (!("RegExpMatcher" in_obj R)){
      throw TypeErrorConstructorInternal()
   };

   /* 4. Let S be ToString(string). */
   S := ToString(string);

   /* 5. ReturnIfAbrupt(S). */
   @ReturnIfAbrupt(S);

   /* 6. Return RegExpBuiltinExec(R, S). */
   return RegExpBuiltinExec(R, S)
};

/* 21.2.5.2.1 Runtime Semantics: RegExpExec ( R, S ) */
/**
 * NOTE If a callable exec property is not found this algorithm falls back to attempting to use the built-in
 * RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where 
 * most built-in algorithms that use regular expressions did not perform a dynamic property lookup of exec.
 */
function RegExpExec(R, S){
   /* 1. Assert: Type(R) is Object. */
   assert(Type(R) = "Object");

   /* 2. Assert: Type(S) is String. */
   assert(Type(S) = "String");

   /* 3. Let exec be Get(R, "exec"). */
   exec := GetNew(R, "exec");

   /* 4. ReturnIfAbrupt(exec). */
   @ReturnIfAbrupt(exec);

   /* 5. If IsCallable(exec) is true, then */
   if (IsCallable(exec) = true){
      /* a. Let result be Call(exec, R, «S»). */
      result := Call(null, null, exec, R, [S]);

      /* b. ReturnIfAbrupt(result). */
      @ReturnIfAbrupt(result);

      /* c. If Type(result) is neither Object or Null, throw a TypeError exception. */
      if (!((Type(result) = "Object") || (Type(result) = "Null"))){
         throw TypeErrorConstructorInternal()
      };

      /* d. Return result. */
      return result
   };

   /* 6. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception. */
   if (!("RegExpMatcher" in_obj R)){
      throw TypeErrorConstructorInternal()
   };

   /* 7. Return RegExpBuiltinExec(R, S). */
   return RegExpBuiltinExec(R, S)
};

/* 21.2.5.2.2 Runtime Semantics: RegExpBuiltinExec ( R, S ) */
function RegExpBuiltinExec(R, S){
   /* 1. Assert: R is an initialized RegExp instance. */
   /* 2. Assert: Type(S) is String. */
   /* 3. Let length be the number of code units in S. */
   /* 4. Let lastIndex be ToLength(Get(R,"lastIndex")). */
   /* 5. ReturnIfAbrupt(lastIndex). */
   /* 6. Let global be ToBoolean(Get(R, "global")). */
   /* 7. ReturnIfAbrupt(global). */
   /* 8. Let sticky be ToBoolean(Get(R, "sticky")). */
   /* 9. ReturnIfAbrupt(sticky). */
   /* 10. If global is false and sticky is false, let lastIndex be 0. */
   /* 11. Let matcher be the value of R’s [[RegExpMatcher]] internal slot. */
   /* 12. Let flags be the value of R’s [[OriginalFlags]] internal slot. */
   /* 13. If flags contains "u", let fullUnicode be true, else let fullUnicode be false. */
   /* 14. Let matchSucceeded be false. */
   /* 15. Repeat, while matchSucceeded is false */
      /* a. If lastIndex > length, then */
         /* i. Let setStatus be Set(R, "lastIndex", 0, true). */
         /* ii. ReturnIfAbrupt(setStatus). */
         /* iii. Return null. */
      /* b. Let r be matcher(S, lastIndex). */
      /* c. If r is failure, then */
         /* i. If sticky is true, then */
            /* 1. Let setStatus be Set(R, "lastIndex", 0, true). */
            /* 2. ReturnIfAbrupt(setStatus). */
            /* 3. Return null. */
         /* ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode). */
      /* d. Else, */
         /* i. Assert: r is a State. */
         /* ii. Set matchSucceeded to true. */
   /* 16. Let e be r's endIndex value. */
   /* 17. If fullUnicode is true, then */
      /* a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S. */
      /* b. Let e be eUTF. */
   /* 18. If global is true or sticky is true, */
      /* a. Let setStatus be Set(R, "lastIndex", e, true). */
      /* b. ReturnIfAbrupt(setStatus). */
   /* 19. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.) */
   /* 20. Let A be ArrayCreate(n + 1). */
   /* 21. Assert: The value of A’s "length" property is n + 1. */
   /* 22. Let matchIndex be lastIndex. */
   /* 23. Assert: The following CreateDataProperty calls will not result in an abrupt completion. */
   /* 24. Perform CreateDataProperty(A, "index", matchIndex). */
   /* 25. Perform CreateDataProperty(A, "input", S). */
   /* 26. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive). */
   /* 27. Perform CreateDataProperty(A, "0", matchedSubstr). */
   /* 28. For each integer i such that i > 0 and i ≤ n */
      /* a. Let captureI be ith element of r's captures List. */
      /* b. If captureI is undefined, let capturedValue be undefined. */
      /* c. Else if fullUnicode is true, */
         /* i. Assert: captureI is a List of code points. */
         /* ii. Let capturedValue be a string whose code units are the UTF16Encoding (10.1.1) of the code points of captureI. */
      /* d. Else, fullUnicode is false, */
         /* i. Assert: captureI is a List of code units. */
         /* ii. Let capturedValue be a string consisting of the code units of captureI. */
      /* e. Perform CreateDataProperty(A, ToString(i) , capturedValue). */
   /* 29. Return A. */
};

/* 21.2.5.2.3 AdvanceStringIndex ( S, index, unicode ) */
function AdvanceStringIndex(S, index, unicode){
   /* 1. Assert: Type(S) is String. */
   assert(Type(S) = "String");

   /* 2. Assert: index is an integer such that 0≤index≤253-1. */
   /* assert((IsInteger(index)) && (index >= 0) && (index <= ((2^53) - 1))); */
   assert(IsInteger(index));
   assert(index >= 0.);
   assert(index <= ((2. ** 53.) - 1.));

   /* 3. Assert: Type(unicode) is Boolean. */
   assert(Type(unicode) = "Boolean");

   /* 4. If unicode is false, return index+1. */
   if (unicode = false){
      return index + 1.
   };

   /* 5. Let length be the number of code units in S. */
   length := s_len_u S;

   /* 6. If index+1 ≥ length, return index+1. */
   if (index + 1. >= length){
      return index + 1.
   };

   /* 7. Let first be the code unit value at index index in S. */
   first := s_nth(S, int_of_float index);

   /* 8. If first < 0xD800 or first > 0xDBFF, return index+1. */
   if ((first < 0xD800) || (first > 0xDBFF)){
      return index + 1.
   };

   /* 9. Let second be the code unit value at index index+1 in S. */
   second := s_nth(S, int_of_float (index + 1.));

   /* 10. If second < 0xDC00 or second > 0xDFFF, return index+1. */
   if ((second < 0xDC00) || (second > 0xDFFF)){
      return index + 1.
   };

   /* 11. Return index+2. */
   return index + 2.
};

/* 21.2.5.3 get RegExp.prototype.flags */
/**
 * RegExp.prototype.flags is an accessor property whose set accessor function is undefined. Its get accessor 
 * function performs the following steps:
 */

/* 21.2.5.4 get RegExp.prototype.global */
/**
 * RegExp.prototype.global is an accessor property whose set accessor function is undefined. Its get accessor
 * function performs the following steps:
 */

/* 21.2.5.5 get RegExp.prototype.ignoreCase */
/**
 * RegExp.prototype.ignoreCase is an accessor property whose set accessor function is undefined. Its get 
 * accessor function performs the following steps:
 */

/* 21.2.5.6 RegExp.prototype [ @@match ] ( string ) */
/**
 * The value of the name property of this function is "[Symbol.match]".
 *
 * NOTE The @@match property is used by the IsRegExp abstract operation to identify objects that have the basic
 * behaviour of regular expressions. The absence of a @@match property or the existence of such a property whose
 * value does not Boolean coerce to true indicates that the object is not intended to be used as a regular 
 * expression object.
 */
function RegExpPrototypematch(global, this, strict, args){
   string := l_nth(args, 0);

   /* 1. Let rx be the this value. */
   rx := this;

   /* 2. If Type(rx) is not Object, throw a TypeError exception. */
   if (!(Type(rx) = "Object")){
      throw TypeErrorConstructorInternal()
   };

   /* 3. Let S be ToString(string) */
   S := ToString(string);

   /* 4. ReturnIfAbrupt(S). */
   @ReturnIfAbrupt(S);

   /* 5. Let global be ToBoolean(GetES6(rx, "global")). */
   global := ToBoolean(GetNew(rx, "global"));

   /* 6. ReturnIfAbrupt(global). */
   @ReturnIfAbrupt(global);

   /* 7. If global is false, then */
   if (global = false){
      /* a. Return RegExpExec(rx, S). */
      /* return RegExpExec(rx, S) */
      return RegExpPrototypeExec(global, rx, strict, [S])
   }
   /* 8. Else global is true, */
   else{
      /* a. Let fullUnicode be ToBoolean(GetES6(rx, "unicode")). */
      /* fullUnicode := ToBoolean(GetES6(rx, "unicode")); */
      fullUnicode := false;

      /* b. ReturnIfAbrupt(fullUnicode). */
      @ReturnIfAbrupt(fullUnicode); 

      /* c. Let setStatus be Set(rx, "lastIndex", 0, true). */
      /* setStatus := Set(rx, "lastIndex", 0, true); */
      setJSProperty(rx, "lastIndex", newDataPropertyDescriptorFull(0., true, false, false));
 
      /* d. ReturnIfAbrupt(setStatus). */
      /* @ReturnIfAbrupt(setStatus); */

      /* e. Let A be ArrayCreate(0). */
      /* A := ArrayCreate(0); */
      A := ArrayConstructor(global, null, strict, []);

      /* f. Let n be 0. */
      n := 0;

      /* g. Repeat, */
      while (true){
         /* i. Let result be RegExpExec(rx, S). */
         /* result := RegExpExec(rx, S); */
         result := RegExpPrototypeExec(global, rx, strict, [S]);

         /* ii. ReturnIfAbrupt(result). */
         @ReturnIfAbrupt(result);

         /* iii. If result is null, then */
         if ((result = 'null) || (result = null)){                
            /* 1. If n=0, return null. */
            if (n = 0){
               return null
            }
            /* 2. Else, return A. */
            else{
               return A
            }
         } 
         /* iv. Else result is not null, */
         else{
            /* 1. Let matchStr be ToString(GetES6(result, "0")). */
            matchStr := ToString(GetNew(result, "0"));

            /* 2. ReturnIfAbrupt(matchStr). */
            @ReturnIfAbrupt(matchStr);

            /* 3. Let status be CreateDataProperty(A, ToString(n), matchStr). */
            status := CreateDataPropertyNew(A, ToString(int_to_float n), matchStr);

            /* 4. Assert: status is true. */
            /* assert(status = true); */

            /* 5. If matchStr is the empty String, then */
            if (matchStr = ""){
               /* a. Let thisIndex be ToLength(GetES6(rx, "lastIndex")). */
               thisIndex := ToLength(GetNew(rx, "lastIndex"));

               /* b. ReturnIfAbrupt(thisIndex). */
               @ReturnIfAbrupt(thisIndex);

               /* c. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode). */
               nextIndex := AdvanceStringIndex(S, thisIndex, fullUnicode);

               /* d. Let setStatus be Set(rx, "lastIndex", nextIndex, true). */
               /* setStatus := Set(rx, "lastIndex", nextIndex, true); */
               setJSProperty(rx, "lastIndex", newDataPropertyDescriptorFull(nextIndex, true, false, false))
                    
               /* e. ReturnIfAbrupt(setStatus). */
               /* @ReturnIfAbrupt(setStatus) */
            };
                    
            /* 6. Increment n. */
            n := n + 1
         }   
      }    
   }
};

/* 21.2.5.7 get RegExp.prototype.multiline */
/**
 * RegExp.prototype.multiline is an accessor property whose set accessor function is undefined. Its get 
 * accessor function performs the following steps:
 */

/* 21.2.5.8 RegExp.prototype [ @@replace ] ( string, replaceValue ) */
/**
 * The value of the name property of this function is "[Symbol.replace]".
 */
function RegExpPrototypereplace(global, this, strict, args){
   string := l_nth(args, 0);
   replaceValue := l_nth(args, 1);
    
   /* 1. Let rx be the this value. */
   rx := this;

   /* 2. If Type(rx) is not Object, throw a TypeError exception. */
   if (!(Type(rx) = "Object")){
      throw TypeErrorConstructorInternal()
   };

   /* 3. Let S be ToString(string). */
   S := ToString(string);

   /* 4. ReturnIfAbrupt(S). */
   @ReturnIfAbrupt(S);

   /* 5. Let lengthS be the number of code unit elements in S. */
   lengthS := s_len_u S;

   /* 6. Let functionalReplace be IsCallable(replaceValue). */
   functionalReplace := IsCallable(replaceValue);

   /* 7. If functionalReplace is false, then */
   if (functionalReplace = false){
      /* a. Let replaceValue be ToString(replaceValue). */
      replaceValue := ToString(replaceValue);

      /* b. ReturnIfAbrupt(replaceValue). */
      @ReturnIfAbrupt(replaceValue)
   };
        
   /* 8. Let global be ToBoolean(GetES6(rx, "global")). */
   global_ := ToBoolean(GetNew(rx, "global")); 

   /* 9. ReturnIfAbrupt(global). */
   @ReturnIfAbrupt(global_);

   /* 10. If global is true, then */
   if (global_ = true){
      /* a. Let fullUnicode be ToBoolean(Get(rx, "unicode")). */
      /* fullUnicode := ToBoolean(GetNew(rx, "unicode")); */
      fullUnicode := false;

      /* b. ReturnIfAbrupt(fullUnicode). */
      @ReturnIfAbrupt(fullUnicode);

      /* c. Let setStatus be Set(rx, "lastIndex", 0, true). */
      /* setStatus := Set(rx, "lastIndex", 0, true); */
      setJSProperty(rx, "lastIndex", newDataPropertyDescriptorFull(0., true, false, false))

      /* d. ReturnIfAbrupt(setStatus). */
      /* @ReturnIfAbrupt(setStatus) */
   };

   /* 11. Let results be a new empty List. */
   results := [];

   /* 12. Let done be false. */
   done := false;

   /* 13. Repeat, while done is false */
   while (done = false){
      /* a. Let result be RegExpExec(rx, S). */
      /* result := RegExpExec(rx, S); */
      result := RegExpPrototypeExec(global, rx, strict, [S]);

      /* b. ReturnIfAbrupt(result). */
      @ReturnIfAbrupt(result);

      /* c. If result is null, set done to true. */
      if ((result = 'null) || (result = null)){
         done := true
      }
      /* d. Else result is not null, */
      else{
         /* i. Append result to the end of results. */
         results := l_concat(results, [result]);

         /* ii. If global is false, set done to true. */
         if (global_ = false){
            done := true
         }
         /* iii. Else, */
         else{
            /* 1. Let matchStr be ToString(GetES6(result, "0")). */
            matchStr := ToString(GetNew(result, "0"));

            /* 2. ReturnIfAbrupt(matchStr). */
            @ReturnIfAbrupt(matchStr);

            /* 3. If matchStr is the empty String, then */
            if (matchStr = ""){ 
               /* a. Let thisIndex be ToLength(Get(rx, "lastIndex")). */
               /* thisIndex := ToLength(GetES6(rx, "lastIndex")); */
               thisIndex := ToLength(GetNew(rx, "lastIndex"));

               /* b. ReturnIfAbrupt(thisIndex). */
               @ReturnIfAbrupt(thisIndex);

               /* c. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode). */
               nextIndex := AdvanceStringIndex(S, thisIndex, fullUnicode);

               /* d. Let setStatus be Set(rx, "lastIndex", nextIndex, true). */
               /* setStatus := Set(rx, "lastIndex", nextIndex, true); */
               setJSProperty(rx, "lastIndex", newDataPropertyDescriptorFull(nextIndex, true, false, false))

               /* e. ReturnIfAbrupt(setStatus). */
               /* @ReturnIfAbrupt(setStatus) */
            } 
         }    
      }
   };
        
   /* 14. Let accumulatedResult be the empty String value. */
   accumulatedResult := "";

   /* 15. Let nextSourcePosition be 0. */
   nextSourcePosition := 0;

   /* 16. Repeat, for each result in results, */
   i := 0;
   len := l_len results;

   while (i < len){
      result := l_nth(results, i);

      /* a. Let nCaptures be ToLength(GetES6(result, "length")). */
      nCaptures := ToLength(GetNew(result, "length"));
        
      /* b. ReturnIfAbrupt(nCaptures). */
      @ReturnIfAbrupt(nCaptures);

      /* c. Let nCaptures be max(nCaptures − 1, 0). */
      nCaptures := int_of_float(max(nCaptures - 1., 0.));

      /* d. Let matched be ToString(GetES6(result, "0")). */
      matched := ToString(GetNew(result, "0"));

      /* e. ReturnIfAbrupt(matched). */
      @ReturnIfAbrupt(matched);

      /* f. Let matchLength be the number of code units in matched. */
      matchLength := s_len_u matched;

      /* g. Let position be ToInteger(GetES6(result, "index")). */
      position := ToInteger(GetNew(result, "index"));

      /* h. ReturnIfAbrupt(position). */
      @ReturnIfAbrupt(position);

      /* i. Let position be max(min(position, lengthS), 0). */
      position := int_of_float(max(min(position, int_to_float lengthS), 0.));

      /* j. Let n be 1. */
      n := 1;

      /* k. Let captures be an empty List. */
      captures := [];

      /* l. Repeat while n ≤ nCaptures */
      while (n <= nCaptures){
         /* i. Let capN be GetES6(result, ToString(n)). */
         capN := GetNew(result, ToString(int_to_float n));

         /* ii. ReturnIfAbrupt(capN). */
         @ReturnIfAbrupt(capN);

         /* iii. If capN is not undefined, then */
         if (!(capN = 'undefined)){
            /* 1. Let capN be ToString(capN). */
            capN := ToString(capN);

            /* 2. ReturnIfAbrupt(capN). */
            @ReturnIfAbrupt(capN)
         };
                
         /* iv. Append capN as the last element of captures. */
         captures := l_add(captures, capN);

         /* v. Let n be n+1 */
         n := n + 1
      };
            
      /* m. If functionalReplace is true, then */
      if (functionalReplace = true){
         /* i. Let replacerArgs be «matched». */
         replacerArgs := [matched];

         /* ii. Append in list order the elements of captures to the end of the List replacerArgs. */
         replacerArgs := l_concat(replacerArgs, captures);

         /* iii. Append position and S as the last two elements of replacerArgs. */
         replacerArgs := l_concat(replacerArgs, [position, S]);

         /* iv. Let replValue be Call(replaceValue, undefined, replacerArgs). */
         replValue := Call(null, null, replaceValue, 'undefined, replacerArgs);

         /* v. Let replacement be ToString(replValue). */
         replacement := ToString(replValue)
      }
      /* n. Else, */
      else{
         /* i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue). */
         replacement := GetSubstitution(matched, S, int_to_float position, captures, replaceValue, global, strict)
      };
          
      /* o. ReturnIfAbrupt(replacement). */
      @ReturnIfAbrupt(replacement);

      /* p. If position ≥ nextSourcePosition, then */
      if (position >= nextSourcePosition){
         /* i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving 
         RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. 
         In such cases, the corresponding substitution is ignored. */

         /* ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of 
         accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to 
         position (exclusive) and with the code units of replacement. */

         substring := StringPrototypesubstring(global, S, strict, [int_to_float nextSourcePosition, int_to_float position]);
         accumulatedResult := s_concat([accumulatedResult, substring]);
         accumulatedResult := s_concat([accumulatedResult, replacement]);

         /* iii. Let nextSourcePosition be position + matchLength. */
         nextSourcePosition := position + matchLength
      };  

      i := i + 1
   };
    
   /* 17. If nextSourcePosition ≥ lengthS, return accumulatedResult. */
   if (nextSourcePosition >= lengthS){
      return accumulatedResult
   };

   /* 18. Return the String formed by concatenating the code units of accumulatedResult with the substring of S 
   consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive). */
   substring := StringPrototypesubstring(global, S, strict, [int_to_float nextSourcePosition, 'undefined]);
   accumulatedResult := s_concat([accumulatedResult, substring]);

   return accumulatedResult
};

/* 21.2.5.9 RegExp.prototype [ @@search ] ( string ) */
/**
 * The value of the name property of this function is "[Symbol.search]".
 *
 * NOTE The lastIndex and global properties of this RegExp object are ignored when performing the search. 
 * The lastIndex property is left unchanged.
 */
function RegExpPrototypesearch(global, this, strict, args){
   string := l_nth(args, 0);

   /* 1. Let rx be the this value. */
   rx := this;

   /* 2. If Type(rx) is not Object, throw a TypeError exception. */
   if (!(Type(rx) = "Object")){
      throw TypeErrorConstructorInternal()
   };

   /* 3. Let S be ToString(string). */
   S := ToString(string);

   /* 4. ReturnIfAbrupt(S). */
   @ReturnIfAbrupt(S);

   /* 5. Let previousLastIndex be GetES6(rx, "lastIndex"). */
   previousLastIndex := GetNew(rx, "lastIndex");

   /* 6. ReturnIfAbrupt(previousLastIndex). */
   @ReturnIfAbrupt(previousLastIndex);

   /* 7. Let status be Set(rx, "lastIndex", 0, true). */
   /* status := Set(rx, "lastIndex", 0, true); */
   rx.lastIndex := 0;

   /* 8. ReturnIfAbrupt(status). */
   /* @ReturnIfAbrupt(status); */

   /* 9. Let result be RegExpExec(rx, S). */
   /* result := RegExpExec(rx, S); */
   result := RegExpPrototypeExec(global, rx, strict, [S]);

   /* 10. ReturnIfAbrupt(result). */
   @ReturnIfAbrupt(result);

   /* 11. Let status be Set(rx, "lastIndex", previousLastIndex, true). */
   /* status := Set(rx, "lastIndex", previousLastIndex, true); */
   rx.lastIndex := previousLastIndex;
    
   /* 12. ReturnIfAbrupt(status). */
   /* @ReturnIfAbrupt(status); */

   /* 13. If result is null, return –1. */
   if (result = 'null){
      return -(1.)
   };

   /* 14. Return Get(result, "index"). */
   return GetNew(result, "index")
};

/* 21.2.5.10 get RegExp.prototype.source */
/**
 * RegExp.prototype.source is an accessor property whose set accessor function is undefined. Its get accessor 
 * function performs the following steps:
 */

/* 21.2.5.11 RegExp.prototype [ @@split ] ( string, limit ) */
/**
 * NOTE 1 Returns an Array object into which substrings of the result of converting string to a String have been
 * stored. The substrings are determined by searching from left to right for matches of the this value regular 
 * expression; these occurrences are not part of any substring in the returned array, but serve to divide up the 
 * String value.
 * The this value may be an empty regular expression or a regular expression that can match an empty String. In
 * this case, regular expression does not match the empty substring at the beginning or end of the input String, 
 * nor does it match the empty substring at the end of the previous separator match. (For example, if the regular 
 * expression matches the empty String, the String is split up into individual code unit elements; the length of 
 * the result array equals the length of the String, and each substring contains one code unit.) Only the first 
 * match at a given index of the this String is considered, even if backtracking could yield a non-empty-substring
 * match at that index. (For example, /a*?/[Symbol.split]("ab") evaluates to the array ["a","b"], while 
 * /a*\/[Symbol.split]("ab") evaluates to the array["","b"].)
 * If the string is (or converts to) the empty String, the result depends on whether the regular expression can 
 * match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains 
 * one element, which is the empty String.
 * If the regular expression that contains capturing parentheses, then each time separator is matched the results
 * (including any undefined results) of the capturing parentheses are spliced into the output array. For example,
    /<(\/)?([^<>]+)>/[Symbol.split]("A<B>bold</B>and<CODE>coded</CODE>")
 * evaluates to the array
    ["A",undefined,"B","bold","/","B","and",undefined,"CODE","coded","/","CODE",""]
 * If limit is not undefined, then the output array is truncated so that it contains no more than limit elements.
 *
 * The length property of the @@split method is 2.
 * The value of the name property of this function is "[Symbol.split]".
 *
 * NOTE 2 The @@split method ignores the value of the global and sticky properties of this RegExp object.
 */
function RegExpPrototypesplit(global, this, strict, args){
   string := l_nth(args, 0);
   limit := l_nth(args, 1);

   /* 1. Let rx be the this value. */
   rx := this;

   /* 2. If Type(rx) is not Object, throw a TypeError exception. */
   if (!(Type(rx) = "Object")){
      throw TypeErrorConstructorInternal()
   };

   /* 3. Let S be ToString(string). */
   S := ToString(string);

   /* 4. ReturnIfAbrupt(S). */
   @ReturnIfAbrupt(S);

   /* 5. Let C be SpeciesConstructor(rx, %RegExp%). */
   /* C := SpeciesConstructor(rx, "RegExp"); */
   /* C := GetES6(rx, "constructor"); */

   /* 6. ReturnIfAbrupt(C). */
   /* @ReturnIfAbrupt(C); */

   /* 7. Let flags be ToString(GetES6(rx, "flags")). */
   flags := ToString(GetNew(rx, "flags"));

   /* 8. ReturnIfAbrupt(flags). */
   @ReturnIfAbrupt(flags);

   /* 9. If flags contains "u", let unicodeMatching be true. */
   contains := StringPrototypeincludes(global, flags, strict, ["u"]);

   if (contains = true){
      unicodeMatching := true
   }
   /* 10. Else, let unicodeMatching be false. */
   else{
      unicodeMatching := false
   };

   /* 11. If flags contains "y", let newFlags be flags. */
   contains := StringPrototypeincludes(global, flags, strict, ["y"]);
    
   if (contains = true){
      newFlags := flags
   }
   /* 12. Else, let newFlags be the string that is the concatenation of flags and "y". */
   else{
      newFlags := s_concat([flags, "y"])
   };

   /* 13. Let splitter be Construct(C, «rx, newFlags»). */
   /* splitter := Construct(C, [rx, newFlags]); */
   /* splitter := RegExpConstructor(global, this, strict, [rx, newFlags]); */
   splitter := newRegExp(strict, rx, newFlags);

   /* 14. ReturnIfAbrupt(splitter). */
   @ReturnIfAbrupt(splitter);

   /* 15. Let A be ArrayCreate(0). */
   /* A := ArrayCreate(0); */
   A := ArrayConstructor(global, null, strict, []);

   /* 16. Let lengthA be 0. */
   lengthA := 0.;

   /* 17. If limit is undefined, let lim be 253–1; else let lim be ToLength(limit). */
   if (limit = 'undefined){
      lim := (2. ** 53.) - 1.
   } else{
      lim := ToLength(limit)
   };

   /* 18. ReturnIfAbrupt(lim). */
   @ReturnIfAbrupt(lim);

   /* 19. Let size be the number of elements in S. */
   size := int_to_float (s_len_u S);

   /* 20. Let p be 0. */
   p := 0.;

   /* 21. If lim = 0, return A. */
   if (lim = 0.){
      return A
   };

   /* 22. If size = 0, then */
   if (size = 0.){
      /* a. Let z be RegExpExec(splitter, S). */
      /* z := RegExpExec(splitter, S); */
      z := RegExpPrototypeExec(global, splitter, strict, [S]);
        
      /* b. ReturnIfAbrupt(z). */
      @ReturnIfAbrupt(z);

      /* c. If z is not null, return A. */
      if (!(z = 'null) &&& !(z = null)){
         return A
      };

      /* d. Assert: The following call will never result in an abrupt completion. */
      /* ???? */

      /* e. Perform CreateDataProperty(A, "0", S). */
      CreateDataPropertyNew(A, "0", S);

      /* f. Return A. */
      return A
   };

   /* 23. Let q be p. */
   q := p;

   /* 24. Repeat, while q < size */
   while (q < size){
      /* a. Let setStatus be Set(splitter, "lastIndex", q, true). */
      /* setStatus := Set(splitter, "lastIndex", q, true); */
      setJSProperty(splitter, "lastIndex", newDataPropertyDescriptorFull(q, true, false, false));
       
      /* b. ReturnIfAbrupt(setStatus). */
      /* @ReturnIfAbrupt(setStatus); */

      /* c. Let z be RegExpExec(splitter, S). */
      /* z := RegExpExec(splitter, S); */
      z := RegExpPrototypeExec(global, splitter, strict, [S]);

      /* d. ReturnIfAbrupt(z). */
      @ReturnIfAbrupt(z);

      /* e. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching). */
      if ((z = 'null) || (z = null)){
         q := AdvanceStringIndex(S, q, unicodeMatching)
      }
      /* f. Else z is not null, */
      else{
         /* i. Let e be ToLength(Get(splitter, "lastIndex")). */
         e := ToLength(GetNew(splitter, "lastIndex"));

         /* ii. ReturnIfAbrupt(e). */
         @ReturnIfAbrupt(e);

         /* iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching). */ 
         if (e = p){
            q := AdvanceStringIndex(S, q, unicodeMatching)
         }
         /* iv. Else e  p, */
         else{
            /* 1. Let T be a String value equal to the substring of S consisting of the elements at indices p 
            (inclusive) through q (exclusive). */
            T := StringPrototypesubstring(global, S, strict, [p, q]);

            /* 2. Assert: The following call will never result in an abrupt completion. */
            /* ???? */

            /* 3. Perform CreateDataProperty(A, ToString(lengthA), T). */
            CreateDataPropertyNew(A, ToString(lengthA), T);

            /* 4. Let lengthA be lengthA +1. */
            lengthA := lengthA + 1.;

            /* 5. If lengthA = lim, return A. */
            if (lengthA = lim){
               return A
            };

            /* 6. Let p be e. */
            p := e;

            /* 7. Let numberOfCaptures be ToLength(GetES6(z, "length")). */ 
            numberOfCaptures := ToLength(GetNew(z, "length"));

            /* 8. ReturnIfAbrupt(numberOfCaptures). */
            @ReturnIfAbrupt(numberOfCaptures);

            /* 9. Let numberOfCaptures be max(numberOfCaptures-1, 0). */ 
            numberOfCaptures := max(numberOfCaptures - 1., 0.);

            /* 10. Let i be 1. */
            i := 1.;

            /* 11. Repeat, while i ≤ numberOfCaptures. */
            while (i <= numberOfCaptures) {
               /* a. Let nextCapture be GetES6(z, ToString(i)). */
               nextCapture := GetNew(z, ToString(i));

               /* b. ReturnIfAbrupt(nextCapture). */
               @ReturnIfAbrupt(nextCapture);

               /* c. Perform CreateDataProperty(A, ToString(lengthA), nextCapture). */ 
               CreateDataPropertyNew(A, ToString(lengthA), nextCapture);

               /* d. Let i be i+1. */
               i := i + 1.;

               /* e. Let lengthA be lengthA +1. */
               lengthA := lengthA + 1.;

               /* f. If lengthA = lim, return A. */
               if (lengthA = lim){
                  return A
               }
            };
                    
            /* 12. Let q be p. */
            q := p
         }
      }
   };
        
   /* 25. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive). */
   T := StringPrototypesubstring(global, S, strict, [p, size]);

   /* 26. Assert: The following call will never result in an abrupt completion. */
   /* ???? */

   /* 27. Perform CreateDataProperty(A, ToString(lengthA), T ). */
   CreateDataPropertyNew(A, ToString(lengthA), T);
   /* setJSProperty(A, "length", newDataPropertyDescriptorFull(lengthA + 1., true, false, false)); */

   /* 28. Return A. */
   return A
}

/* 21.2.5.12 get RegExp.prototype.sticky */
/**
 * RegExp.prototype.sticky is an accessor property whose set accessor function is undefined. Its get accessor 
 * function performs the following steps:
 */

/* 21.2.5.13 RegExp.prototype.test( S ) */

/* 21.2.5.14 RegExp.prototype.toString ( ) */
/**
 * NOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object 
 * with the same behaviour as this object.
 */

/* 21.2.5.15 get RegExp.prototype.unicode */
/**
 * RegExp.prototype.unicode is an accessor property whose set accessor function is undefined. Its get accessor
 * function performs the following steps:
 */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* 21.2.6 Properties of RegExp Instances */

/**
 * RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp 
 * instances have internal slots [[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value of the 
 * [[RegExpMatcher]] internal slot is an implementation dependent representation of the Pattern of the RegExp object.
 *
 * NOTE Prior to ECMAScript 2015, RegExp instances were specified as having the own data properties source, global, 
 * ignoreCase, and multiline. Those properties are now specified as accessor properties of RegExp.prototype.
 *
 * RegExp instances also have the following property:
*/

/* 21.2.6.1 lastIndex */
/**
 * The value of the lastIndex property specifies the String index at which to start the next match. It is coerced
 * to an integer when used (see 21.2.5.2.2). This property shall have the attributes { [[Writable]]: true, [[Enumerable]]:
 * false, [[Configurable]]: false }.
 */

