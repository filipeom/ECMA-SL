/******************************
 *                            *
 *   %TypedArray%.prototype   *
 *                            *
 ******************************/
function initTypedArrayMainPrototype(global, objectPrototype, strict) {
  prototype := NewECMAScriptObjectFull(objectPrototype, "TypedArrayPrototype", true);

  /* 22.2.3 Properties of the %TypedArrayPrototype% Object */
  /* 22.2.3.1 get %TypedArray%.prototype.buffer */
  bufferFunc := CreateBuiltInFunctionObject([], "getTypedArrayBuffer", global, strict, null);
  descBuffer := newGetAccessorPropertyDescriptor(bufferFunc);
  setJSProperty(prototype, "buffer", descBuffer);
  /* 22.2.3.2 get %TypedArray%.prototype.byteLength */
  byteLengthFunc := CreateBuiltInFunctionObject([], "getTypedArrayByteLength", global, strict, null);
  descByteLength := newGetAccessorPropertyDescriptor(byteLengthFunc);
  setJSProperty(prototype, "byteLength", descByteLength);
  /* 22.2.3.3 get %TypedArray%.prototype.byteOffset */
  byteOffsetFunc := CreateBuiltInFunctionObject([], "getTypedArrayByteOffset", global, strict, null);
  descByteOffset := newGetAccessorPropertyDescriptor(byteOffsetFunc);
  setJSProperty(prototype, "byteOffset", descByteOffset);

  /*
    Falta definir os metodos
  */

  |ElementTable| := {
    Int8Array: {
      type: "Int8",
      size: 1
    },
    Uint8Array: {
      type: "Uint8",
      size: 1
    },
    Uint8ClampedArray: {
      type: "Uint8C",
      size: 1
    },
    Int16Array: {
      type: "Int16",
      size: 2
    },
    Uint16Array: {
      type: "Uint16",
      size: 2
    },
    Int32Array: {
      type: "Int32",
      size: 4
    },
    Uint32Array: {
      type: "Uint32",
      size: 4
    },
    Float32Array: {
      type: "Float32",
      size: 4
    },
    Float64Array: {
      type: "Float64",
      size: 8
    }
  };

  return prototype
};

/********************
 *                  *
 *   %TypedArray%   *
 *                  *
 ********************/
function initTypedArrayMainConstructor(global, objectPrototype, strict) {
  prototype := initTypedArrayMainPrototype(global, objectPrototype, strict);
  functionPrototype := getFunctionPrototype(strict);

  typedArrayConstructor := CreateBuiltInConstructorObject(functionPrototype, ["argumentList"], "TypedArrayConstructor", global, strict, 3, "TypedArray");

  descriptor := newDataPropertyDescriptorFull(typedArrayConstructor, true, false, true);
  setJSProperty(prototype, "constructor", descriptor);

  /* Length */
  descLen := newDataPropertyDescriptorFull(3., false, false, true);
  setJSProperty(typedArrayConstructor, "length", descLen);

  /* 22.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] ) */
  fromObject := CreateBuiltInFunctionObject(["source", "mapfn", "thisArg"], "TypedArrayFrom", global, strict, null);
  fromDesc := newDataPropertyDescriptorFull(fromObject, true, false, true);
  setJSProperty(typedArrayConstructor, "from", fromDesc);

  /* 22.2.2.2 %TypedArray%.of ( ...items ) */
  ofObject := CreateBuiltInFunctionObject(["items"], "TypedArrayOf", global, strict, null);
  ofDesc := newDataPropertyDescriptorFull(ofObject, true, false, true);
  setJSProperty(typedArrayConstructor, "of", ofDesc);

  /* 22.2.2.3 %TypedArray%.prototype */
  prototypeDesc := newDataPropertyDescriptorFull(prototype, false, false, false);
  setJSProperty(typedArrayConstructor, "prototype", prototypeDesc);

  /* 22.2.2.4 get %TypedArray% [ @@species ] */
  symbolSpeciesObject := CreateBuiltInFunctionObject([], "typedArraySpeciesGetter", global, strict, null);
  descriptor := newGetAccessorPropertyDescriptorFull(symbolSpeciesObject, false, true);
  setJSProperty(typedArrayConstructor, getSpeciesPropertyName(), descriptor);
  setJSProperty(symbolSpeciesObject, "name", newDataPropertyDescriptorFull("get [Symbol.species]", false, false, true));

  return typedArrayConstructor
};

/********************************************************
 *                                                      *
 *   TypedArray.prototype: - Int8Array.prototype, etc.  *
 *                                                      *
 ********************************************************/
function initTypedArrayPrototype(global, objectPrototype, strict, typeOfArray) {
  prototypeName := s_concat([typeOfArray, "Prototype"]);
  typedArrayPrototype := |Intrinsics|.TypedArrayPrototype;
  prototype := NewECMAScriptObjectFull(typedArrayPrototype, prototypeName, true);
    
  /* 22.2.6.1 TypedArray.prototype.BYTES_PER_ELEMENT */
  descBytes := newDataPropertyDescriptorFull(|ElementTable|[s_concat([typeOfArray, "Array"])].size, false, false, false);
  setJSProperty(prototype, "BYTES_PER_ELEMENT", descBytes);

  return prototype
};

/************************************
 *                                  *
 *   TypedArray: - Int8Array, etc.  *
 *                                  *
 ************************************/
function initTypedArrayObject(global, objectPrototype, strict, typeOfArray) {
  objTypedArrayPrototype := initTypedArrayPrototype(global, objectPrototype, strict, typeOfArray);
  
  /* 22.2.4 TypedArray constructors
    Int32TypedArrayConstructor
  */
  name := s_concat([typeOfArray, "Array"]);
  objTypedArrayConstructor := CreateBuiltInConstructorObject(|Intrinsics|.TypedArray, ["argumentList"], s_concat([typeOfArray, "TypedArrayConstructor"]), global, strict, 0., name);
  /* 22.2.5 */
  /* Length */
  descLen := newDataPropertyDescriptorFull(3., false, false, true);
  setJSProperty(objTypedArrayConstructor, "length", descLen);
  /* TypedArrayConstructorName */
  setInternalProperty(objTypedArrayConstructor, "TypedArrayConstructorName", name);
  /* 22.2.5.1 BYTES_PER_ELEMENT */
  descBytes := newDataPropertyDescriptorFull(|ElementTable|[name].size, false, false, false);
  setJSProperty(objTypedArrayConstructor, "BYTES_PER_ELEMENT", descBytes);
  /* 22.2.6.2 TypedArray.prototype.constructor */
  descriptor := newDataPropertyDescriptorFull(objTypedArrayConstructor, true, false, true);
  setJSProperty(objTypedArrayPrototype, "constructor", descriptor);

  descProto := newDataPropertyDescriptorFull(objTypedArrayPrototype, false, false, false);
  setJSProperty(objTypedArrayConstructor, "prototype", descProto);
  
  return objTypedArrayConstructor
};



function Int8TypedArrayConstructor(global, this, strict, items) {
  /* super call */
  return TypedArrayConstructor("Int8", global, this, strict, items)
};
function Uint8TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Uint8", global, this, strict, items)
};
function Uint8ClampedTypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Uint8Clamped", global, this, strict, items)
};
function Int16TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Int16", global, this, strict, items)
};
function Uint16TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Uint16", global, this, strict, items)
};
function Int32TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Int32", global, this, strict, items)
};
function Uint32TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Uint32", global, this, strict, items)
};
function Float32TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Float32", global, this, strict, items)
};
function Float64TypedArrayConstructor(global, this, strict, items) {
  return TypedArrayConstructor("Float64", global, this, strict, items)
};

/* %TypedArray% Overloads */
function TypedArrayConstructor(typeOfArray, global, this, strict, items) {
  refObj := newPropertyReference(|global|, s_concat([typeOfArray, "Array"]), strict);
  FunctionObject := GetValue(refObj);

  len := l_len items; 
  if (len = 0) {
    /* 22.2.1.1 */
    return TypedArrayConstructorEmpty(typeOfArray, global, FunctionObject, strict, items)
  } else {
    if (len > 0) {
      obj := l_nth(items, 0);
      /* 22.2.1.2 */
      if (!(Type(obj) = "Object")) {
        return TypedArrayConstructorLength(typeOfArray, global, FunctionObject, strict, obj)
      } else {
        /* 22.2.1.3 */
        if ("TypedArrayName" in_obj obj) {
          return TypedArrayConstructorTypedArray(typeOfArray, global, FunctionObject, strict, obj)
        } else {
          /* 22.2.1.4 */
          if (!("ArrayBufferData" in_obj obj)) {
            return TypedArrayConstructorObject(typeOfArray, global, FunctionObject, strict, obj)
          /* 22.2.1.5 */
          } else {
            /* optional parameters default values. */
            byteOffset := 0;
            length := 'undefined;

            if (len > 1) {
              byteOffset := l_nth(items, 1)
            };
            if (len > 2) {
              length := l_nth(items, 2)
            };

            return TypedArrayConstructorBuffer(typeOfArray, global, FunctionObject, strict, obj, byteOffset, length)
          }
        }
      }
    }
  }
};

/**
 * 22.2.1.1 %TypedArray%
 *
 * This description applies only if the %TypedArray% function is called with no
 * arguments.
 */
function TypedArrayConstructorEmpty(typeOfArray, global, this, strict, items) {
  NewTarget := this;
  /* 1. If NewTarget is undefined, */
  if (NewTarget = 'undefined) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 2. Return AllocateTypedArray(NewTarget, 0). */
  return AllocateTypedArray(NewTarget, 0, strict)
};

/**
 * 22.2.1.2 %TypedArray% (length)
 *
 * This description applies only if the %TypedArray% function is called with at
 * least one argument and the Type of the first argument is not Object.
 *
 * %TypedArray% called with argument length performs the following steps:
 */
function TypedArrayConstructorLength(typeOfArray, global, this, strict, length) {
  /* 1. Assert: Type(length) is not Object. */
  assert(!(Type(length) = "Object"));
  /* 2. If NewTarget is undefined, */
  if (NewTarget = 'undefined) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 3. If length is undefined, */
  if (length = 'undefined) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 4. Let numberLength be ToNumber(length). */
  numberLength := ToNumber(length);
  /* 5. Let elementLength be ToLength(numberLength). */
  elementLength := ToLength(numberLength);
  /* 6. ReturnIfAbrupt(elementLength). */
  @ReturnIfAbrupt(elementLength);
  /* 7. If SameValueZero(numberLength, elementLength) is false, */
  if (SameValueZero(numberLength, elementLength) = false) {
    /* throw a RangeError exception */
    throw RangeErrorConstructorInternal()
  };
  /* 8. Return AllocateTypedArray(NewTarget, elementLength). */
  return AllocateTypedArray(NewTarget, elementLength, strict)
};


/**
 * 22.2.1.2.1 Runtime Semantics: AllocateTypedArray (newTarget, length)
 *
 * The abstract operation AllocateTypedArray with argument newTarget and
 * optional argument length is used to validate and create an instance of a
 * TypedArray constructor. If the length argument is passed an ArrayBuffer of
 * that length is also allocated and associated with the new TypedArray
 * instance. AllocateTypedArray provides common semantics that is used by all of
 * the %TypeArray% overloads and other methods. AllocateTypedArray performs the
 * following steps:
 */
function AllocateTypedArray(newTarget, length, strict) {
  /* 1. Assert: IsConstructor(newTarget) is true. */
  assert(IsConstructor(newTarget) = true);
  
  /* 2. If SameValue(%TypedArray%, newTarget) is true, throw a TypeError exception */
  if (SameValue(|Intrinsics|.TypedArray, newTarget) = true) {
    throw TypeErrorConstructorInternal()
  };
  
  /* 3. NOTE %TypedArray% throws an exception when invoked via either a
     function call or the new operator. It can only be successfully invoked
     by a SuperCall. */
  
  /* 4. Let constructorName be undefined. */
  constructorName := 'undefined;
  /* 5. Let subclass be newTarget. */
  subclass := newTarget;
  /* 6. Repeat while constructorName is undefined */
  while (constructorName = 'undefined) {
    /* a. If subclass is null, throw a TypeError exception. */
    if (subclass = 'null) {
      throw TypeErrorConstructorInternal()
    };
    /* b. If SameValue(%TypedArray%, subclass) is true, throw a TypeError exception. */
    if (SameValue(|Intrinsics|.TypedArray, subclass) = true) {
      throw TypeErrorConstructorInternal()
    };
    /* c. If subclass has a [[TypedArrayConstructorName]] internal slot, let constructorName be the value of subclass’s [[TypedArrayConstructorName]] internal slot. */
    if ("TypedArrayConstructorName" in_obj subclass) {
      constructorName := subclass.TypedArrayConstructorName
    };
    /* d. Let subclass be subclass.[[GetPrototypeOf]](). */
    subclass := GetPrototypeOf(subclass);
    /* subclass := {subclass.GetPrototypeOf}(); */
    /* e. ReturnIfAbrupt(subclass). */
    @ReturnIfAbrupt(subclass)
  };
  /* 7. Let proto be GetPrototypeFromConstructor(newTarget, "%TypedArrayPrototype%"). */    
  proto := GetPrototypeFromConstructor(newTarget, "TypedArrayPrototype");
  /* 8. ReturnIfAbrupt(proto). */ 
  @ReturnIfAbrupt(proto);        
  /* 9. Let obj be IntegerIndexedObjectCreate (proto, «‍[[ViewedArrayBuffer]],
     [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]]»
     ). */                           
  obj := IntegerIndexedObjectCreate(proto, ["ViewedArrayBuffer", "TypedArrayName", "ByteLength", "ByteOffset", "ArrayLength"]);
  /* 10. Assert: The [[ViewedArrayBuffer]] internal slot of obj is undefined. */
  assert(getInternalProperty(obj, "ViewedArrayBuffer") = 'undefined);
  /* 11. Set obj's [[TypedArrayName]] internal slot to constructorName. */
  obj.TypedArrayName := constructorName;        
  /* 12. If length was not passed, then */
  if (length = 'undefined) {
    /* a. Set obj's [[ByteLength]] internal slot to 0. */
    obj.ByteLength := 0.;
    /* b. Set obj's [[ByteOffset]] internal slot to 0. */
    obj.ByteOffset := 0.;          
    /* c. Set obj's [[ArrayLength]] internal slot to 0. */
    obj.ArrayLength := 0.
  } /* 13. Else, */ else {
    /* Let elementSize be the Element Size value in Table 49 for constructorName. */
    elementSize := |ElementTable|[constructorName].size;
    /* Let byteLength be elementSize × length. */
    byteLength := elementSize * length;
    /* Let data be AllocateArrayBuffer(%ArrayBuffer%, byteLength). */
    data := AllocateArrayBuffer(|Intrinsics|.ArrayBuffer, byteLength, strict);
    /* ReturnIfAbrupt(data). */
    @ReturnIfAbrupt(data);
    /* Set obj’s [[ViewedArrayBuffer]] internal slot to data. */
    obj.ViewedArrayBuffer := data;
    /* Set obj’s [[ByteLength]] internal slot to byteLength. */
    obj.ByteLength := byteLength;
    /* Set obj’s [[ByteOffset]] internal slot to 0. */
    obj.ByteOffset := 0;
    /* Set obj’s [[ArrayLength]] internal slot to length. */
    obj.ArrayLength := length
  };
  /* 14. Return obj. */         
  return obj
};

/**
 * 22.2.1.3 %TypedArray% (typedArray)
 *
 * This description applies only if the %TypedArray% function is called with at
 * least one argument and the Type of the first argument is Object and that
 * object has a [[TypedArrayName]] internal slot.
 *
 * %TypedArray% called with argument typedArray performs the following steps:
 */
function TypedArrayConstructorTypedArray(typeOfArray, global, this, strict, typedArray) {
  /* 1. Assert: Type(typedArray) is Object and typedArray has a
     [[TypedArrayName]] internal slot. */
  assert((Type(typedArray) = "Object") &&& ("TypedArrayName" in_obj typedArray));
  /* 2. If NewTarget is undefined, */
  if (NewTarget = 'undefined) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 3. Let O be AllocateTypedArray(NewTarget). */
  O := AllocateTypedArray(NewTarget);
  /* 4. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 5. Let srcArray be typedArray. */
  srcArray := typedArray;
  /* 6. Let srcData be the value of srcArray's [[ViewedArrayBuffer]] internal
     slot. */
  srcData := srcArray.ViewedArrayBuffer;
  /* 7. If IsDetachedBuffer(srcData) is true, */
  if (IsDetachedBuffer(srcData) = true) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 8. Let constructorName be the String value of O's [[TypedArrayName]]
     internal slot. */
  constructorName := O.TypedArrayName;
  /* 9. Let elementType be the String value of the Element Type value in Table
     49 for constructorName. */
  elementType := |ElementTable|[constructorName].type;
  /* 10. Let elementLength be the value of srcArray's [[ArrayLength]] internal
     slot. */
  elementLength := srcArray.ArrayLength;
  /* 11. Let srcName be the String value of srcArray's [[TypedArrayName]]
     internal slot. */
  srcName := srcArray.TypedArrayName;
  /* 12. Let srcType be the String value of the Element Type value in Table 49
     for srcName. */
  srcType := |ElementTable|[srcName].type;
  /* 13. Let srcElementSize be the Element Size value in Table 49 for srcName. */
  srcElementSize := |ElementTable|[srcName].size;
  /* 14. Let srcByteOffset be the value of srcArray's [[ByteOffset]] internal
     slot. */
  srcByteOffset := srcArray.ByteOffset;
  /* 15. Let elementSize be the Element Size value in Table 49 for
     constructorName. */
  elementSize := |ElementTable|[constructorName].size;
  /* 16. Let byteLength be elementSize × elementLength. */
  byteLength := elementSize * elementLength;
  /* 17. If SameValue(elementType,srcType) is true, then */
  if (SameValue(elementType, srcType) = true) {
    /* a. Let data be CloneArrayBuffer(srcData, srcByteOffset). */
    data := CloneArrayBuffer(srcData, srcByteOffset);
    /* b. ReturnIfAbrupt(data). */
    @ReturnIfAbrupt(data)
  }
  /* 18. Else, */
  else {
    /* a. Let bufferConstructor be SpeciesConstructor(srcData, %ArrayBuffer%). */
    bufferConstructor := SpeciesConstructor(srcData, |ArrayBuffer|);
    /* b. ReturnIfAbrupt(bufferConstructor). */
    @ReturnIfAbrupt(bufferConstructor);
    /* c. Let data be AllocateArrayBuffer(bufferConstructor, byteLength). */
    data := AllocateArrayBuffer(bufferConstructor, byteLength);
    /* d. ReturnIfAbrupt(data). */
    @ReturnIfAbrupt(data);
    /* e. If IsDetachedBuffer(srcData) is true, throw a TypeError exception. */
    if (IsDetachedBuffer(srcData)) {
      throw TypeErrorConstructorInternal()
    };
    /* f. Let srcByteIndex be srcByteOffset. */
    srcByteIndex := srcByteOffset;
    /* g. Let targetByteIndex be 0. */
    targetByteIndex := 0;
    /* h. Let count be elementLength. */
    count := elementLength;
    /* i. Repeat, while count >0 */
    while (count > 0) {
      /* i. Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType). */
      value := GetValueFromBuffer(srcData, srcByteIndex, srcType);
      /* ii. Perform SetValueInBuffer(data, targetByteIndex, elementType, value). */
      SetValueInBuffer(data, targetByteIndex, elementType, value);
      /* iii. Set srcByteIndex to srcByteIndex + srcElementSize. */
      srcByteIndex := srcByteIndex + srcElementSize;
      /* iv. Set targetByteIndex to targetByteIndex + elementSize. */
      targetByteIndex := targetByteIndex + elementSize;
      /* v. Decrement count by 1. */
      count := count - 1
    }
  };
  /* 19. Set O's [[ViewedArrayBuffer]] internal slot to data. */
  O.ViewedArrayBuffer := data;
  /* 20. Set O's [[ByteLength]] internal slot to byteLength. */
  O.ByteLength := byteLength;
  /* 21. Set O's [[ByteOffset]] internal slot to 0. */
  O.ByteOffset := 0;
  /* 22. Set O's [[ArrayLength]] internal slot to elementLength. */
  O.ArrayLength := elementLength;
  /* 23. Return O. */
  return O
};

/**
 * 22.2.1.4 %TypedArray% (object)
 *
 * This description applies only if the %TypedArray% function is called with at
 * least one argument and the Type of the first argument is Object and that
 * object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]]
 * internal slot.
 *
 * %TypedArray% called with argument object performs the following steps:
 */
function TypedArrayConstructorObject(typeOfArray, global, this, strict, object) {
  /* 1. Assert: Type(object) is Object and object does not have either a
     [[TypedArrayName]] or an [[ArrayBufferData]] internal slot. */
  assert((Type(object) = "Object") &&& !(("TypedArrayName" in_obj object) || ("ArrayBufferData" in_obj object)));
  /* 2. If NewTarget is undefined, */
  if (NewTarget = 'undefined) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 3. Return TypedArrayFrom(NewTarget, object, undefined, undefined). */
  return TypedArrayFrom(NewTarget, object, 'undefined, 'undefined)
};

/**
 * 22.2.1.5 %TypedArray% (buffer [ , byteOffset [ , length ] ] )
 *
 * This description applies only if the %TypedArray% function is called with at
 * least one argument and the Type of the first argument is Object and that
 * object has an [[ArrayBufferData]] internal slot.
 *
 * %TypedArray% called with arguments buffer, byteOffset, and length performs
 * the following steps:
 */
function TypedArrayConstructorBuffer(typeOfArray, global, this, strict, buffer, byteOffset, length) {
  /* 1. Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]]
     internal slot. */
  assert((Type(buffer) = "Object") &&& ("ArrayBufferData" in_obj buffer));
  /* 2. If NewTarget is undefined, */
  if (NewTarget = 'undefined) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 3. Let O be AllocateTypedArray(NewTarget). */
  O := AllocateTypedArray(NewTarget);
  /* 4. ReturnIfAbrupt(O). */
  @ReturnIfAbrupt(O);
  /* 5. Let constructorName be the String value of O's [[TypedArrayName]]
     internal slot. */
  constructorName := O.TypedArrayName;
  /* 6. Let elementSize be the Number value of the Element Size value in Table
     49 for constructorName. */
  elementSize := |ElementTable|[constructorName].size;
  /* 7. Let offset be ToInteger(byteOffset). */
  offset := ToInteger(byteOffset);
  /* 8. ReturnIfAbrupt(offset). */
  @ReturnIfAbrupt(offset);
  /* 9. If offset < 0, */
  if (offset < 0) {
    /* throw a RangeError exception */
    throw RangeErrorConstructorInternal()
  };
  /* 10. If offset modulo elementSize ≠ 0, */
  if (!((offset % elementSize) = 0)) {
    /* throw a RangeError exception */
    throw RangeErrorConstructorInternal()
  };
  /* 11. If IsDetachedBuffer(buffer) is true, */
  if (IsDetachedBuffer(buffer) = true) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 12. Let bufferByteLength be the value of buffer's
     [[ArrayBufferByteLength]] internal slot. */
  bufferByteLength := buffer.ArrayBufferByteLength;
  /* 13. If length is undefined, then */
  if (length = 'undefined) {
    /* a. If bufferByteLength modulo elementSize ≠ 0, */
    if (!((bufferByteLength % elementSize) = 0)) {
      /* throw a RangeError exception */
      throw RangeErrorConstructorInternal()
    };
    /* b. Let newByteLength be bufferByteLength – offset. */
    newByteLength := bufferByteLength - offset;
    /* c. If newByteLength < 0, */
    if (newByteLength < 0) {
      /* throw a RangeError exception */
      throw RangeErrorConstructorInternal()
    }
  }
  /* 14. Else, */
  else {
    /* a. Let newLength be ToLength(length). */
    newLength := ToLength(length);
    /* b. ReturnIfAbrupt(newLength). */
    @ReturnIfAbrupt(newLength);
    /* c. Let newByteLength be newLength × elementSize. */
    newByteLength := newLength * elementSize;
    /* d. If offset+newByteLength > bufferByteLength, throw a RangeError exception. */
    if ((offset + newByteLength) > bufferByteLength) {
      throw RangeErrorConstructorInternal()
    }
  };
  /* 15. Set O's [[ViewedArrayBuffer]] internal slot to buffer. */
  O.ViewedArrayBuffer := buffer;
  /* 16. Set O's [[ByteLength]] internal slot to newByteLength. */
  O.ByteLength := newByteLength;
  /* 17. Set O's [[ByteOffset]] internal slot to offset. */
  O.ByteOffset := offset;
  /* 18. Set O's [[ArrayLength]] internal slot to newByteLength / elementSize . */
  O.ArrayLength := newByteLength / elementSize;
  /* 19. Return O. */
  return O
};

/**
 * 22.2.2.1 %TypedArray%.from (source [ , mapfn [ , thisArg ] ] )
 *
 * When the from method is called with argument source, and optional arguments
 * mapfn and thisArg, the following steps are taken:
 */
function TypedArrayFromMethod(global, this, strict, args) {
  source := l_nth(args, 0);
  mapfn := getOptionalParam(args, 1);
  thisArg := getOptionalParam(args, 2);
  /* 1. Let C be the this value. */
  C := this;
  /* 2. If IsConstructor(C) is false, */
  if (IsConstructor(C) = false) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 3. If mapfn was supplied, let f be mapfn; otherwise let f be undefined. */
  if (!(mapfn = 'undefined)) {
    f := mapfn
  } else {
    f := 'undefined
  };
  /* 4. If f is not undefined, then */
  if (!(f = 'undefined)) {
    /* a. If IsCallable(f) is false, */
    if (IsCallable(f) = false) {
      /* throw a TypeError exception */
      throw TypeErrorConstructorInternal()
    }
  };
  /* 5. If thisArg was supplied, let t be thisArg; else let t be undefined. */
  if (!(thisArg = 'undefined)) {
    t := thisArg
  } else {
    t := 'undefined
  };
  /* 6. Return TypedArrayFrom(C, source, f, t). */
  return TypedArrayFrom(C, source, f, t)
};

/**
 * 22.2.2.1.1 Runtime Semantics: TypedArrayFrom (constructor, items, mapfn, thisArg)
 *
 * When the TypedArrayFrom abstract operation is called with arguments
 * constructor, items, mapfn, and thisArg, the following steps are taken:
 */
function TypedArrayFrom(constructor, items, mapfn, thisArg) {
  /* 1. Let C be constructor. */
  C := constructor;
  /* 2. Assert: IsConstructor(C) is true. */
  assert(IsConstructor(C) = true);
  /* 3. Assert: mapfn is either a callable Object or undefined. */
  assert((mapfn = 'undefined) || (IsCallable(mapfn)));
  /* 4. If mapfn is undefined, let mapping be false. */
  if (mapfn = 'undefined) {
    mapping := false
  }
  /* 5. Else */
  else {
    /* a. Let T be thisArg. */
    T := thisArg;
    /* b. Let mapping be true */
    mapping := true
  };
  /* 6. Let usingIterator be GetMethod(items, @@iterator). */
  usingIterator := GetMethod(items, Symbol.iterator);
  /* 7. ReturnIfAbrupt(usingIterator). */
  @ReturnIfAbrupt(usingIterator);
  /* 8. If usingIterator is not undefined, then */
  if (!(usingIterator = 'undefined)) {
    /* a. Let iterator be GetIterator(items, usingIterator). */
    iterator := GetIterator(items, usingIterator, null);
    /* b. ReturnIfAbrupt(iterator). */
    @ReturnIfAbrupt(iterator);
    /* c. Let values be a new empty List. */
    values := [];
    /* d. Let next be true. */
    next := true;
    /* e. Repeat, while next is not false */
    while(next) {
      /* i. Let next be IteratorStep(iterator). */
      next := IteratorStep(iterator);
      /* ii. ReturnIfAbrupt(next). */
      @ReturnIfAbrupt(next);
      /* iii. If next is not false, then */
      if (next) {
        /* 1. Let nextValue be IteratorValue(next). */
        nextValue := IteratorValue(next);
        /* 2. ReturnIfAbrupt(nextValue). */
        @ReturnIfAbrupt(nextValue);
        /* 3. Append nextValue to the end of the List values. */
        values := l_concat(values, [nextValue])
      }
    };
    /* f. Let len be the number of elements in values. */
    len := l_len values;
    /* g. Let targetObj be AllocateTypedArray(C, len). */
    targetObj := AllocateTypedArray(C, len);
    /* h. ReturnIfAbrupt(targetObj). */
    @ReturnIfAbrupt(targetObj);
    /* i. Let k be 0. */
    k := 0.;
    /* j. Repeat, while k < len */
    while (k < len) {
      /* i. Let Pk be ToString(k). */
      Pk := ToString(k);
      /* ii. Let kValue be the first element of values and remove that element from values. */
      kValue := l_nth(values, 0);
      values := l_remove_nth(values, 0); /* TODO: there is no operation to remove the first element of a list or a specific one to my knowledge. The only existent operation is l_remove_last */
      /* iii. If mapping is true, then */
      if (mapping) {
        /* 1. Let mappedValue be Call(mapfn, T, «kValue, k»). */
        mappedValue := Call(mapfn, T, [kValue, k]);
        /* 2. ReturnIfAbrupt(mappedValue). */
        @ReturnIfAbrupt(mappedValue)
      }
      /* iv. Else, let mappedValue be kValue. */
      else {
        mappedValue := kValue
      };
      /* v. Let setStatus be Set(targetObj, Pk, mappedValue, true). */
      setStatus := Set(targetObj, Pk, mappedValue, true);
      /* vi. ReturnIfAbrupt(setStatus). */
      @ReturnIfAbrupt(setStatus);
      /* vii. Increase k by 1. */
      k := k + 1
    };
    /* k. Assert: values is now an empty List. */
    assert((l_len values) = 0);
    /* l. Return targetObj. */
    return targetObj
  };
  /* 9. Assert: items is not an Iterable so assume it is an array-like object. */
  assert(!(IsIterable(items)));
  /* 10. Let arrayLike be ToObject(items). */
  arrayLike := ToObject(items);
  /* 11. ReturnIfAbrupt(arrayLike). */
  @ReturnIfAbrupt(arrayLike);
  /* 12. Let len be ToLength(Get(arrayLike, "length")). */
  len := ToLength(Get(arrayLike, "length"));
  /* 13. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 14. Let targetObj be AllocateTypedArray(C, len). */
  targetObj := AllocateTypedArray(C, len);
  /* 15. ReturnIfAbrupt(targetObj). */
  @ReturnIfAbrupt(targetObj);
  /* 16. Let k be 0. */
  k := 0;
  /* 17. Repeat, while k < len */
  while (k < len) {
    /* a. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* b. Let kValue be Get(arrayLike, Pk). */
    kValue := Get(arrayLike, Pk);
    /* c. ReturnIfAbrupt(kValue). */
    @ReturnIfAbrupt(kValue);
    /* d. If mapping is true, then */
    if (mapping) {
      /* i. Let mappedValue be Call(mapfn, T, «kValue, k»). */
      mappedValue := Call(mapfn, T, [kValue, k]);
      /* ii. ReturnIfAbrupt(mappedValue). */
      @ReturnIfAbrupt(mappedValue)
    }
    /* e. Else, let mappedValue be kValue. */
    else {
      mappedValue := kValue
    };
    /* f. Let setStatus be Set(targetObj, Pk, mappedValue, true). */
    setStatus := Set(targetObj, Pk, mappedValue, true);
    /* g. ReturnIfAbrupt(setStatus). */
    @ReturnIfAbrupt(setStatus);
    /* h. Increase k by 1. */
    k := k + 1
  };
  /* 18. Return targetObj. */
  return targetObj
};

/**
 * 22.2.2.2 %TypedArray%.of (...items)
 *
 * When the of method is called with any number of arguments, the following
 * steps are taken:
 */
function TypedArrayOf(global, this, strict, args) {
  /* 1. Let len be the actual number of arguments passed to this function. */
  len := l_len args;
  /* 2. Let items be the List of arguments passed to this function. */
  items := args;
  /* 3. Let C be the this value. */
  C := this;
  /* 4. If IsConstructor(C) is false, */
  if (IsConstructor(C) = false) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 5. Let newObj be AllocateTypedArray(C, len). */
  newObj := AllocateTypedArray(C, len);
  /* 6. ReturnIfAbrupt(newObj). */
  @ReturnIfAbrupt(newObj);
  /* 7. Let k be 0. */
  k := 0;
  /* 8. Repeat, while k < len */
  while (k < len) {
    /* a. Let kValue be items[k]. */
    kValue := l_nth(items, k);
    /* b. Let Pk be ToString(k). */
    Pk := ToString(k);
    /* c. Let status be Set(newObj, Pk, kValue, true). */
    status := Set(newObj, Pk, kValue, true);
    /* d. ReturnIfAbrupt(status). */
    @ReturnIfAbrupt(status);
    /* e. Increase k by 1. */
    k := k + 1
  };
  /* 9. Return newObj. */
  return newObj
};

/**
 * 22.2.2.4 get %TypedArray% [ @@species ]
 *
 * %TypedArray%[@@species] is an accessor property whose set accessor function
 * is undefined. Its get accessor function performs the following steps:
 */
function typedArraySpeciesGetter() {
  /* 1. Return the this value. */
  return this
};

/* 22.2.3 Accessor property functions */
/* 22.2.3.1 get %TypedArray%.prototype.buffer */
function getTypedArrayBuffer(global, this, strict) {
  /* Let O be the this value.*/
  O := this;
  /* If Type(O) is not Object, throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* If O does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError exception. */
  if (!("ViewedArrayBuffer" in_obj O)) {
    throw TypeErrorConstructorInternal()
  };
  /* Let buffer be the value of O’s [[ViewedArrayBuffer]] internal slot. */
  buffer := getInternalProperty(O, "ViewedArrayBuffer");
  /* Return buffer. */  
  return buffer
};

/* 22.2.3.2 get %TypedArray%.prototype.byteLength */
function getTypedArrayByteLength(global, this, strict) {
  /* Let O be the this value. */
  O := this;
  /* If Type(O) is not Object, throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* If O does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError exception. */
  if (!("ViewedArrayBuffer" in_obj O)) {
    throw TypeErrorConstructorInternal()
  };
  /* Let buffer be the value of O’s [[ViewedArrayBuffer]] internal slot. */
  buffer := getInternalProperty(O, "ViewedArrayBuffer");
  /* If IsDetachedBuffer(buffer) is true, return 0. */
  if (IsDetachedBuffer(buffer)) {
    return 0
  };
  /* Let size be the value of O’s [[ByteLength]] internal slot. */
  size := getInternalProperty(O, "ByteLength");
  /* Return size. */
  return size
};

/* 22.2.3.3 get %TypedArray%.prototype.byteOffset */
function getTypedArrayByteOffset(global, this, strict) {
  /* Let O be the this value. */
  O := this;
  /* If Type(O) is not Object, throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* If O does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError exception. */
  if (!("ViewedArrayBuffer" in_obj O)) {
    throw TypeErrorConstructorInternal()
  };
  /* Let buffer be the value of O’s [[ViewedArrayBuffer]] internal slot. */
  buffer := getInternalProperty(O, "ViewedArrayBuffer");
  /* If IsDetachedBuffer(buffer) is true, return 0. */
  if (IsDetachedBuffer(buffer)) {
    return 0
  };
  /* Let offset be the value of O’s [[ByteOffset]] internal slot. */
  offset := getInternalProperty(O, "ByteOffset");
  /* Return offset. */
  return offset
}