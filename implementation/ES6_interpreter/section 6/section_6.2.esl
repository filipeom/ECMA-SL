/*
*   6.2.2.4 ReturnIfAbrupt
*/
macro ReturnIfAbrupt (argument) {

    if (!(Type(argument) = "Completion")) {
    } elif (isAnAbruptCompletion(argument)) {
        /* 1. If argument is an abrupt completion, return argument. */
        return argument
    } else {
        /* 2. Else if argument is a Completion Record, let argument be argument.[[value]]. */
        argument := getCompletionValue(argument)
    }
};

/* 6.2.6.1 CreateByteDataBlock(size) */
function CreateByteDataBlock(size) {
    /* 1. Assert: size ≥ 0. */
    assert (size >= (0.));
    /* 2. Let db be a new Data Block value consisting of size bytes. */ 
    /*db := [];*/
    /* If it is impossible to create such a Data Block, throw a RangeError exception. */
    if (size >= (7 * 1125899906842624)) {
        throw RangeErrorConstructorInternal()
    };
    if (size = 0.) {
        size := 1.
    };
    db := array_make(int_of_float(size), float_to_byte(0.));
    
    /* i := 0.;
    while (i < size) {
        i := i + 1.;*/
        /* 3. Set all of the bytes of db to 0. */
        /*db := l_concat(db, float64_to_le_bytes(0.))
    };*/
    /* 4. Return db. */
    return db
};

/* 6.2.6.2 CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) */
function CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) {
    count := int_of_float count;
    fromIndex := int_of_float fromIndex;
    /* Assert: fromBlock and toBlock are distinct Data Block values. */
    assert (!(fromBlock = toBlock));
    /* Assert: fromIndex, toIndex, and count are positive integer values. */
    assert ((fromIndex >= 0) &&& (toIndex >= 0) &&& (count >= 0)); 
    /* Let fromSize be the number of bytes in fromBlock. */
    fromSize := a_len(fromBlock);
    /* Assert: fromIndex+count ≤ fromSize. */
    assert((fromIndex + count) <= fromSize);
    /* Let toSize be the number of bytes in toBlock. */
    toSize := a_len(toBlock);
    /* Assert: toIndex+count ≤ toSize. */
    assert((toIndex + count) <= toSize);
    /* 7. Repeat, while count>0 */
    while (count > 0) {
        /* a. Set toBlock[toIndex] to the value of fromBlock[fromIndex]. */
        a_set(toBlock, toIndex, a_nth(fromBlock, fromIndex));
        /* b. Increment toIndex and fromIndex each by 1. */
        toIndex := toIndex + 1;
        fromIndex := fromIndex + 1;
        /* c. Decrement count by 1. */
        count := count - 1
    };
    /* 8. Return NormalCompletion(empty) */
    return NormalCompletion('empty)
}