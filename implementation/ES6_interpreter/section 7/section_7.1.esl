/* 7.1 Type Conversion */

/* 7.1.14 ToPropertyKey (argument) */
function ToPropertyKey(argument){

    /* 1. Let key be ToPrimitive(argument, hint String).*/
    key := ToPrimitive(argument, 'String);

    /* 2. ReturnIfAbrupt(key). */
    @ReturnIfAbrupt(key);

    /* 3. If Type(key) is Symbol, then return key. */
    if (Type(key) = "Symbol"){
        return key
    };

    /* 4. Return ToString(key). */
    return ToString(key)
};

/* 7.1.16 CanonicalNumericIndexString ( argument ) */
function CanonicalNumericIndexString(argument){
    /* 1. Assert: Type(argument) is String. */
    assert(Type(argument) = "String");

    /* 2. If argument is "-0", return −0. */
    if (argument = "-0"){
        return -(0.)
    };

    /* 3. Let n be ToNumber(argument). */
    n := ToNumber(argument);

    /* 4. If SameValue(ToString(n), argument) is false, return undefined. */
    if (SameValue(ToString(n), argument) = false){
        return 'undefined
    };

    /* 5. Return n. */
    return n
};


/**
 * 7.1.5 ToInt32 (argument)
 *
 * The abstract operation ToInt32 converts argument to one of 2^32 integer values 
 * in the range -2^31 through 2^31-1, inclusive. This abstract operation functions 
 * as follows:
 *
 * NOTE Given the above definition of ToInt32: 
 *
 * The ToInt32 abstract operation is idempotent: if applied to a result that it 
 * produced, the second application leaves that value unchanged. 
 *
 * ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of x. (It is to 
 * preserve this latter property that +∞ and -∞ are mapped to +0.) 
 *
 * ToInt32 maps -0 to +0. 
 */
function _ToInt32(argument) {
  /* 1. Let number be ToNumber(argument). */
  number := ToNumber(argument);
  /* 2. ReturnIfAbrupt(number). */
  @ReturnIfAbrupt(number);
  /* 3. If number is NaN, +0, -0, +∞, or -∞, return +0 */
  if (is_NaN number ||| number = Infinity ||| number = -Infinity 
        ||| isZero(number) ||| isMinusZero(number)) {
    return 0.
  };
  /* 4. Let int be the mathematical value that is the same sign as number and 
     whose magnitude is floor(abs(number)). */
  int := floor(abs(number)) *(abs(number)/number);
  /* 5. Let int32bit be int modulo 2^32. */
  int32bit := mod(int, 2.**32.);
  /* 6. If int32bit >= 2^31, */
  if (int32bit >= 2.**31.) {
    /* return int32bit - 2^32,*/
    return int32bit - 2.**32.
  };
  /*  otherwise return int32bit */
  return int32bit

};

/**
 * 7.1.6 ToUint32 (argument)
 *
 * The abstract operation ToUint32 converts argument to one of 2^32 integer 
 * values in the range 0 through 2^32-1, inclusive. This abstract operation 
 * functions as follows: 
 *
 * NOTE Given the above definition of ToUint32: 
 *
 * Step 6 is the only difference between ToUint32 and ToInt32. 
 *
 * The ToUint32 abstract operation is idempotent: if applied to a result that it 
 * produced, the second application leaves that value unchanged. 
 *
 * ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of x. (It is to 
 * preserve this latter property that +∞ and -∞ are mapped to +0.) 
 *
 * ToUint32 maps -0 to +0. 
 */
function _ToUint32(argument) {
   /* 1. Let number be ToNumber(argument). */
  number := ToNumber(argument);
  /* 2. ReturnIfAbrupt(number). */
  @ReturnIfAbrupt(number);
  /* 3. If number is NaN, +0, -0, +∞, or -∞, return +0 */
  if (is_NaN number ||| number = Infinity ||| number = -Infinity 
        ||| isZero(number) ||| isMinusZero(number)) {
    return 0.
  };
  /* 4. Let int be the mathematical value that is the same sign as number and 
     whose magnitude is floor(abs(number)). */
  int := floor(abs(number)) *(abs(number)/number);
  /* 5. Let int32bit be int modulo 2^32. */
  int32bit := mod(int, 2.**32.);
  /* 6. Return int32bit. */
  return int32bit
};



/**
 * 7.1.7 ToInt16 (argument)
 *
 * The abstract operation ToInt16 converts argument to one of 2^16 integer values 
 * in the range -32768 through 32767, inclusive. This abstract operation 
 * functions as follows: 
 */
function ToInt16(argument) {
  /* 1. Let number be ToNumber(argument). */
  number := ToNumber(argument);
  /* 2. ReturnIfAbrupt(number). */
  @ReturnIfAbrupt(number);
  /* 3. If number is NaN, +0, -0, +∞, or -∞, return +0 */
  if (is_NaN number ||| number = Infinity ||| number = -Infinity 
        ||| isZero(number) ||| isMinusZero(number)) {
    return 0.
  };
  /* 4. Let int be the mathematical value that is the same sign as number and 
     whose magnitude is floor(abs(number)). */
  int := floor(abs(number)) *(abs(number)/number);
  /* 5. Let int16bit be int modulo 2^16. */
  int16bit := mod(int, 2.**16.); /* TODO */
  /* 6. If int16bit >= 2^15, */
  if (int16bit >= 2.**15.) {
    /* return int16bit - 2^16, */
    return int16bit - 2.**16.
  };
  /* otherwise return int16bit */
  return int16bit
};


/**
 * 7.1.8 ToUint16 (argument)
 *
 * The abstract operation ToUint16 converts argument to one of 2^16 integer values 
 * in the range 0 through 2^16-1, inclusive. This abstract operation 
 * functions as follows: 
 *
 * 
 * NOTE Given the above definition of ToUint16:
 *
 * The substitution of 216 for 232 in step 5 is the only difference between ToUint32 and ToUint16.
 * ToUint16 maps −0 to +0.
 */
function _ToUint16(argument) {
  /* 1. Let number be ToNumber(argument). */
  number := ToNumber(argument);
  /* 2. ReturnIfAbrupt(number). */
  @ReturnIfAbrupt(number);
  /* 3. If number is NaN, +0, -0, +∞, or -∞, return +0 */
  if (is_NaN number ||| number = Infinity ||| number = -Infinity 
        ||| isZero(number) ||| isMinusZero(number)) {
    return 0.
  };
  /* 4. Let int be the mathematical value that is the same sign as number and 
     whose magnitude is floor(abs(number)). */
  int := floor(abs(number)) *(abs(number)/number);
  /* 5. Let int16bit be int modulo 2^16. */
  int16bit := mod(int, 2.**16.);
  /* 6. Return int16bit */
  return int16bit
};


/**
 * 7.1.9 ToInt8 (argument)
 *
 * The abstract operation ToInt8 converts argument to one of 2^8 integer values 
 * in the range -128 through 127, inclusive. This abstract operation functions 
 * as follows: 
 */
function ToInt8(argument) {
  print "debug--intToInt8-1";
  print argument;
  /* 1. Let number be ToNumber(argument). */
  number := ToNumber(argument);
  /* 2. ReturnIfAbrupt(number). */
  @ReturnIfAbrupt(number);
  /* 3. If number is NaN, +0, -0, +∞, or -∞, return +0 */
  if (is_NaN number ||| number = Infinity ||| number = -Infinity 
        ||| isZero(number) ||| isMinusZero(number)) {
    return 0.
  };
  /* 4. Let int be the mathematical value that is the same sign as number and 
     whose magnitude is floor(abs(number)). */
  int := floor(abs(number)) *(abs(number)/number);
  print "debug--intToInt8-2";
  print int;
  /* 5. Let int8bit be int modulo 2^8. */
  int8bit := mod(int, 2.**8.); /*TODO usar modulo que funciona com negativos*/
  print "debug--intToInt8-3";
  print int8bit;
  /* 6. If int8bit ≥ 2^7, */
  if (int8bit >= 2.**7.) {
    /* return int8bit - 2^8, otherwise return int8bit */
    return int8bit - 2.**8.
  };
  return int8bit
};

/**
 * 7.1.10  ToUint8 (argument)
 *
 * The abstract operation ToUInt8 converts argument to one of 2^8 integer values 
 * in the range 0 through 255, inclusive. This abstract operation functions 
 * as follows: 
 */
function ToUint8(argument) {
  print "debug--intToUint8-1";
  print argument;
  /* 1. Let number be ToNumber(argument). */
  number := ToNumber(argument);
  /* 2. ReturnIfAbrupt(number). */
  @ReturnIfAbrupt(number);
  /* 3. If number is NaN, +0, -0, +∞, or -∞, return +0 */
  if (is_NaN number ||| number = Infinity ||| number = -Infinity 
        ||| isZero(number) ||| isMinusZero(number)) {
    return 0.
  };
  /* 4. Let int be the mathematical value that is the same sign as number and 
     whose magnitude is floor(abs(number)). */
  int := floor(abs(number)) *(abs(number)/number);
  print "debug--intToInt8-2";
  print int;
  /* 5. Let int8bit be int modulo 2^8. */
  int8bit := mod(int, 2.**8.); /*TODO usar modulo que funciona com negativos*/
  print "debug--intToInt8-3";
  print int8bit;
  /* 6. Return int8bit. */
  return int8bit
};

/**
 * 7.1.11  ToUint8Clamp (argument)
 *
 * The abstract operation ToUint8Clamp converts argument to one of 2^8 integer values 
 * in the range 0 through 255, inclusive. This abstract operation functions 
 * as follows:
 *
 * NOTE Unlike the other ECMAScript integer conversion abstract operation, 
 * ToUint8Clamp rounds rather than truncates non-integer values and does not convert +∞ to 0. 
 * ToUint8Clamp does “round half to even” tie-breaking. 
 * This differs from Math.round which does “round half up” tie-breaking.
 */
function ToUint8Clamp(argument) {

    /* 1. Let number be ToNumber(argument). */
    number := ToNumber(argument);
    /* 2. ReturnIfAbrupt(number). */
    @ReturnIfAbrupt(number);
    /* 3. If number is NaN, return +0. */
    if (is_NaN number){
        return 0.
    };
    /* 4. If number ≤ 0, return +0. */
    if (number <= 0.){
        return 0.
    };
    /* 5. If number ≥ 255, return 255. */
    if (number >= 255.){
        return 255.
    };
    /* 6. Let f be floor(number). */
    f := floor(number);
    /* 7. If f + 0.5 < number, return f + 1. */
    if (f + 0.5 < number){
        return (f + 1.)
    };
    /* 8. If number < f + 0.5, return f. */
    if (number < (f + 0.5)){
        return f
    };
    /* 9. If f is odd, return f + 1. */
    if (!((f % 2.) = 0.)){
        return f + 1.
    };
    /* 10. Return f. */
    return f
};


/* aux functions */

function mod(a, b) {
  res := a % b;
  if (res < 0.){
      return res + b
  };
  return res

  /* return (((a % b) + b) % b) */
}