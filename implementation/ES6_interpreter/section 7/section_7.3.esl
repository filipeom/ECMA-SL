

function GetES6 (O, P) { 
    ref := newPropertyReference(O, P, false);
    v := GetValue(ref);
    return v 
}; 


/*
*   7.3.9 GetMethod (O, P)
*/
function GetMethod(O, P) {
    /* 1.Assert: IsPropertyKey(P) is true. */
    
    /* 2. Let func be GetV(O, P). */
    func := GetES6(O, P);

    /* 3. ReturnIfAbrupt(func). */
    @ReturnIfAbrupt(func);

    /* 4. If func is either undefined or null, return undefined. */
    if ((func = 'undefined) || (func = 'null)) {
        return 'undefined
    }; 

    /* 5. If IsCallable(func) is false, throw a TypeError exception. */
    if (IsCallable(func) = false) { 
        throw TypeErrorConstructorInternal() 
    }; 

    /* 6. Return func. */
    return func 
}; 

function Invoke(O, P, argumentsList) {
  func := GetES6(O, P);
  return Call(null, null, func, O, argumentsList)
}; 

function CreateArrayFromList(elements) {
  arrayPrototype := getArrayPrototype(false);
  array := internalNewArray(arrayPrototype, []);
  len := l_len elements;
  i := 0;
  while (i < len) {
    vl := l_nth (elements, i);

    if (!(vl = null)) {
      descriptor := newDataPropertyDescriptorFull(vl, true, true, true);
      {array.DefineOwnProperty}(array, ToString(ToUint32(int_to_float i)), descriptor, false)
    };
    i := i + 1
  };
  descriptor := newDataPropertyDescriptorFull(ToUint32(int_to_float i), true, false, false);
  {array.DefineOwnProperty}(array, "length", descriptor, false);

  return array
};

/**
 * 7.3.17 CreateListFromArrayLike (obj [ , elementTypes ] )
 *
 * The abstract operation CreateListFromArrayLike is used to create a List value
 * whose elements are provided by the indexed properties of an array-like
 * object, obj. The optional argument elementTypes is a List containing the
 * names of ECMAScript Language Types that are allowed for element values of the
 * List that is created. This abstract operation performs the following steps:
 */
function CreateListFromArrayLike(obj, elementTypes) {
  /* 1. ReturnIfAbrupt(obj). */
  @ReturnIfAbrupt(obj);
  /* 2. If elementTypes was not passed, */
  if (elementTypes = null) {
    /* let elementTypes be (Undefined, Null, Boolean, String, Symbol, Number,
       Object) */
    elementTypes := ("Undefined", "Null", "Boolean", "String", "Symbol", "Number", "Object")
  };
  /* 3. If Type(obj) is not Object, */
  if (!(Type(obj) = "Object")) {
    /* throw a TypeError exception */
    throw TypeErrorConstructorInternal()
  };
  /* 4. Let len be ToLength(Get(obj, "length")). */
  len := ToLength(Get(obj, "length"));
  /* 5. ReturnIfAbrupt(len). */
  @ReturnIfAbrupt(len);
  /* 6. Let list be an empty List. */
  list := [];
  /* 7. Let index be 0. */
  index := 0.;
  /* 8. Repeat while index < len */
  while (index < len) {
    /* a. Let indexName be ToString(index). */
    indexName := ToString(index);
    /* b. Let next be Get(obj, indexName). */
    next := Get(obj, indexName);
    /* c. ReturnIfAbrupt(next). */
    @ReturnIfAbrupt(next);
    /* d. If Type(next) is not an element of elementTypes, throw a TypeError exception. */
    if (!(Type(next) in_list elementTypes)) {
      throw TypeErrorConstructorInternal()
    };
    /* e. Append next as the last element of list. */
    list := l_concat(list, [next]);
    /* f. Set index to index + 1. */
    index := index + 1.
  };
  /* 9. Return list. */
  return list
};

/* 7.3.20 SpeciesConstructor ( O, defaultConstructor ) */
/**
 * The abstract operation SpeciesConstructor is used to retrieve the constructor that should 
 * be used to create new objects that are derived from the argument object O. The defaultConstructor
 * argument is the constructor to use if a constructor @@species property cannot be found starting
 * from O. This abstract operation performs the following steps:
 */
function SpeciesConstructor(O, defaultConstructor){
    /* 1. Assert: Type(O) is Object. */
    assert(Type(O) = "Object");

    /* 2. Let C be Get(O, "constructor"). */
    C := GetNew(O, "constructor");

    /* 3. ReturnIfAbrupt(C). */
    @ReturnIfAbrupt(C);

    /* 4. If C is undefined, return defaultConstructor. */
    if (C = 'undefined){
        return defaultConstructor
    };

    /* 5. If Type(C) is not Object, throw a TypeError exception. */
    if (!(Type(C) = "Object")){
        throw TypeErrorConstructorInternal()
    };

    /* 6. Let S be Get(C, @@species). */
    S := GetNew(C, getSpeciesPropertyName());

    /* 7. ReturnIfAbrupt(S). */
    @ReturnIfAbrupt(S);

    /* 8. If S is either undefined or null, return defaultConstructor. */
    if ((S = 'undefined) ||| (S = null) ||| (S = 'null)){
        return defaultConstructor
    };

    /* 9. If IsConstructor(S) is true, return S. */
    if (IsConstructor(S) = true){
        return S
    };

    /* 10. Throw a TypeError exception. */
    throw TypeErrorConstructorInternal()
};

/**
 * 7.3.22 GetFunctionRealm (obj)
 *
 * The abstract operation GetFunctionRealm with argument obj performs the
 * following steps:
 */
function GetFunctionRealm(obj) { /* *??* */
  return 'undefined;
  /* 1. Assert: obj is a callable object. */
  assert(IsCallable(obj));
  /* 2. If obj has a [[Realm]] internal slot, then */
  if ("Realm" in_obj obj) {
    /* a. Return obj's [[Realm]] internal slot. */
    return obj.Realm
  };
  /* 3. If obj is a Bound Function exotic object, then */
  if (obj = null/* TODO: Instruction not yet implemented. */) {
    /* a. Let target be obj's [[BoundTargetFunction]] internal slot. */
    target := obj.BoundTargetFunction;
    /* b. Return GetFunctionRealm(target). */
    return GetFunctionRealm(target)
  };
  /* 4. If obj is a Proxy exotic object, then */
  if (obj = null/* TODO: Instruction not yet implemented. */) {
    /* a. If the value of the [[ProxyHandler]] internal slot of obj is null, */
    if ((obj.ProxyHandler) = 'null) {
      /* throw a TypeError exception */
      throw TypeErrorConstructorInternal()
    };
    /* b. Let proxyTarget be the value of obj's [[ProxyTarget]] internal slot. */
    proxyTarget := obj.ProxyTarget;
    /* c. Return GetFunctionRealm(proxyTarget). */
    return GetFunctionRealm(proxyTarget)
  };
  /* 5. Return the running execution context's Realm. */
  return /* TODO: Instruction not yet implemented. */
}