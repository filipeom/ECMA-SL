function InternalObjectCreate(proto) {

    newlyConstructedObject := NewECMAScriptObject();
    setAllInternalMethodsOfObject(newlyConstructedObject);

    setInternalProperty(newlyConstructedObject, "Prototype", proto);
  
    setInternalProperty(newlyConstructedObject, "Extensible", true);
  
    setInternalProperty(newlyConstructedObject, "Class", "Object");

    return newlyConstructedObject
};

function CreateDataProperty (obj, prop, val) {
    descriptor := newDataPropertyDescriptorFull(val, true, true, true);
    setJSProperty(obj, prop, descriptor); 
    return null 
};


/* CreateIterResultObject ( value, done )*/
function CreateIterResultObject ( value, done ) {
    /* 1. Let obj be ObjectCreate(%ObjectPrototype%). */
    obj := InternalObjectCreate(|ObjectPrototype|); 

    /* 2. Perform CreateDataProperty(obj, "value", value). */
    CreateDataProperty(obj, "value", value); 

    /* 3. Perform CreateDataProperty(obj, "done", done). */
    CreateDataProperty(obj, "done", done);

    /* 4. Return obj. */
    return obj 
};

/*
*   7.4.1 GetIterator ( obj, method )
*/
function GetIterator(obj, method) {

    /* 1. ReturnIfAbrupt(obj). */
    @ReturnIfAbrupt(obj); 

    /* 2. If method was not passed, then */
    if(method = null) {
        /* a. Let method be GetMethod(obj, @@iterator). */
        method := GetMethod(obj, obj.IteratorFunction);

        /* b. ReturnIfAbrupt(method). */
        @ReturnIfAbrupt(method)
    }; 

    /* 3. Let iterator be Call(method,obj). */
    iterator := Call(null, null, method, obj, []); 
    
    /* 4. ReturnIfAbrupt(iterator). */
    @ReturnIfAbrupt(obj); 

    /* If Type(iterator) is not Object, throw a TypeError exception. */
    if (!(Type(iterator) = "Object")) {
        throw TypeErrorConstructorInternal() 
    }; 

    /* Return iterator. */
    return iterator
};

/*
*   7.4.6 IteratorClose( iterator, completion )
*/

function IteratorClose(iterator, completion) {

    /* 1. Assert: Type(iterator) is Object. */
    assert(Type(iterator) = "Object");

    /* 2. Assert: completion is a Completion Record. */
    assert(Type(completion) = "Completion");
    
    /* 3. Let return be GetMethod(iterator, "return"). */
    returnVar := GetMethod(iterator, "return");

    /* 4. ReturnIfAbrupt(return). */
    @ReturnIfAbrupt(returnVar);

    /* 5. If return is undefined, return Completion(completion). */
    if (returnVar = 'undefined) {
        return completion
    };

    /* 6. Let innerResult be Call(return, iterator, «‍ »). */
    innerResult := Call(null, null, returnVar, iterator, []);

    /* 7. If completion.[[type]] is throw, return Completion(completion). */
    if (getCompletionType(completion) = 'throw) {
        return completion
    };

    /* 8. If innerResult.[[type]] is throw, return Completion(innerResult). */
    if (getCompletionType(getCompletionValue(innerResult)) = 'throw) {
        return innerResult
    };

    /* 9. If Type(innerResult.[[value]]) is not Object, throw a TypeError exception. */
    if (!(Type(getCompletionValue(innerResult)) = "Object")) {
        throw TypeErrorConstructorInternal()
    };

    /* 10. Return Completion(completion). */
    return completion
}
