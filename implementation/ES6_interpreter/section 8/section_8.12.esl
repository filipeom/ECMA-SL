function GetProps(Desc) {
  list := [];
  if ("Value" in_obj Desc) { list := l_add(list, "Value") };
  if ("Writable" in_obj Desc) { list := l_add(list, "Writable") };
  if ("Get" in_obj Desc) { list := l_add(list, "Get") };
  if ("Set" in_obj Desc) { list := l_add(list, "Set") };
  if ("Enumerable" in_obj Desc) { list := l_add(list, "Enumerable") };
  if ("Configurable" in_obj Desc) { list := l_add(list, "Configurable") };

  return list
};

/**
 * The values used here are based on Table 7 of the specification.
 */
function GetValueOrDefault(propDesc, propName) {
  objectDefaultAttributeValues := {
    Value       : 'undefined,
    Get         : 'undefined,
    Set         : 'undefined,
    Writable    : false,
    Enumerable  : false,
    Configurable: false
  };
  if (propName in_obj propDesc) {
    return propDesc[propName]
  } else {
    return objectDefaultAttributeValues[propName]
  }
};
/** See 8.12.9 */
function CreateAccessorPropertyFrom(Desc) {
  return {
    Get: GetValueOrDefault(Desc, "Get"),
    Set: GetValueOrDefault(Desc, "Set"),
    Enumerable: GetValueOrDefault(Desc, "Enumerable"),
    Configurable: GetValueOrDefault(Desc, "Configurable")
  }
};
/** See 8.12.9 */
function CreateDataPropertyFrom(Desc) {
  return {
    Value: GetValueOrDefault(Desc, "Value"),
    Writable: GetValueOrDefault(Desc, "Writable"),
    Enumerable: GetValueOrDefault(Desc, "Enumerable"),
    Configurable: GetValueOrDefault(Desc, "Configurable")
  }
};
/** See 8.12.9 */
function Reject (Throw) {
  if (Throw) {
    throw TypeErrorConstructorInternal()
  } else {
    return false
  }
};

/**
 * 8.12 Algorithms for Object Internal Methods
 *
 * In the following algorithm descriptions, assume O is a native ECMAScript object, P is a String, Desc is a Property Description record, and Throw is a Boolean flag.
 */
function GetOwnProperty(O, P) {
  print "GetOwnProperty";

  if (!(P in_obj O.JSProperties)) {
    return 'undefined
  };

  D := NewPropertyDescriptor();
  X := O.JSProperties[P];

  if (IsDataDescriptor(X)) {
    D.Value := X.Value;
    D.Writable := X.Writable
  }
  else {
    D.Get := X.Get;
    D.Set := X.Set
  };

  D.Enumerable := X.Enumerable;
  D.Configurable := X.Configurable;

  return D
};

/**
 * 8.12.2 [[GetProperty]] (P)
 *
 * When the [[GetProperty]] internal method of O is called with property name P, the following steps are taken:
 */
function GetProperty (O, P) {
  print "GetProperty";

  /** 1. Let prop be the result of calling the [[GetOwnProperty]] internal method of O with property name P. */
  prop := {O.GetOwnProperty}(O, P);

  /** 2. If prop is not undefined, return prop. */
  if (!(prop = 'undefined)) {
    return prop
  };

  /** 3. Let proto be the value of the [[Prototype]] internal property of O. */
  proto := O.Prototype;

  /** 4. If proto is null, return undefined. */
  if (proto = 'null) {
    return 'undefined
  };

  /** 5. Return the result of calling the [[GetProperty]] internal method of proto with argument P. */
  return {proto.GetProperty}(proto, P)
};

/**
 * 8.12.3 [[Get]] (P)
 *
 * When the [[Get]] internal method of O is called with property name P, the following steps are taken:
 */
/**
 * 8.12.4 [[CanPut]] (P)
 *
 * When the [[CanPut]] internal method of O is called with property name P, the following steps are taken:
 */
function CanPut(O, P) {
  print "CanPut";

  /** 1. Let desc be the result of calling the[[GetOwnProperty]] internal method of O with argument P. */
  desc := {O.GetOwnProperty}(O, P);

  /** 2. If desc is not undefined, then: */
  if (!(desc = 'undefined)) {
    /** a. If IsAccessorDescriptor(desc) is true, then: */
    if (IsAccessorPropertyDescriptor(desc)) {
      /** i. If desc.[[Set]] is undefined, then return false. */
      if (desc.Set = 'undefined) {
        return false
      }
      /** ii. Else return true. */
      else {
        return true
      }
    }
    /** b. Else, desc must be a DataDescriptor so return the value of desc.[[Writable]]. */
    else {
      return desc.Writable
    }
  };
  /** 3. Let proto be the [[Prototype]] internal property of O. */
  proto := O.Prototype;

  /** 4. If proto is null, then return the value of the [[Extensible]] internal property of O. */
  if (proto = 'null) {
    return O.Extensible
  };

  /** 5. Let inherited be the result of calling the [[GetProperty]] internal method of proto with property name P. */
  inherited := {proto.GetProperty}(proto, P);

  /** 6. If inherited is undefined, return the value of the [[Extensible]] internal property of O. */
  if (inherited = 'undefined) {
    return O.Extensible
  };

  /** 7. If IsAccessorDescriptor(inherited) is true, then */
  if (IsAccessorPropertyDescriptor(inherited)) {
    /** a. If inherited.[[Set]] is undefined, then return false. */
    if (inherited.Set = 'undefined) {
      return false
    }
    /** b. Else return true. */
    else {
      return true
    }
  }
  /** 8. Else, inherited must be a DataDescriptor */
  else {
    if (IsDataPropertyDescriptor(inherited)) {
      /** a. If the [[Extensible]] internal property of O is false, return false. */
      if (O.Extensible = false) {
        return false
      }
      /** b. Else return the value of inherited.[[Writable]]. */
      else {
        return inherited.Writable
      }
    }
  }
  /** Host objects may define additional constraints upon [[Put]] operations.
   *  If possible, host objects should not allow [[Put]] operations in situations where this definition of [[CanPut]] returns false. */
};

/**
 * 8.12.5 [[Put]] ( P, V, Throw )
 *
 * When the [[Put]] internal method of O is called with property P, value V, and Boolean flag Throw, the following steps are taken:
 */
function Put(O, P, V, Throw) {
  print "Put";

  /** 1. If the result of calling the [[CanPut]] internal method of O with argument P is false, then: */
  if ({O.CanPut}(O, P) = false) {
    /** a. If Throw is true, then throw a TypeError exception. */
    if (Throw) {
      throw TypeErrorConstructorInternal()
    }
    /** b. Else return. */
    else {
      return
    }
  };
  /** 2. Let ownDesc be the result of calling the [[GetOwnProperty]] internal method of O with argument P. */
  ownDesc := {O.GetOwnProperty}(O, P);

  /** 3. If IsDataDescriptor(ownDesc) is true, then: */
  if (IsDataPropertyDescriptor(ownDesc)) {
    /** a. Let valueDesc be the Property Descriptor {[[Value]]: V}. */
    valueDesc := {
      Value: V
    };
    /** b. Call the [[DefineOwnProperty]] internal method of O passing P, valueDesc, and Throw as arguments. */
    {O.DefineOwnProperty}(O, P, valueDesc, Throw);

    /** c. Return. */
    return
  };

  /** 4. Let desc be the result of calling the [[GetProperty]] internal method of O with argument P.
   *     This may be either an own or inherited accessor property descriptor or an inherited data property descriptor. */
  desc := {O.GetProperty}(O, P);

  /** 5. If IsAccessorDescriptor(desc) is true, then: */
  if (IsAccessorPropertyDescriptor(desc)) {
    /** a. Let setter be desc.[[Set]] which cannot be undefined. */
    setter := desc.Set;

    /** b. Call the [[Call]] internal method of setter providing O as the this value and providing V as the sole argument. */
    {setter.Call}(null, null, setter, O, [V])
  }
  /** 6. Else, create a named data property named P on object O as follows */
  else {
    /** a. Let newDesc be the Property Descriptor {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}. */
    newDesc := {
      Value: V,
      Writable: true,
      Enumerable: true,
      Configurable: true
    };

    /** b. Call the [[DefineOwnProperty]] internal method of O passing P, newDesc, and Throw as arguments. */
    {O.DefineOwnProperty}(O, P, newDesc, Throw)
  };

  /** 7. Return. */
  return
};

/**
 * 8.12.7 [[Delete]] (P, Throw)
 *
 * When the [[Delete]] internal method of O is called with property name P and the Boolean flag Throw, the following steps are taken:
 */
function Delete(O, P) {
  print "Delete";

  /** 1. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with property name P. */
  desc := {O.GetOwnProperty}(O, P);
  
  print "REAL DELETE";
  print desc;

  /** 2. If desc is undefined, then return true. */
  if (desc = 'undefined) {
    return true
  };


  /** 3. If desc.[[Configurable]] is true, then */
  if (desc.Configurable = true) {
    /** a. Remove the own property with name P from O. */
    delete (O.JSProperties)[P];

    /* ES6 property order temporary fix for JSON.stringify */
    newInternalSlotsList := [];
    len := l_len O.internalSlotsList;
    i := 0;
    while (i < len) {
      P2 := l_nth(O.internalSlotsList, i);
      if (!(P2 = P)) {
        newInternalSlotsList := l_add(newInternalSlotsList, P2)
      };
      i := i + 1
    };
    O.internalSlotsList := newInternalSlotsList;

    /** b. Return true. */
    return true
  };

  /** 5. Return false. */
  return false
};

/**
 * 8.12.8 [[DefaultValue]] (hint)
 */
function DefaultValue (O, hint) {
  if (hint = null) {
    if (getInternalProperty(O, "Class") = "Date") {
      hint := 'String
    } else {
      hint := 'Number
    }
  };

  /** When the [[DefaultValue]] internal method of O is called with hint String, the following steps are taken: */
  if (hint = 'String) {
    /** 1. Let toString be the result of calling the [[Get]] internal method of object O with argument "toString". */
    toString := {O.Get}(O, "toString");

    /** 2. If IsCallable(toString) is true then: */
    if (IsCallable(toString)) {
      /** a. Let str be the result of calling the [[Call]] internal method of toString, with O as the this value and an empty argument list. */
      str := {toString.Call}(null, null, toString, O, []);

      /** b. If str is a primitive value, return str. */
      if (IsPrimitiveValue(str)) {
        return str
      }
    };

    /** 3. Let valueOf be the result of calling the [[Get]] internal method of object O with argument "valueOf". */
    valueOf := {O.Get}(O, "valueOf");

    /** 4. If IsCallable(valueOf) is true then: */
    if (IsCallable(valueOf)) {
      /** a. Let val be the result of calling the [[Call]] internal method of valueOf, with O as the this value and an empty argument list. */
      val := {valueOf.Call}(null, null, valueOf, O, []);

      /** b. If val is a primitive value, return val. */
      if (IsPrimitiveValue(val)) {
        return val
      }
    };

    /** 5. Throw a TypeError exception. */
    throw TypeErrorConstructorInternal()
  }
  else {
    /** When the [[DefaultValue]] internal method of O is called with hint Number, the following steps are taken: */
    if (hint = 'Number) {
      /** 1. Let valueOf be the result of calling the [[Get]] internal method of object O with argument "valueOf". */
      valueOf := {O.Get}(O, "valueOf");

      /** 2. If IsCallable(valueOf) is true then: */
      if (IsCallable(valueOf)) {
        /** a. Let val be the result of calling the [[Call]] internal method of valueOf, with O as the this value and an empty argument list. */
        val := {valueOf.Call}(null, null, valueOf, O, []);

        /** b. If val is a primitive value, return val. */
        if (IsPrimitiveValue(val)) {
          return val
        }
      };

      /** 3. Let toString be the result of calling the [[Get]] internal method of object O with argument "toString". */
      toString := {O.Get}(O, "toString");

      /** 4. If IsCallable(toString) is true then: */
      if (IsCallable(toString)) {
        /** a. Let str be the result of calling the [[Call]] internal method of toString, with O as the this value and an empty argument list. */
        str := {toString.Call}(null, null, toString, O, []);

        /** b. If str is a primitive value, return str. */
        if (IsPrimitiveValue(str)) {
          return str
        }
      };

      /** 5. Throw a TypeError exception. */
      throw TypeErrorConstructorInternal()
    }
  }

/* TODO*/
/** When the [[DefaultValue]] internal method of O is called with no hint, then it behaves as if the hint were Number,
 * unless O is a Date object (see 15.9.6), in which case it behaves as if the hint were String.
 *
 * The above specification of [[DefaultValue]] for native objects can return only primitive values.
 * If a host object implements its own [[DefaultValue]] internal method,
 * it must ensure that its [[DefaultValue]] internal method can return only primitive values.
 */
};

function IsPrimitiveValue (v) {
  v_type := Type(v);
  if (v_type = "Object") {
    return false
  } else {
    return true
  }
}

