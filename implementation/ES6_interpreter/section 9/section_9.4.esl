/* 9.4 Built-in Exotic Object Internal Methods and Slots */

/* 9.4.3 String Exotic Objects */
 
/**
 * 9.4.3.4 StringCreate( value, prototype) 
 *
 * The abstract operation StringCreate with arguments value and prototype is used to specify
 * the creation of new exotic String objects. It performs the following steps:
 */
 function StringCreate(value, prototype){
    /* 1. ReturnIfAbrupt(prototype). */
    @ReturnIfAbrupt(prototype);
    
    /* 2. Assert: Type(value) is String. */
    assert(Type(value) = "String");

    /* 3. Let S be a newly created String exotic object. */
    S := NewECMAScriptObject();
    setAllInternalMethodsOfObject(S);
    setInternalProperty(S, "Class", "String");

    /* 4. Set the [[StringData]] internal slot of S to value. */
    setInternalProperty(S, "StringData", value);

    /* 5. Set S’s essential internal methods to the default ordinary object definitions specified in 9.1. */
    /**
     * All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is 
     * either null or an object and is used for implementing inheritance. Data properties of the 
     * [[Prototype]] object are inherited (are visible as properties of the child object) for the purposes
     * of get access, but not for set access. Accessor properties are inherited for both get access and 
     * set access.
     *
     * Every ordinary object has a Boolean-valued [[Extensible]] internal slot that controls whether or 
     * not properties may be added to the object. If the value of the [[Extensible]] internal slot is 
     * false then additional properties may not be added to the object. In addition, if [[Extensible]] 
     * is false the value of the [[Prototype]] internal slot of the object may not be modified. Once the
     * value of an object’s [[Extensible]] internal slot has been set to false it may not be subsequently
     * changed to true.
     *
     * In the following algorithm descriptions, assume O is an ordinary object, P is a property key value,
     * V is any ECMAScript language value, and Desc is a Property Descriptor record.
     */ 

    /* 6. Set the [[GetOwnProperty]] internal method of S as specified in 9.4.3.1. */
    setInternalProperty(S, "GetOwnProperty", "GetOwnPropertyString");

    /* 7. Set the [[HasProperty]] internal method of S as specified in 9.4.3.2. */
    setInternalProperty(S, "HasProperty", "HasPropertyString");

    /* 8. Set the [[OwnPropertyKeys]] internal method of S as specified in 9.4.3.3. */
    setInternalProperty(S, "OwnPropertyKeys", "OwnPropertyKeysString");
    
    /* 9. Set the [[Prototype]] internal slot of S to prototype. */
    setInternalProperty(S, "Prototype", prototype);

    /* 10. Set the [[Extensible]] internal slot of S to true. */
    setInternalProperty(S, "Extensible", true);

    /* 11. Let length be the number of code unit elements in value. */
    length := int_to_float(s_len_u value);

    /* 12. Let status be DefinePropertyOrThrow(S, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: false,
    [[Enumerable]]: false, [[Configurable]]: false }). */

    /**
     * NOTA
     *
     * 7.3.7 DefinePropertyOrThrow (O, P, desc) e da parte de outra pessoa - colocar depois
     */

    setJSProperty(S, "length", newDataPropertyDescriptorFull(length, false, false, false));
    
    /*
    desc := newDataPropertyDescriptorFull(int_to_float length, false, false, false);
    status := {S.DefineOwnProperty}(S, "length", {
      Value: int_to_float length,
      Writable: false,
      Enumerable: false,
      Configurable: false
    }, false);
    @ReturnIfAbrupt(status);
    if (status = false){
      throw TypeErrorConstructorInternal()
    };
    */

    /* 13. Assert: status is not an abrupt completion. */
    /*
    if(Type(status) = "Completion"){
      assert(!isAnAbruptCompletion(status))
    };
    */
    
    /* 14. Return S. */
    return S
};

/* 9.4.3.1 [[GetOwnProperty]] ( P ) */
function GetOwnPropertyString(S, P){
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert(IsPropertyKey(P) = true);

  /* 2. Let desc be OrdinaryGetOwnProperty(S, P). */
  desc := OrdinaryGetOwnProperty(S, P);

  /* 3. If desc is not undefined return desc. */
  if (!(desc = 'undefined)){
    return desc
  };

  /* 4. Return StringGetIndexProperty(S, P). */
  return StringGetIndexProperty(S, P)
};

/* 9.4.3.1.1 StringGetIndexProperty (S, P) */
function StringGetIndexProperty(S, P){  
  /* 1. If Type(P) is not String, return undefined. */
  if (!(Type(P) = "String")){
    return 'undefined
  };

  /* 2. Let index be CanonicalNumericIndexString (P). */
  index := CanonicalNumericIndexString(P);

  /* 3. Assert: index is not an abrupt completion. */
  if (Type(index) = "Completion"){
    assert(!isAnAbruptCompletion(index))
  };

  /* 4. If index is undefined, return undefined. */
  if (index = 'undefined){
    return 'undefined
  };

  /* 5. If IsInteger(index) is false, return undefined. */
  if (IsInteger(index) = false){
    return 'undefined
  };

  /* 6. If index = −0, return undefined. */
  if (isMinusZero(index)){
    return 'undefined
  };

  /* 7. Let str be the String value of the [[StringData]] internal slot of S. */
  str := S.StringData;

  /* 8. Let len be the number of elements in str. */
  len := s_len_u str;

  /* 9. If index < 0 or len ≤ index, return undefined. */
  if ((index < 0.) || ((int_to_float len) <= index)) {
    return 'undefined
  };

  /* 10. Let resultStr be a String value of length 1, containing one code unit from str, specifically the code unit at index index. */
  resultStr := s_nth_u (str, int_of_float index);

  /* 11. Return a PropertyDescriptor{ [[Value]]: resultStr, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false }. */
  return newDataPropertyDescriptorFull(resultStr, false, true, false)
};

/* 9.4.3.2 [[HasProperty]](P) */
function HasPropertyString(S, P){
  /* 1. Let elementDesc be StringGetIndexProperty(S, P). */
  elementDesc := StringGetIndexProperty(S, P);

  /* 2. If elementDesc is not undefined, return true. */
  if(!(elementDesc = 'undefined)){
    return true
  };

  /* 3. Return OrdinaryHasProperty(S, P). */
  return OrdinaryHasProperty(S, P)
};
 
/* 9.4.3.3 [[OwnPropertyKeys]] ( ) */
function OwnPropertyKeysString(O){
  /* 1. Let keys be a new empty List. */
  keys := [];
  
  /* 2. Let str be the String value of the [[StringData]] internal slot of O. */
  str := ToString(O.StringData);

  /* 3. Let len be the number of elements in str. */
  len := s_len_u str;
  
  /* 4. For each integer i starting with 0 such that i < len, in ascending order, */
  i := 0;
  while (i < len){
    /* a. Add ToString(i) as the last element of keys */
    keys := l_concat(keys, [ToString(i)]);

    i := i + 1
  };

  /* 5. For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending numeric index order, */
  foreach(P : O)[]{
    if ((Type(P) = "Number") && (ToInteger(P) >= len)){
      /* a. Add P as the last element of keys. */
      keys := l_concat(keys, [P])
    }
  };
    
  /* 6. For each own property key P of O such that Type(P) is String and P is not an integer index, in property creation order, */
  foreach(P : O)[]{
    if ((Type(P) = "String") && !(Type(P) = "Integer")){
      /* a. Add P as the last element of keys. */
      keys := l_concat(keys, [P])
    }
  };
    
  /* 7. For each own property key P of O such that Type(P) is Symbol, in property creation order, */
  foreach(P : O)[]{
    if (Type(P) = "Symbol"){
      /* a. Add P as the last element of keys. */
      keys := l_concat(keys, [P])
    }
  };
    
  /* 8. Return keys. */
  return keys
}

