/* 9.4 Built-in Exotic Object Internal Methods and Slots */

/* 9.4.3 String Exotic Objects */
 
/**
 * 9.4.3.4 StringCreate( value, prototype) 
 *
 * The abstract operation StringCreate with arguments value and prototype is used to specify
 * the creation of new exotic String objects. It performs the following steps:
 */
 function StringCreate(value, prototype){
   print "1::::";
   print value;
   print prototype;

    /* 1. ReturnIfAbrupt(prototype). */
    @ReturnIfAbrupt(prototype);
    
    /* 2. Assert: Type(value) is String. */
    assert(Type(value) = "String");

    /* 3. Let S be a newly created String exotic object. */
    S := NewECMAScriptObject();
    setAllInternalMethodsOfOrdinaryObject(S); 
    /* setInternalProperty(S, "Class", "String"); */

    /* 4. Set the [[StringData]] internal slot of S to value. */
    setInternalProperty(S, "StringData", value);

    /* 5. Set S’s essential internal methods to the default ordinary object definitions specified in 9.1. */
    setStringInternals(S);
    /**
     * All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is 
     * either null or an object and is used for implementing inheritance. Data properties of the 
     * [[Prototype]] object are inherited (are visible as properties of the child object) for the purposes
     * of get access, but not for set access. Accessor properties are inherited for both get access and 
     * set access.
     *
     * Every ordinary object has a Boolean-valued [[Extensible]] internal slot that controls whether or 
     * not properties may be added to the object. If the value of the [[Extensible]] internal slot is 
     * false then additional properties may not be added to the object. In addition, if [[Extensible]] 
     * is false the value of the [[Prototype]] internal slot of the object may not be modified. Once the
     * value of an object’s [[Extensible]] internal slot has been set to false it may not be subsequently
     * changed to true.
     *
     * In the following algorithm descriptions, assume O is an ordinary object, P is a property key value,
     * V is any ECMAScript language value, and Desc is a Property Descriptor record.
     */ 

    /* 6. Set the [[GetOwnProperty]] internal method of S as specified in 9.4.3.1. */
    setInternalProperty(S, "GetOwnProperty", "GetOwnPropertyString");

    /* 7. Set the [[HasProperty]] internal method of S as specified in 9.4.3.2. */
    setInternalProperty(S, "HasProperty", "HasPropertyString");

    /* 8. Set the [[OwnPropertyKeys]] internal method of S as specified in 9.4.3.3. */
    setInternalProperty(S, "OwnPropertyKeys", "OwnPropertyKeysString");
    
    /* 9. Set the [[Prototype]] internal slot of S to prototype. */
    setInternalProperty(S, "Prototype", prototype);

    /* 10. Set the [[Extensible]] internal slot of S to true. */
    setInternalProperty(S, "Extensible", true);

    /* 11. Let length be the number of code unit elements in value. */
    length := int_to_float(s_len_u value);

    /* 12. Let status be DefinePropertyOrThrow(S, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: false,
    [[Enumerable]]: false, [[Configurable]]: false }). */
    setJSProperty(S, "length", newDataPropertyDescriptorFull(length, false, false, false));
    /*
    status := DefinePropertyOrThrow(S, "length", newDataPropertyDescriptorFull(length, false, false, false) );
    */
    /* 13. Assert: status is not an abrupt completion. */
    /*
    if(Type(status) = "Completion"){
      assert(!isAnAbruptCompletion(status))
    };
    */
    print "2::::";
    print S;
    
    /* 14. Return S. */
    return S
};

/* 9.1 Ordinary Object Internal Methods and Internal Slots */
function setStringInternals(S){
  /* 9.1.1 [[GetPrototypeOf]] ( ) */
  setInternalProperty(S, "GetPrototypeOf", "OrdinaryObjectGetPrototypeOf");

  /* 9.1.2 [[SetPrototypeOf]] (V) */
  setInternalProperty(S, "SetPrototypeOf", "OrdinaryObjectSetPrototypeOf");

  /* 9.1.3 [[IsExtensible]] ( ) */
  setInternalProperty(S, "IsExtensible", "OrdinaryObjectIsExtensible");

  /* 9.1.4 [[PreventExtensions]] ( ) */
  setInternalProperty(S, "PreventExtensions", "OrdinaryObjectPreventExtensions");

  /* 9.1.5 [[GetOwnProperty]] (P) */

  /* 9.1.6 [[DefineOwnProperty]] (P, Desc) */
  setInternalProperty(S, "DefineOwnProperty", "OrdinaryObjectDefineOwnProperty");

  /* 9.1.7 [[HasProperty]](P) */

  /* 9.1.8 [[Get]] (P, Receiver) */
  setInternalProperty(S, "Get", "OrdinaryObjectGet");

  /* 9.1.9 [[Set]] ( P, V, Receiver) */
  setInternalProperty(S, "Set", "OrdinaryObjectSet");

  /* 9.1.10 [[Delete]] (P) */
  setInternalProperty(S, "Delete", "OrdinaryObjectDelete");

  /* 9.1.11 [[Enumerate]] () */
  setInternalProperty(S, "Enumerate", "OrdinaryObjectEnumerate");

  /* 9.1.12 [[OwnPropertyKeys]] ( ) */
  return 'null
};

/* 9.4.3.1 [[GetOwnProperty]] ( P ) */
function GetOwnPropertyString(S, P){
  /* 1. Assert: IsPropertyKey(P) is true. */
  assert(IsPropertyKey(P) = true);

  print "?????";
  print S;
  print P;
  /* 2. Let desc be OrdinaryGetOwnProperty(S, P). */
  desc := OrdinaryGetOwnProperty(S, P);

  print "helooooo";
  print desc;

  /* 3. If desc is not undefined return desc. */
  if (!(desc = 'undefined)){
    return desc
  };

  /* 4. Return StringGetIndexProperty(S, P). */
  return StringGetIndexProperty(S, P)
};

/* 9.4.3.1.1 StringGetIndexProperty (S, P) */
function StringGetIndexProperty(S, P){  
  /* 1. If Type(P) is not String, return undefined. */
  if (!(Type(P) = "String")){
    return 'undefined
  };

  print "P:::::";
  print P;

  /* 2. Let index be CanonicalNumericIndexString (P). */
  index := CanonicalNumericIndexString(P);

  /* 3. Assert: index is not an abrupt completion. */
  if (Type(index) = "Completion"){
    assert(!isAnAbruptCompletion(index))
  };

  /* 4. If index is undefined, return undefined. */
  if (index = 'undefined){
    return 'undefined
  };

  /* 5. If IsInteger(index) is false, return undefined. */
  if (IsInteger(index) = false){
    return 'undefined
  };

  /* 6. If index = −0, return undefined. */
  if (isMinusZero(index)){
    return 'undefined
  };

  /* 7. Let str be the String value of the [[StringData]] internal slot of S. */
  str := S.StringData;

  /* 8. Let len be the number of elements in str. */
  len := s_len_u str;

  /* 9. If index < 0 or len ≤ index, return undefined. */
  if ((index < 0.) || ((int_to_float len) <= index)) {
    return 'undefined
  };

  /* 10. Let resultStr be a String value of length 1, containing one code unit from str, specifically the code unit at index index. */
  resultStr := s_nth_u (str, int_of_float index);

  /* 11. Return a PropertyDescriptor{ [[Value]]: resultStr, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false }. */
  return newDataPropertyDescriptorFull(resultStr, false, true, false)
};

/* 9.4.3.2 [[HasProperty]](P) */
function HasPropertyString(S, P){
  /* 1. Let elementDesc be StringGetIndexProperty(S, P). */
  elementDesc := StringGetIndexProperty(S, P);

  /* 2. If elementDesc is not undefined, return true. */
  if(!(elementDesc = 'undefined)){
    return true
  };

  /* 3. Return OrdinaryHasProperty(S, P). */
  return OrdinaryHasProperty(S, P)
};
 
/* 9.4.3.3 [[OwnPropertyKeys]] ( ) */
function OwnPropertyKeysString(O){
  /* 1. Let keys be a new empty List. */
  keys := [];
  
  /* 2. Let str be the String value of the [[StringData]] internal slot of O. */
  str := ToString(O.StringData);

  /* 3. Let len be the number of elements in str. */
  len := int_to_float(s_len_u str);
  
  /* 4. For each integer i starting with 0 such that i < len, in ascending order, */
  i := 0.;
  while (i < len){
    /* a. Add ToString(i) as the last element of keys */
    keys := l_add(keys, ToString(i));

    i := i + 1.
  };

  /* 5. For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending numeric index order, */
  foreach(P : obj_fields O.JSProperties){
    if ((Type(P) = "Number") &&& (ToInteger(P) >= len)){
      /* a. Add P as the last element of keys. */
      keys := l_add(keys, P)
    }
  };
    
  /* 6. For each own property key P of O such that Type(P) is String and P is not an integer index, in property creation order, */
  foreach(P : obj_fields O.JSProperties){
    if ((Type(P) = "String") &&& !(Type(P) = "Number")){
      /* a. Add P as the last element of keys. */
      keys := l_add(keys, P)
    }
  };
    
  /* 7. For each own property key P of O such that Type(P) is Symbol, in property creation order, */
  foreach(P : obj_fields O.JSProperties){
    if (Type(P) = "Symbol"){
      /* a. Add P as the last element of keys. */
      keys := l_add(keys, P)
    }
  };
    
  /* 8. Return keys. */
  return keys
};

/**
 * 9.4.4.7 CreateMappedArgumentsObject (func, formals, argumentsList, env)
 *
 * The abstract operation CreateMappedArgumentsObject is called with object
 * func, parsed grammar phrase formals, List argumentsList, and Environment
 * Record env. The following steps are performed:
 */
function CreateMappedArgumentsObject(func, formals, argumentsList, env) {
  /* 1. Assert: formals does not contain a rest parameter, any binding
     patterns, or any initializers. It may contain duplicate identifiers. */
  /* TODO */
  /* 2. Let len be the number of elements in argumentsList. */
  len := l_len(argumentsList);
  /* 3. Let obj be a newly created arguments exotic object with a
     [[ParameterMap]] internal slot. */
  obj := NewECMAScriptObject();
  obj.ParameterMap := 'undefined;

  setAllInternalMethodsOfOrdinaryObject(obj);

  /* 4. Set the [[GetOwnProperty]] internal method of obj as specified in
     9.4.4.1. */
  /* TODO */
  /* 5. Set the [[DefineOwnProperty]] internal method of obj as specified in
     9.4.4.2. */
  /* TODO: Instruction not yet implemented. */
  /* 6. Set the [[Get]] internal method of obj as specified in 9.4.4.3. */
  /* TODO: Instruction not yet implemented. */
  /* 7. Set the [[Set]] internal method of obj as specified in 9.4.4.4. */
  /* TODO: Instruction not yet implemented. */
  /* 8. Set the [[Delete]] internal method of obj as specified in 9.4.4.5. */
  /* TODO: Instruction not yet implemented. */
  /* 9. Set the remainder of obj's essential internal methods to the default
     ordinary object definitions specified in 9.1. */
  /* TODO */
  /* 10. Set the [[Prototype]] internal slot of obj to %ObjectPrototype%. */
  obj.Prototype := getObjectPrototype(false);
  /* 11. Set the [[Extensible]] internal slot of obj to true. */
  obj.Extensible := true;

  /* 12. Let parameterNames be the BoundNames of formals. */
  parameterNames := formals;

  /* 13. Let numberOfParameters be the number of elements in parameterNames */
  numberOfParameters := l_len(parameterNames);

  /* 14. Let index be 0. */
  index := 0;

  /* 15. Repeat while index < len , */
  while (index < len) {
    /* a. Let val be argumentsList[index]. */
    val := l_nth(argumentsList, index);

    /* b. Perform CreateDataProperty(obj, ToString(index), val). */
    CreateDataProperty(obj, ToString(int_to_float index), val);
    index := index + 1
  };
  /* 16. Perform DefinePropertyOrThrow(obj, "length",
     PropertyDescriptor{[[Value]]: len, [[Writable]]: true, [[Enumerable]]:
     false, [[Configurable]]: true}). */
  DefinePropertyOrThrow(obj, "length", newDataPropertyDescriptorFull(int_to_float len, true, false, true));

  /* 17. Let map be ObjectCreate(null). */
  map := ObjectCreate('null, null);

  /* 18. Let mappedNames be an empty List. */
  mappedNames := [];

  /* 19. Let index be numberOfParameters - 1. */
  index := numberOfParameters - 1;

  /* 20. Repeat while index ≥ 0 , */
  while (index >= 0) {
    /* a. Let name be parameterNames[index]. */
    name := l_nth(parameterNames, index);

    /* b. If name is not an element of mappedNames, then */
    /* TODO */

    /* c. Let index be index − 1 */
    index := index - 1
  };

  /* 21. Set the [[ParameterMap]] internal slot of obj to map. */
  obj.ParameterMap := map;

  /* 22. Perform DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor
     {[[Value]]:%ArrayProto_values%, [[Writable]]: true, [[Enumerable]]:
     false, [[Configurable]]: true}). */
  status1 := DefinePropertyOrThrow(obj, "Symbol.iterator", newDataPropertyDescriptorFull(getArrayPrototype(false), true, false, true));

  /* 23. Perform DefinePropertyOrThrow(obj, "callee", PropertyDescriptor
     {[[Value]]: func, [[Writable]]: true, [[Enumerable]]: false,
     [[Configurable]]: true}). */
  status2 := DefinePropertyOrThrow(obj, "callee", newDataPropertyDescriptorFull(func, true, false, true));
  /* 24. Assert: the above property definitions will not produce an abrupt
     completion. */
  assert(!(isAnAbruptCompletion(status1) ||| isAnAbruptCompletion(status2)));
  /* 25. Return obj */
  return obj
}

