
/**
 * 7.3.3 Set (O, P, V, Throw)
 * The abstract operation Set is used to set the value of a specific property of an object. 
 * The operation is called with arguments O, P, V, and Throw where O is the object, P is the property key,
 * V is the new value for the property and Throw is a Boolean flag. 
 * 
 * This abstract operation performs the following steps:
*/
function SetNew(O, P, V, Throw) {
	/* Assert: Type(O) is Object. */
	assert(Type(O) = "Object");

	/* Assert: IsPropertyKey(P) is true. */
	assert( IsPropertyKey(P) = true );

	/* Assert: Type(Throw) is Boolean. */
	assert( Type(Throw) = "Boolean" );


	/* Let success be O.[[Set]](P, V, O). */
	success := {O.Put}(O, P, V, O);

	/* ReturnIfAbrupt(success). */
	/*
  @ReturnIfAbrupt(success);
  */

	/* If success is false and Throw is true, throw a TypeError exception. */
	if ( (success = false) &&& (Throw = true) ) {
		throw TypeErrorConstructorInternal()
	};

	/* Return success. */
	return success
};

/**
 *  7.3.4 CreateDataProperty (O, P, V)
 * The abstract operation CreateDataProperty is used to create a new own property of an object.
 * The operation is called with arguments O, P, and V where O is the object, P is the property key,
 * and V is the value for the property.
 * 
 * This abstract operation performs the following steps:
*/
function CreateDataPropertyNew(O,P,V) {
	/* Assert: Type(O) is Object. */
	assert( Type(O) = "Object" );

	/* Assert: IsPropertyKey(P) is true. */
	assert( IsPropertyKey(P) = true );

	/* Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}. */
	newDesc := newDataPropertyDescriptorFull(V, true, true, true);

	/* Return O.[[DefineOwnProperty]](P, newDesc). */
	return {O.DefineOwnProperty}(O, P, newDesc)  
};

function CreateDataPropertyOrThrowNew(O,P,V) {
	x := CreateDataPropertyOrThrow(O, P, V) catch CallHandler;
  return x
};

/**
 * 7.3.13 Construct (F, [argumentsList], [newTarget]) 
 * The abstract operation Construct is used to call the [[Construct]] internal method of a function object.
 * The operation is called with arguments F, and optionally argumentsList, and newTarget where F is the function object.
 * argumentsList and newTarget are the values to be passed as the corresponding arguments of the internal method. 
 * If argumentsList is not present, an empty List is used as its value. If newTarget is not present, F is used as its value. 
 * 
 * This abstract operation performs the following steps:
*/
function ConstructNew(F, argumentsList, newTarget) {
	/* If newTarget was not passed, let newTarget be F. */
 	if ( newTarget = null ) { 
 		newTarget := F
 	};

 	/* If argumentsList was not passed, let argumentsList be a new empty List. */
 	if ( argumentsList = null ) {
 		argumentsList := []
 	};

 	/* Assert: IsConstructor (F) is true. */
 	assert( IsConstructor(F) = true ); 

 	/* Assert: IsConstructor (newTarget) is true. */
 	assert( IsConstructor(newTarget) = true);

 	/* Return F.[[Construct]](argumentsList, newTarget). */
 	/* return {F.Construct}(F, argumentsList, newTarget) */
  return {F.Construct}(null, null, F, argumentsList, newTarget)
};

/**
 * 7.3.1 Get (O, P)
 * The abstract operation Get is used to retrieve the value of a specific property of an object. 
 * The operation is called with arguments O and P where O is the object and P is the property key. 
 * 
 * This abstract operation performs the following steps:
 * 
*/
function GetNew(O, P) {
	/* Assert: Type(O) is Object. */
	assert( Type(O) = "Object" );

	/* Assert: IsPropertyKey(P) is true. */
	assert( IsPropertyKey(P) = true );

	/* Return O.[[Get]](P, O). */
	return {O.Get}(O, P)
};

function WrappedGet(O, P) {
  getResult := Get(O, P) catch GetHandler;

  if (!(Type(getResult) = "Completion")) {
    return NormalCompletion(getResult)
  };

  return getResult
};

function GetHandler(x) {
  return throwEmptyCompletion(x)
};

function StringValue(value){
	return value
};

/**
 * 9.1.1 [[GetPrototypeOf]]()
 *
 * When the [[GetPrototypeOf]] internal method of O is called the following 
 * steps are taken: 
 */
function GetPrototypeOf(O) {
  /* 1. Return the value of the [[Prototype]] internal slot of O. */
  return getInternalProperty(O, "Prototype")
};

function InternalObjectIsExtensible(O){
  return ObjectIsExtensible(|global|, |objectConstructor|, false, [O])
};

/**
 * NOTE This abstract operation creates a property whose attributes are set to
 * the same defaults used for built-in methods and methods defined using class
 * declaration syntax. Normally, the property will not already exist. If it does
 * exist and is not configurable or if O is not extensible,
 * [[DefineOwnProperty]] will return false.
 */

/* 8.1.1.4.4 */
function GlobalInitializeBinding(envRec, N, V) {
  /* Let envRec be the global Environment Record for which the method was invoked. */

  /* Let DclRec be envRec.[[DeclarativeRecord]]. */
  DclRec := envRec.DeclarativeRecord;

  /* If DclRec.HasBinding(N) is true, then */
  if (HasBinding(DclRec, N)) {
      /* Return DclRec.InitializeBinding(N, V). */
      return InitializeBindingObjectRecord(DclRec, N, V)
  };

  /* Assert: If the binding exists it must be in the object Environment Record. */
  assert(isObjectEnvRec(envRec));

  /* Let ObjRec be envRec.[[ObjectRecord]]. */
  ObjRec := envRec.ObjectRecord;

  /* Return ObjRec.InitializeBinding(N, V). */
  return InitializeBindingObjectRecord(ObjRec, N, V)
};

function InitializeBindingDeclarativeRecordTemp(env, N, V) {
  env := env.EnvRec;
	varAlreadyDeclared := HasBinding(env, N);
  /* c. If varAlreadyDeclared is false, then */
  if (varAlreadyDeclared = false) {
    /* i. Call env’s CreateMutableBinding concrete method passing dn and configurableBindings as
          the arguments. */
    CreateMutableBinding(env, N, true);
    /* ii. Call env’s SetMutableBinding concrete method passing dn, undefined, and strict as the
            arguments.*/
    SetMutableBinding(env, N, V, true)
  };
  return 'undefined
};


function InitializeBoundName(className, value, env){
  CreateMutableBindingDeclarative(env, className, value);
  return true
};

function newSetAccessorPropertyDescriptorFull(set, enumerable, configurable) {
  desc := NewPropertyDescriptor();
  desc.Set := set;
  desc.Enumerable := enumerable;
  desc.Configurable := configurable;

  return desc
};

function temporaryInternalGetPrototypeOf (O) {
	return O.Prototype
};

function GuardedDelete(O, P) {
  status := {O.Delete}(O, P) catch deleteWrapper;
  return status
};

function deleteWrapper(error) {
    return false
};

/**
 * 8.1.2.4 NewFunctionEnvironment (F, newTarget)
 *
 * When the abstract operation NewFunctionEnvironment is called with arguments F
 * and newTarget the following steps are performed:
 */
function NewFunctionEnvironment(F, newTarget) {
  /* 1. Assert: F is an ECMAScript function. */
  assert(isESFunctionObject(F));
  /* 2. Assert: Type(newTarget) is Undefined or Object. */
  /* TODO */

  /* 3. Let env be a new Lexical Environment. */
  env := newLexicalEnvironment();
  /* 4. Let envRec be a new function Environment Record containing no
     bindings. */
  envRec := newFunctionEnvironmentRecord();
  /* 5. Set envRec.[[FunctionObject]] to F. */
  envRec.FunctionObject := F;
  /* 6. If F's [[ThisMode]] internal slot is lexical, */
  if (F.ThisMode = "lexical") {
    /* set envRec.[[thisBindingStatus]] to "lexical" */
    envRec.thisBindingStatus := "lexical"
  }
  /* 7. Else, */
  else {
    /* Set envRec.[[thisBindingStatus]] to "uninitialized" */
    envRec.thisBindingStatus := "uninitialized"
  };
  /* 8. Let home be the value of F's [[HomeObject]] internal slot. */
  home := F.HomeObject;
  /* 9. Set envRec.[[HomeObject]] to home. */
  envRec.HomeObject := home;
  /* 10. Set envRec.[[NewTarget]] to newTarget. */
  envRec.NewTarget := newTarget;
  /* 11. Set env's EnvironmentRecord to be envRec. */
  env.EnvRec := envRec;
  /* 12. Set the outer lexical environment reference of env to the value of F's
     [[Environment]] internal slot. */
  env.OuterEnvRef := F.Environment;
  /* 13. Return env. */
  print "DEBUG NEW FUNCTION ENV 0";
  print envRec;
  return env
};

function newFunctionEnvironmentRecord() {
	env := newDeclarativeEnvironmentRecord();

	env.BindThisValue 	:= "BindThisValue";
	env.GetThisBinding 	:= "GetThisBinding";
	env.GetSuperBase 		:= "GetSuperBase";
	env.HasThisBinding 	:= "HasThisBindingFunctionRecord";
	env.HasSuperBinding := "HasSuperBindingFunctionRecord";

	return env
};

function HasThisBinding(envRec) {
  if (!("thisBindingStatus" in_obj envRec)) {
    return false
  } else {
    if (envRec.thisBindingStatus = "lexical") {
      return false
    };
    return true
  }
};

function HasSuperBinding(envRec) {
  if (!("thisBindingStatus" in_obj envRec)) {
    return false
  } else {
    if (envRec.thisBindingStatus = "lexical") {
      return false
    };
    if (envRec.HomeObject = 'undefined) {
      return false
    };
    return true
  }
};

function GetSuperBase(envRec) {
  home := envRec.HomeObject;
  if (home = 'undefined) {
    return 'undefined
  };
  return GetPrototypeOf(home)
};

function GetThisBinding(envRec) {
  assert(!(envRec.thisBindingStatus = "lexical"));

  if (envRec.thisBindingStatus = "uninitialized") {
    throw ReferenceErrorConstructorInternal()
  };

  return envRec._thisValue
}

