#! /bin/node
const fs = require("fs/promises")

async function parseFile(file, fn) {
    let fh;
    try {
        fh = await fs.open(file)

        let data;
        try {
            data = await fh.readFile("UTF-8")
        } catch (e) {
            console.error(`Error reading ${file}. ${e.message}`)
        }
        
        fn(data)

    } catch (e) {
        console.error(`Error opening ${file}. ${e.message}`)
    } finally {
        fh.close()
    }
}

function firstPass(data) {
    const lines = data.split("\n")
    
    for (let line of lines) {
        if (line.startsWith("test")) {
            const testResult = TestResult.from(line, 1)
            testsResultsFile1.write(testResult)
            testsSummaryFile1.write(testResult)
        }
    }
}

function secondPass(data) {
    const lines = data.split("\n")
    
    for (let line of lines) {
        if (line.startsWith("test")) {
            let testResult = TestResult.from(line, 2)
            let compTestResult = testsResultsFile1.read(testResult.name)
            if (compTestResult) {
                if (testResult.result !== compTestResult.result) {
                    testResult.difference = {type: TestResult.DIFFERENT_RESULT, diff: `${compTestResult.result} vs ${testResult.result}`}
                }
            } else {
                testResult.difference = {type: TestResult.NOT_EXISTS}
            }
            testsResultsFile2.write(testResult)
            testsSummaryFile2.write(testResult)
        }
    }
}

function difference(set1, set2) {
    const differentResults = new TestResultCollection();

    for (let compTestResult of set1.flatten()) {
        let testResult = set2.read(compTestResult.name)
        if (testResult) {
            if (testResult.result !== compTestResult.result) {
                compTestResult.difference = {type: TestResult.DIFFERENT_RESULT, diff: `${compTestResult.result} vs ${testResult.result}`}
                differentResults.write(compTestResult)
            }
        } else {
            compTestResult.difference = {type: TestResult.NOT_EXISTS, diff: `${compTestResult.result} vs NOT_EXISTS`}
            differentResults.write(compTestResult)
        }
    }
    
    return differentResults
}

class TestResultSummary {
    _ok = 0
    _fail = 0
    _error = 0
    _notSupported = 0
    children = {}

    constructor(path = "test/test262/tests") {
        this.path = path
        this.pathSegments = path.split("/")
    }

    get total() {
        return this._ok + this._fail + this._error + this._notSupported + Object.values(this.children).reduce((acc, curr) => acc + curr.total, 0)
    }
    get totalOK() {
        return this._ok + Object.values(this.children).reduce((acc, curr) => acc + curr.totalOK, 0)
    }
    get totalFAIL() {
        return this._fail + Object.values(this.children).reduce((acc, curr) => acc + curr.totalFAIL, 0)
    }
    get totalERROR() {
        return this._error + Object.values(this.children).reduce((acc, curr) => acc + curr.totalERROR, 0)
    }
    get totalUNSUPPORTED() {
        return this._notSupported + Object.values(this.children).reduce((acc, curr) => acc + curr.totalUNSUPPORTED, 0)
    }

    OK() {
        this._ok += 1
    }

    FAIL() {
        this._fail += 1
    }

    ERROR() {
        this._error += 1
    }

    UNSUPPORTED() {
        this._notSupported += 1
    }

    write(testResult) {
        let pathSegments = testResult.name.split("/")
        
        if ((pathSegments.length - 1) === this.pathSegments.length) {
            this[testResult.result]()
        } else {
            const key = pathSegments[this.pathSegments.length]
            let next = this.children[key]
            if (!next || !(next instanceof TestResultSummary)) {
                next = this.children[key] = new TestResultSummary(this.path + "/" + key, this)
            }
            next.write(testResult)
        }
    }
    
    log() {
        console.log(`OK: ${this.totalOK} FAIL: ${this.totalFAIL} ERROR: ${this.totalERROR} UNSUPPORTED: ${this.totalUNSUPPORTED}`)
    }
}

class TestResultSummaryMerged {
    static NA = {
        totalOK: "N/A",
        totalFAIL: "N/A",
        totalERROR: "N/A",
        totalUNSUPPORTED: "N/A",
        children: {}
    }

    constructor(c1 = TestResultSummaryMerged.NA, c2 = TestResultSummaryMerged.NA) {
        this.c1 = c1 || NA
        this.c2 = c2 || NA
        this.path = this.c1.path || this.c2.path
        this.paths = new Set(Object.keys(this.c1.children).concat(Object.keys(this.c2.children)))
        this.children = {}
        for (let path of this.paths) {
            this.children[path] = new TestResultSummaryMerged(this.c1.children[path], this.c2.children[path])
        }
    }

    depth(currDepth) {
        let items = [this]

        if (currDepth === 0) {
            return items
        }

        for (let path of this.paths) {
            items = items.concat(this.children[path].depth(currDepth - 1))
        }

        return items
    }

    log() {
        console.log(`${this.path} -- OK: ${this.c1.totalOK} vs ${this.c2.totalOK} | FAIL: ${this.c1.totalFAIL} vs ${this.c2.totalFAIL} | ERROR: ${this.c1.totalERROR} vs ${this.c2.totalERROR} | UNSUPPORTED: ${this.c1.totalUNSUPPORTED} vs ${this.c2.totalUNSUPPORTED}`)
    }
}

class TestResultCollection {
    tests = {}

    write(testResult) {
        const testName = testResult.name.split("/")
        let root = this.tests
        for (let i = 0; i < testName.length - 1; ++i) {
            const segment = testName[i]
            if (!root[segment]) {
                root[segment] = {}
            }
            root = root[segment]
        }
        root[testName[testName.length - 1]] = testResult
    }

    read(testName) {
        testName = testName.split("/")
        let root = this.tests
        for (let i = 0; i < testName.length - 1; ++i) {
            const segment = testName[i]
            if (!root[segment]) {
                return undefined
            }
            root = root[segment]
        }
        return root[testName[testName.length - 1]]
    }

    flatten() {
        const array = []

        function flattenObject(obj, array) {
            const keys = Object.keys(obj)
            for (let key of keys) {
                let val = obj[key]
                if (val instanceof TestResult) {
                    array.push(val)
                } else {
                    flattenObject(val, array)
                }
            }
        }
        flattenObject(this.tests, array)

        return array
    }
}

class TestResult {
    static NOT_EXISTS = Symbol("not exists")
    static DIFFERENT_RESULT = Symbol("different result")

    constructor(name, result, sourceFile, difference) {
        this.name = name;
        this.result = result;
        this.sourceFile = sourceFile;
        this.difference = difference;
    }

    static from(str, file) {
        const components = str.split(" | ")
        return new TestResult(components[0], components[1].replace(/[_\*]*/g, ""), file, undefined)
    }
}

if (process.argv.length < 4) throw "Need 2 input file paths."
let file1 = process.argv[process.argv.length - 2]
let file2 = process.argv[process.argv.length - 1]

const excludeNotExists = process.argv.includes("-e")
const fixed = process.argv.includes("-f") || process.argv.includes("--fixed")
const noResults = process.argv.includes("--no_results") || process.argv.includes("--no-results")

// parse Summary
const summaryIndex = process.argv.indexOf("-s")
const summary = summaryIndex !== -1
let summaryDepth
if (summary) {
    summaryDepth = parseInt(process.argv[summaryIndex + 1]) || -1
}



// main function
var testsResultsFile1 = new TestResultCollection()
var testsResultsFile2 = new TestResultCollection();
var testsSummaryFile1 = new TestResultSummary()
var testsSummaryFile2 = new TestResultSummary();

(async () => {
    await parseFile(file1, firstPass)
    await parseFile(file2, secondPass)

    if (summary) {
        const merged = new TestResultSummaryMerged(testsSummaryFile1, testsSummaryFile2)
        
        const summaries = merged.depth(summaryDepth)

        summaries.forEach(s => s.log())
    } else {
        const differentResults = difference(testsResultsFile1, testsResultsFile2)

        const log = noResults ? function (testResult) {
            console.log(testResult.name)
        } : function (testResult) {
            console.log(testResult.name, testResult.difference.diff)
        }
    
        let ignoredResults = fixed ? [/^.*? vs (?!OK).*$/i] : [/^.* vs OK$/i, /^.*ERROR vs FAIL$/i]
    
        for (let testResult of differentResults.flatten()) {
            if (testResult.difference.type === TestResult.DIFFERENT_RESULT) {
                if (!ignoredResults.some(regex => testResult.difference.diff.match(regex))) {
                    log(testResult)
                }
            } else if (testResult.difference.type === TestResult.NOT_EXISTS && !excludeNotExists) {
                log(testResult)
            }
        }
    }

})()
