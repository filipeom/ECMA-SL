import "test/ES5_Reference_Interpreter.esl";

function JS_Interpreter(p) {
  match p with
  | { sourceType: "script", type: "Program", body: body } -> {
    scope := NewObject();
    i := 0;
    lbody := l_len(body);
    while (i<lbody) {
      print "Before JS_Interpreter_Stmt";
      JS_Interpreter_Stmt(l_nth(body, i), scope);
      print "After JS_Interpreter_Stmt";
      i := i + 1
    };

    return scope
  }
};

function JS_Interpreter_Expr(e, scope) {
  match e with
  | { type: "AssignmentExpression", operator: op, left: l_expr, right: r_expr} -> {
    /* 11.13.1 Simple Assignment ( = ) */
    if (op = "=") {
      lref := JS_Interpreter_Expr(l_expr, scope);
      rref := JS_Interpreter_Expr(r_expr, scope);
      rval := GetValue(rref);
      if ((Type(lref) = "Reference") &&
          (IsStrictReference(lref)) &&
          (Type(GetBase(lref)) = "EnvironmentRecord") &&
          ((GetReferencedName(lref) = "eval") || (GetReferencedName(lref) = "arguments")))
      {
        throw SyntaxErrorException()
      };
      PutValue(lref, rval);
      return rval
    }
  }
  | { type: "BinaryExpression" } -> {
    return JS_Interpreter_BinExpr(e, scope)
  }
  | { type: "Identifier", name: name } -> {
    /* 10.3.1 Identifier Resolution : TO_COMPLETE */
    return GetIdentifierReference(scope, name, true)
  }
  | { type: "Literal", value: value } -> { return value }
};

function JS_Interpreter_Stmt(s, scope) {
  match s with
  | { type: "BlockStatement", body: body } -> {
    /* TODO */
    i := 0;
    lbody := l_len(body);
    while (i<lbody) {
      JS_Interpreter_Stmt(l_nth(body, i), scope);
      i := i + 1
    };

    return scope
  }
  | { type: "ExpressionStatement", expression: Expression } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (normal, GetValue(exprRef), empty). */
    return normalEmptyCompletion(GetValue(exprRef))
  }
  | { type: "IfStatement", test: Expression, consequent: Statement1, alternate: Statement2 } -> {
    exprRef := JS_Interpreter_Expr(Expression, scope);
    if (ToBoolean(GetValue(exprRef))) {
      return JS_Interpreter_Stmt(Statement1, scope)
    }
    else {
      if (!(Statement2 = null)) {
        return JS_Interpreter_Stmt(Statement2, scope)
      };

      return normalEmptyCompletion('empty)
    }
  }
  | { type: "LabeledStatement", label: Identifier, body: Statement } -> {
    /* 12.12 Labelled Statements */
    /* TO COMPLETE: If the LabelledStatement itself has a non-empty label set, these labels are also added to
                    the label set of Statement before evaluating it */
    Statement.labelSet := [Identifier.name];

    return JS_Interpreter_Stmt(Statement, scope)
  }
  /* The label set of an IterationStatement or a SwitchStatement initially contains the single element empty. */
  | { type: "WhileStatement" } -> {
    if (!("labelSet" in s)) {
      s.LabelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
};

function JS_Interpreter_BinExpr(e, scope) {
  match e with
  | { type: "BinaryExpression", operator: "+", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* 11.6.1 The Addition operator ( + ) */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    lval := GetValue(lref);
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    rval := GetValue(rref);
    lprim := ToPrimitive(lval, "Number");
    rprim := ToPrimitive(rval, "Number");
    if ((Type(lprim) = "String") || (Type(rprim) = "String")) {
      return ToString(lprim) + ToString(rprim)
    };
    return ToNumber(lprim) + ToNumber(rprim)
  }
  | { type: "BinaryExpression", operator: "===", left: EqualityExpression, right: RelationalExpression } -> {
    /* 11.9.4 The Strict Equals Operator ( === ) */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    lval := GetValue(lref);
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    rval := GetValue(rref);

    return StrictEqualityOperator(rval, lval)
  }
  | { type: "BinaryExpression", operator: "*", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the * Operator */

    /* If either operand is NaN, the result is NaN. */
    if ((leftNum = 'NaN) && (rightNum = 'NaN)) {
      return 'NaN
    };

    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* TODO */

    /* Multiplication of an infinity by a zero results in NaN. */
    if (((rightNum = 0) || (rightNum = '+0) || (rightNum = '-0)) && ((leftNum = '+Infinity) || (leftNum = '-Infinity) || (leftNum = 'Infinity))) {
      return 'NaN
    };
    if (((leftNum = 0) || (leftNum = '+0) || (leftNum = '-0)) && ((rightNum = '+Infinity) || (rightNum = '-Infinity) || (rightNum = 'Infinity))) {
      return 'NaN
    };

    /* Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above. */
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && ((rightNum = '+Infinity) || (rightNum = 'Infinity))) {
      return '+Infinity
    };
    if ((leftNum = '-Infinity) && (rightNum = '-Infinity)) {
      return '+Infinity
    };
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && (rightNum = '-Infinity)) {
      return '-Infinity
    };
    if ((leftNum = '-Infinity) && ((rightNum = '+Infinity) || (rightNum = 'Infinity))) {
      return '-Infinity
    };

    /* Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* TODO */

    /* In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value
       using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign.
       If the magnitude is too small to represent, the result is then a zero of appropriate sign.
       The ECMAScript language requires support of gradual underflow as defined by IEEE 754. */
    /* TODO */
    return leftNum * rightNum
  }
  | { type: "BinaryExpression", operator: "/", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the / Operator */

    /* If either operand is NaN, the result is NaN. */
    if ((leftNum = 'NaN) && (rightNum = 'NaN)) {
      return 'NaN
    };

    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* TODO */

    /* Division of an infinity by an infinity results in NaN. */
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity) || (leftNum = '-Infinity)) && ((rightNum = '+Infinity) || (rightNum = 'Infinity) || (rightNum = '-Infinity))) {
      return 'NaN
    };

    /* Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above. */
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && ((rightNum = 0) || (rightNum = '+0))) {
      return '+Infinity
    };
    if ((leftNum = '-Infinity) && (rightNum = '-0)) {
      return '+Infinity
    };
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && (rightNum = '-0)) {
      return '-Infinity
    };
    if ((leftNum = '-Infinity) && ((rightNum = 0) || (rightNum = '+0))) {
      return '-Infinity
    };

    /* Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* TODO */

    /* Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above. */
    /* TODO */

    /* Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above. */
    /* TODO */

    /* Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above. */
    /* TODO */

    /* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and rounded
       to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent,
       the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the
       operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of
       gradual underflow as defined by IEEE 754.
    */
    return leftNum / rightNum
  }
  | { type: "BinaryExpression", operator: ">", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.2 The Greater-than Operator ( > ) */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is undefined, return false. Otherwise, return r. */
    if (r = 'undefined) {
      return false
    };

    return r
  }
};

function JS_Interpreter_IterationStatement(s, scope) {
  match s with
  | { type: "WhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.2 The while Statement */
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Repeat */
    repeat {
      /* a. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* b. If ToBoolean(GetValue(exprRef)) is false, return (normal, V, empty). */
      if (ToBoolean(GetValue(exprRef)) = false) {
        return normalEmptyCompletion(V)
      };
      /* c. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* d. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, then */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in currentLabelSet)) {
          /* 1. Return (normal, V, empty). */
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
}
