import "test/ES5_Reference_Interpreter.esl";

function JS_Interpreter_Program(p) {
  /* 14 Program */
  match p with
  | { sourceType: "script", type: "Program", body: SourceElementsopt, variableDeclarations: vars, functionDeclarations: funcs } -> {
    /* The production Program : SourceElements opt is evaluated as follows: */

    /* 1. The code of this Program is strict mode code if the Directive Prologue (14.1) of its SourceElements
          contains a Use Strict Directive or if any of the conditions of 10.1.1 apply. If the code of this
          Program is strict mode code, SourceElements is evaluated in the following steps as strict mode code.
          Otherwise SourceElements is evaluated in the following steps as non-strict mode code. */
    /* TODO strict */
    /* 2. If SourceElements is not present, return (normal, empty, empty). */
    if (SourceElementsopt = []) {
      return normalEmptyCompletion('empty)
    };
    /* 3. Let progCxt be a new execution context for global code as described in 10.4.1. */
    progCxt := EnteringGlobalCode(p);
    /* 4. Let result be the result of evaluating SourceElements. */
    result := JS_Interpreter_SourceElements(SourceElementsopt, progCxt);
    /* 5. Exit the execution context progCxt. */

    /* 6. Return result. */
    print progCxt;
    return result
  }
};

function JS_Interpreter_SourceElements(SourceElements, scope) {
  /* The production SourceElements : SourceElements SourceElement is evaluated as follows: */

  i := 0;
  lSourceElements := l_len(SourceElements);
  while (i < lSourceElements) {
    /* 1. Let headResult be the result of evaluating SourceElements. */
    /* 2. If headResult is an abrupt completion, return headResult. */
    /* 3. Let tailResult be result of evaluating SourceElement. */
    /* 4. If tailResult.value is empty, let V = headResult.value, otherwise let V = tailResult.value. */
    result := JS_Interpreter_Stmt(l_nth(SourceElements, i), scope);
    if (isAnAbruptCompletion(result)) {
      return result
    };
    V := getCompletionValue(result);
    i := i + 1
  };
  /* 5. Return (tailResult.type, V, tailResult.target) */
  return newCompletion(getCompletionType(result), V, getCompletionTarget(result))
};

function JS_Interpreter_Expr(e, scope) {
  match e with
  | { type: "ThisExpression" } -> {
    /* 11.1.1 The this Keyword */

    /* The this keyword evaluates to the value of the ThisBinding of the current execution context. */
    return getThisBinding(scope)
  }
  | { type: "Identifier", name: name } -> {
    /* 11.1.2 Identifier Reference */

    /* An Identifier is evaluated by performing Identifier Resolution as specified in 10.3.1. The result of evaluating an
       Identifier is always a value of type Reference. */
    return IdentifierResolution(name, scope)
  }
  | { type: "Literal", value: value } -> {
    /* 11.1.3 Literal Reference */

    /* A Literal is evaluated as described in 7.8. */
    return formingTheValueOfTheNumericLiteral(value)
  }
  | { type: "ObjectExpression" } -> {
    /* 11.1.5 Object Initialiser */
    return JS_Interpreter_ObjectInitializer(e, scope)
  }
  | { type: "ProtoAssignment", object: Object, value: Expression } -> {
    /* This pattern match is specific to this implementation and
       does not exist specified in the ES5 standard.
       Was created to test the assignment of a value to the Prototype of an object. */
    objectReference := JS_Interpreter_Expr(Object, scope);
    objectLocation := GetValue(objectReference);
    valueReference := JS_Interpreter_Expr(Expression, scope);
    value := GetValue(valueReference);

    objectLocation.Prototype := value;

    return value
  }
  | { type: "ESLPrint", value: Argument } -> {
    arg := JS_Interpreter_Expr(Argument, scope);
    argValue := GetValue(arg);

    print s_concat ["JSPrint - ", argValue];

    return argValue
  }
  | { type: "MemberExpression", object: MemberExpression, property: Expression } -> {
    /* 11.2.1 Property Accessors */

    /* The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows: */
    /* 1. Let baseReference be the result of evaluating MemberExpression. */
    baseReference := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let baseValue be GetValue(baseReference). */
    baseValue := GetValue(baseReference);
    /* 3. Let propertyNameReference be the result of evaluating Expression. */
    propertyNameReference := JS_Interpreter_Expr(Expression, scope);
    /* 4. Let propertyNameValue be GetValue(propertyNameReference). */
    propertyNameValue := GetValue(propertyNameReference);
    /* 5. Call CheckObjectCoercible(baseValue). */
    CheckObjectCoercible(baseValue);
    /* 6. Let propertyNameString be ToString(propertyNameValue). */
    propertyNameString := ToString(propertyNameValue);
    /* 7. If the syntactic production that is being evaluated is contained in strict mode code,
          let strict be true, else let strict be false. */
    strict := true; /* TODO */
    /* 8. Return a value of type Reference whose base value is baseValue and whose referenced name is
          propertyNameString, and whose strict mode flag is strict. */
    return newValueReference(baseValue, propertyNameString, strict)
  }
  | { type: "CallExpression", callee: MemberExpression, arguments: Arguments } -> {
    /* 11.2.3 Function Calls */

    /* The production CallExpression : MemberExpression Arguments is evaluated as follows: */
    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let func be GetValue(ref). */
    func := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (see 11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(func) is not Object, throw a TypeError exception. */
    if (!(Type(func) = "Object")) {
      throw TypeErrorException()
    };
    /* 5. If IsCallable(func) is false, throw a TypeError exception. */
    if (IsCallable(func) = false) {
      throw TypeErrorException()
    };
    /* 6. If Type(ref) is Reference, then */
    if (Type(ref) = "Reference") {
      /* a. If IsPropertyReference(ref) is true, then */
      if (IsPropertyReference(ref) = true) {
        /* i. Let thisValue be GetBase(ref). */
        thisValue := GetBase(ref)
      }
      /* b. Else, the base of ref is an Environment Record */
      else {
        /* i. Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). */
        thisValue := ImplicitThisValue(GetBase(ref))
      }
    }
    /* 7. Else, Type(ref) is not Reference. */
    else {
      /* a. Let thisValue be undefined. */
      thisValue := 'undefined
    };
    /* 8. Return the result of calling the [[Call]] internal method on func, providing thisValue as the this value
          and providing the list argList as the argument values. */
    return Call(func, thisValue, argList)
  }
  | { type: "FunctionExpression", id: Identifier, params: FormalParameterList, body: FunctionBody } -> {
    /* 11.2.5 Function Expressions */

    /* The production MemberExpression : FunctionExpression is evaluated as follows: */
    /* 1. Return the result of evaluating FunctionExpression. */
    return JS_Interpreter_FunctionExpression(e, scope)
  }
  | { type: "AssignmentExpression", operator: op, left: l_expr, right: r_expr} -> {
    /* 11.13.1 Simple Assignment ( = ) */
    if (op = "=") {
      lref := JS_Interpreter_Expr(l_expr, scope);
      rref := JS_Interpreter_Expr(r_expr, scope);
      rval := GetValue(rref);
      if ((Type(lref) = "Reference") &&
          (IsStrictReference(lref)) &&
          (Type(GetBase(lref)) = "EnvironmentRecord") &&
          ((GetReferencedName(lref) = "eval") || (GetReferencedName(lref) = "arguments")))
      {
        throw SyntaxErrorException()
      };
      PutValue(lref, rval, getGlobalObject(getLexicalEnvironment(scope)));
      return rval
    }
  }
  | { type: "BinaryExpression" } -> {
    return JS_Interpreter_BinExpr(e, scope)
  }
};

function JS_Interpreter_Arguments(ArgumentsList, scope) {
  /* 11.2.4 Argument Lists */
  /* The evaluation of an argument list produces a List of values (see 8.8). */

  /* The production ArgumentList : ArgumentList , AssignmentExpression is evaluated as follows:*/

  args := [];
  lArguments := l_len ArgumentsList;
  i := 0;
  /* 1. Let precedingArgs be the result of evaluating ArgumentList. */
  while(lArguments > i) {
    /* 2. Let ref be the result of evaluating AssignmentExpression. */
    ref := JS_Interpreter_Expr(l_nth(ArgumentsList, i), scope);
    /* 3. Let arg be GetValue(ref). */
    arg := GetValue(ref);

    args := l_add(args, arg);

    i := i + 1
  };

  /* 4. Return a List whose length is one greater than the length of precedingArgs and whose items are the items of
        precedingArgs, in order, followed at the end by arg which is the last item of the new list. */
  return args
};

function JS_Interpreter_FunctionDeclaration(FunctionDeclaration, scope) {
  print "JS_Interpreter_FunctionDeclaration";
  print FunctionDeclaration;
  /* 13 Function Definition */
  match FunctionDeclaration with
  | { id: Identifier, params: FormalParameterListopt, body: FunctionBody } -> {
    /* The production FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Return the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt , and body specified by FunctionBody. Pass in the VariableEnvironment of the running
          execution context as the Scope. Pass in true as the Strict flag if the FunctionDeclaration is contained in
          strict code or if its FunctionBody is strict code. */
    return CreateFunctionObject(FormalParameterListopt, FunctionBody, getVariableEnvironment(scope), false) /* TODO strict */
  }
};

function JS_Interpreter_FunctionExpression(FunctionExpression, scope) {
  /* 13 Function Definition */
  match FunctionExpression with
  | { id: null, params: FormalParameterList, body: FunctionBody } -> {
    /* The production FunctionExpression : function ( FormalParameterList opt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Return the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt and body specified by FunctionBody. Pass in the LexicalEnvironment of the running
          execution context as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in
          strict code or if its FunctionBody is strict code. */
    return CreateFunctionObject(FormalParameterList, FunctionBody, getLexicalEnvironment(scope), false) /* TODO strict */
  }
  | { id: Identifier, params: FormalParameterListopt, body: FunctionBody } -> {
    /* The production FunctionExpression : function Identifier ( FormalParameterList opt ) { FunctionBody }
       is evaluated as follows: */

    /* 1. Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context‘s
          Lexical Environment as the argument. */
    funcEnv := NewDeclarativeEnvironment(getLexicalEnvironment(scope));
    /* 2. Let envRec be funcEnv’s environment record. */
    envRec := getEnvironmentRecord(funcEnv);
    /* 3. Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument. */
    CreateImmutableBinding(envRec, Identifier.name);
    /* 4. Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by
          FormalParameterList opt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the
          Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code. */
    closure := CreateFunctionObject(FormalParameterListopt, FunctionBody, funcEnv, false); /* TODO strict */
    /* 5. Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure
          as the arguments. */
    InitializeImmutableBinding(envRec, Identifier.name, closure);
    /* 6. Return closure. */
    return closure


    /* NOTE The Identifier in a FunctionExpression can be referenced from inside the FunctionExpression's FunctionBody to
            allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the Identifier in a
            FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression. */
  }
};

function JS_Interpreter_FunctionBody(SourceElementsopt, scope) {
  /* The production FunctionBody : SourceElements opt is evaluated as follows: */

  /* 1. The code of this FunctionBody is strict mode code if it is part of a FunctionDeclaration or
        FunctionExpression that is contained in strict mode code or if the Directive Prologue (14.1)
        of its SourceElements contains a Use Strict Directive or if any of the conditions in 10.1.1 apply.
        If the code of this FunctionBody is strict mode code, SourceElements is evaluated in the following
        steps as strict mode code. Otherwise, SourceElements is evaluated in the following steps as
        non-strict mode code. */
  /* TODO strict */
  /* 2. If SourceElements is present return the result of evaluating SourceElements. */
  if (!(SourceElementsopt = [])) {
    return JS_Interpreter_SourceElements(SourceElementsopt, scope)
  }
  /* 3. Else return (normal, undefined, empty). */
  else {
    return normalEmptyCompletion('undefined)
  }
};

function JS_Interpreter_ObjectInitializer(objExpr, scope) {
  /* 11.1.5 Object Initialiser */
  match objExpr with
  | { type: "ObjectExpression", properties: PropertyNameAndValueList } -> {
    /* The production ObjectLiteral : { } is evaluated as follows: */
    /* Return a new object created as if by the expression new Object() where Object
        is the standard built-in constructor with that name. */
    if (l_len PropertyNameAndValueList = 0) {
      return NewObject()
    };

    /* The production PropertyNameAndValueList : PropertyAssignment is evaluated as follows: */

    /* 1. Let obj be the result of creating a new object as if by the expression new Object()
          where Object is the standard built-in constructor with that name. */
    obj := NewObject();

    /* The production PropertyNameAndValueList : PropertyNameAndValueList , PropertyAssignment is evaluated as follows: */

    /* 1. Let obj be the result of evaluating PropertyNameAndValueList. */
    lPropList := l_len PropertyNameAndValueList;
    i := 0;
    while (i < lPropList) {
      /* 2. Let propId be the result of evaluating PropertyAssignment. */
      propId := JS_Interpreter_PropertyAssignment(l_nth(PropertyNameAndValueList, i), scope);
      /* 3. Let previous be the result of calling the [[GetOwnProperty]] internal method of obj with argument
            propId.name. */
      previous := GetOwnProperty(obj, getPropertyName(propId));
      /* 4. If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true */
      if (!(previous = 'undefined)) {
        /* a. This production is contained in strict code and IsDataDescriptor(previous) is true and
              IsDataDescriptor(propId.descriptor) is true. */
        if (/* TODO (strict = true) */ false &&
            (IsDataPropertyDescriptor(previous) = true) &&
            (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) = true)) {
          throw SyntaxErrorException()
        };
        /* b. IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true. */
        if ((IsDataPropertyDescriptor(previous) = true) &&
            (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) = true)) {
          throw SyntaxErrorException()
        };
        /* c. IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true. */
        if ((IsAccessorPropertyDescriptor(previous) = true) &&
            (IsDataPropertyDescriptor(getPropertyDescriptor(propId)) = true)) {
          throw SyntaxErrorException()
        };
        /* d. IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true and
              either both previous and propId.descriptor have [[Get]] fields or both previous and propId.descriptor
              have [[Set]] fields */
        if ((IsAccessorPropertyDescriptor(previous) = true) &&
            (IsAccessorPropertyDescriptor(getPropertyDescriptor(propId)) = true) &&
            ((("Get" in_obj previous) && (!(previous.Get = 'undefined)) && ("Get" in_obj getPropertyDescriptor(propId)) && !(getPropertyDescriptor(propId).Get = 'undefined)) ||
             (("Set" in_obj previous) && (!(previous.Set = 'undefined)) && ("Set" in_obj getPropertyDescriptor(propId)) && !(getPropertyDescriptor(propId).Set = 'undefined)))) {
          throw SyntaxErrorException()
        }
      };

      /* 5. Call the [[DefineOwnProperty]] internal method of obj with arguments propId.name, propId.descriptor, and
            false. */
      DefineOwnProperty(obj, getPropertyName(propId), getPropertyDescriptor(propId), false);

      i := i + 1
    };
    /* 6. Return obj. */
    return obj
  }
};

function JS_Interpreter_PropertyAssignment (PropertyAssignment, scope) {
  match PropertyAssignment with
  | { type: "Property", key: PropertyName, value: AssignmentExpression, kind: "init" } -> {
    /* The production PropertyAssignment : PropertyName : AssignmentExpression is evaluated as follows: */

    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let exprValue be the result of evaluating AssignmentExpression. */
    exprValue := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 3. Let propValue be GetValue(exprValue). */
    propValue := GetValue(exprValue);
    /* 4. Let desc be the Property Descriptor{[[Value]]: propValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newDataPropertyDescriptor(propValue);
    /* 5. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc)
  }
  | { type: "Property", key: PropertyName, value: FunctionExpression, kind: "get" } -> {
    /* The production PropertyAssignment : get PropertyName ( ) { FunctionBody } is evaluated as follows: */

    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let closure be the result of creating a new Function object as specified in 13.2 with an empty parameter list
          and body specified by FunctionBody. Pass in the LexicalEnvironment of the running execution context as the
          Scope. Pass in true as the Strict flag if the PropertyAssignment is contained in strict code or if its
          FunctionBody is strict code. */
    closure := JS_Interpreter_FunctionExpression(FunctionExpression, scope);
    /* 3. Let desc be the Property Descriptor{[[Get]]: closure, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newGetAccessorPropertyDescriptor(closure);
    /* 4. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc)
  }
  | { type: "Property", key: PropertyName, value: FunctionExpression, kind: "set" } -> {
    /* The production PropertyAssignment : set PropertyName ( PropertySetParameterList ) { FunctionBody } is
       evaluated as follows: */

    /* 1. Let propName be the result of evaluating PropertyName. */
    propName := JS_Interpreter_PropertyName(PropertyName, scope);
    /* 2. Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by
          PropertySetParameterList and body specified by FunctionBody. Pass in the LexicalEnvironment of the
          running execution context as the Scope. Pass in true as the Strict flag if the PropertyAssignment is contained
          in strict code or if its FunctionBody is strict code. */
    closure := JS_Interpreter_FunctionExpression(FunctionExpression, scope);
    /* 3. Let desc be the Property Descriptor{[[Set]]: closure, [[Enumerable]]: true, [[Configurable]]: true} */
    desc := newSetAccessorPropertyDescriptor(closure);
    /* 4. Return Property Identifier (propName, desc). */
    return newPropertyIdentifier(propName, desc)
  }
};

function JS_Interpreter_PropertyName(PropertyName, scope) {
  match PropertyName with
  /* The production PropertyName : IdentifierName is evaluated as follows: */
  | { type: "Identifier", name: IdentifierName } -> {
    /* 1. Return the String value containing the same sequence of characters as the IdentifierName. */
    return IdentifierName
  }
  /* The production PropertyName : StringLiteral is evaluated as follows: */
  | { type: "Literal", value: Literal } -> {
    /* Return the SV of the StringLiteral. */
    if (typeof Literal = __$Str) {
      return Literal
    };
    /* The production PropertyName : NumericLiteral is evaluated as follows: */

    /* 1. Let nbr be the result of forming the value of the NumericLiteral. */
    nbr := formingTheValueOfTheNumericLiteral(Literal);
    /* 2. Return ToString(nbr). */
    return ToString(nbr)
  }
};

function JS_Interpreter_Stmt(s, scope) {
  match s with
  | { type: "BlockStatement", body: StatementList } -> {
    /* 12.1 Block */
    if ((l_len StatementList) = 0) {
      return normalEmptyCompletion('empty)
    };

    return JS_Interpreter_StmtList(StatementList, scope)
  }
  | { type: "VariableDeclaration", declarations: VariableDeclarationList } -> {
    /* 12.2 Variable Statement */

    /* The production VariableStatement : var VariableDeclarationList ; is evaluated as follows: */

    i := 0;
    lVarDecl := l_len VariableDeclarationList;
    while(lVarDecl > i) {
      /* 1. Evaluate VariableDeclarationList. */
      JS_Interpreter_VarDecl(l_nth(VariableDeclarationList, i), scope);
      i := i + 1
    };
    /* 2. Return (normal, empty, empty).*/
    return normalEmptyCompletion('empty)
  }
  | { type: "EmptyStatement" } -> {
    return normalEmptyCompletion('empty)
  }
  | { type: "ExpressionStatement", expression: Expression } -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (normal, GetValue(exprRef), empty). */
    return normalEmptyCompletion(GetValue(exprRef))
  }
  | { type: "IfStatement", test: Expression, consequent: Statement1, alternate: Statement2 } -> {
    exprRef := JS_Interpreter_Expr(Expression, scope);
    if (ToBoolean(GetValue(exprRef))) {
      return JS_Interpreter_Stmt(Statement1, scope)
    }
    else {
      if (!(Statement2 = null)) {
        return JS_Interpreter_Stmt(Statement2, scope)
      };

      return normalEmptyCompletion('empty)
    }
  }
  | { type: "LabeledStatement", label: Identifier, body: Statement } -> {
    /* 12.12 Labelled Statements */
    /* The production Identifier : Statement is evaluated by adding Identifier to the label set of Statement
      and then evaluating Statement. */
    if (!("labelSet" in_obj Statement)) {
      Statement.labelSet := []
    };
    Statement.labelSet := l_add(Statement.labelSet, Identifier.name);
    /* If the LabelledStatement itself has a non-empty label set, these labels are also added to
       the label set of Statement before evaluating it */
    if ("labelSet" in_obj s) {
      Statement.labelSet := l_concat(s.labelSet, Statement.labelSet)
    };

    return JS_Interpreter_Stmt(Statement, scope)
  }
  /* The label set of an IterationStatement or a SwitchStatement initially contains the single element empty. */
  | { type: "DoWhileStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "WhileStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "ForStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "ForInStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_IterationStatement(s, scope)
  }
  | { type: "ContinueStatement", label: Identifier } -> {
    /* 12.7 The continue Statement */
    /* A ContinueStatement without an Identifier is evaluated as follows: */
    if (Identifier = null) {
      /* 1. Return (continue, empty, empty). */
      return newCompletion('continue, 'empty, 'empty)
    };

    /* A ContinueStatement with the optional Identifier is evaluated as follows:
       1. Return (continue, empty, Identifier). */
    return newCompletion('continue, 'empty, Identifier.name)
  }
  | { type: "BreakStatement", label: Identifier } -> {
    /* 12.8 The break Statement */
    /* A BreakStatement without an Identifier is evaluated as follows: */
    if (Identifier = null) {
      /* 1. Return (break, empty, empty). */
      return newCompletion('break, 'empty, 'empty)
    };

    /* A BreakStatement with an Identifier is evaluated as follows:
       1. Return (break, empty, Identifier). */
    return newCompletion('break, 'empty, Identifier.name)
  }
  | { type: "ReturnStatement", argument: Expression } -> {
    /* 12.9 The return Statement */
    /* 1. If the Expression is not present, return (return, undefined, empty). */
    if (Expression = null) {
      return newCompletion('return, 'undefined, 'empty)
    };
    /* 2. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Return (return, GetValue(exprRef), empty). */
    return newCompletion('return, GetValue(exprRef), 'empty)
  }
  | { type: "WithStatement", object: Expression, body: Statement } -> {
    /* 12.10 The with Statement */

    /* The with statement adds an object environment record for a computed object to the lexical environment of
       the current execution context. It then executes a statement using this augmented lexical environment.
       Finally, it restores the original lexical environment. */

    /* The production WithStatement : with ( Expression ) Statement is evaluated as follows: */

    /* 1. Let val be the result of evaluating Expression. */
    val := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let obj be ToObject(GetValue(val)). */
    obj := ToObject(GetValue(val));
    /* 3. Let oldEnv be the running execution context‘s LexicalEnvironment. */
    oldEnv := getLexicalEnvironment(scope);
    /* 4. Let newEnv be the result of calling NewObjectEnvironment passing obj and oldEnv as the arguments. */
    newEnv := NewObjectEnvironment(obj, oldEnv);
    /* 5. Set the provideThis flag of newEnv to true. */
    setProvideThis(newEnv, true);
    /* 6. Set the running execution context‘s LexicalEnvironment to newEnv. */
    setLexicalEnvironment(scope, newEnv);
    /* 7. Let C be the result of evaluating Statement but if an exception is thrown during the evaluation, let C be
          (throw, V, empty), where V is the exception. (Execution now proceeds as if no exception were thrown.) */
    C := JS_Interpreter_Stmt(Statement, scope);
    /* 8. Set the running execution context‘s Lexical Environment to oldEnv. */
    setLexicalEnvironment(scope, oldEnv);
    /* 9. Return C. */
    return C
  }
  | { type: "SwitchStatement" } -> {
    if (!("labelSet" in_obj s)) {
      s.labelSet := []
    };

    s.labelSet := l_add(s.labelSet, 'empty);

    return JS_Interpreter_SwitchStatement(s, scope)
  }
  | { type: "ThrowStatement", argument: Expression } -> {
    /* 12.13 The throw Statement */
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (throw, GetValue(exprRef), empty). */
    return newCompletion('throw, GetValue(exprRef), 'empty)
  }
  | { type: "TryStatement" } -> {
    /* 12.14 The try Statement */

    /* The try statement encloses a block of code in which an exceptional condition can occur, such as a runtime
       error or a throw statement. The catch clause provides the exception-handling code. When a catch clause
       catches an exception, its Identifier is bound to that exception. */

    return JS_Interpreter_TryStatement(s, scope)
  }
  | { type: "DebuggerStatement" } -> {
    /* 12.15 The debugger statement */

    /* Evaluating the DebuggerStatement production may allow an implementation to cause a breakpoint when run
       under a debugger. If a debugger is not present or active this statement has no observable effect. */

    /* The production DebuggerStatement : debugger ; is evaluated as follows: */

    /* 1. If an implementation defined debugging facility is available and enabled, then */
    if(existsDebuggerImplementation()) { /* TODO */
      /* a. Perform an implementation defined debugging action. */
      /* b. Let result be an implementation defined Completion value. */
      result := debuggerAction() /* TODO */
    }
    /* 2. Else */
    else {
      /* a. Let result be (normal, empty, empty). */
      result := normalEmptyCompletion('empty)
    };
    /* 3. Return result. */
    return result
  }
};

function JS_Interpreter_TryStatement(TryStatement, scope) {
  match TryStatement with
  | { type: "TryStatement", block: Block, handler: Catch, finalizer: null } -> {
    /* The production TryStatement : try Block Catch is evaluated as follows: */

    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 2. If B.type is not throw, return B. */
    if (!(getCompletionType(B) = 'throw)) {
      return B
    };
    /* 3. Return the result of evaluating Catch with parameter B.value. */
    return JS_Interpreter_Catch(Catch, getCompletionValue(B), scope)
  }
  | { type: "TryStatement", block: Block, handler: null, finalizer: Finally } -> {
    /* The production TryStatement : try Block Finally is evaluated as follows: */

    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 2. Let F be the result of evaluating Finally. */
    F := JS_Interpreter_Stmt(Finally, scope);
    /* 3. If F.type is normal, return B. */
    if (getCompletionType(F) = 'normal) {
      return B
    };
    /* 4. Return F. */
    return F
  }
  | { type: "TryStatement", block: Block, handler: Catch, finalizer: Finally } -> {
    /* The production TryStatement : try Block Catch Finally is evaluated as follows: */

    /* 1. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 2. If B.type is throw, then */
    if (getCompletionType(B) = 'throw) {
      /* a. Let C be the result of evaluating Catch with parameter B.value. */
      C := JS_Interpreter_Catch(Catch, getCompletionValue(B), scope)
    }
    /* 3. Else, B.type is not throw, */
    else {
      /* a. Let C be B. */
      C := B
    };
    /* 4. Let F be the result of evaluating Finally. */
    F := JS_Interpreter_Stmt(Finally, scope);
    /* 5. If F.type is normal, return C. */
    if (getCompletionType(F) = 'normal) {
      return C
    };
    /* 6. Return F. */
    return F
  }
};

function JS_Interpreter_Catch(Catch, parameter, scope) {
  match Catch with
  | { type: "CatchClause", param: Identifier, body: Block } -> {
    /* The production Catch : catch ( Identifier ) Block is evaluated as follows: */

    /* 1. Let C be the parameter that has been passed to this production. */
    C := parameter;
    /* 2. Let oldEnv be the running execution context‘s LexicalEnvironment. */
    oldEnv := getLexicalEnvironment(scope);
    /* 3. Let catchEnv be the result of calling NewDeclarativeEnvironment passing oldEnv as the argument. */
    catchEnv := NewDeclarativeEnvironment(oldEnv);
    /* 4. Call the CreateMutableBinding concrete method of catchEnv passing the Identifier String value as the
          argument. */
    CreateMutableBinding(getEnvironmentRecord(catchEnv), Identifier.name, false); /* TODO the third argument is optional as in the method signature */
    /* 5. Call the SetMutableBinding concrete method of catchEnv passing the Identifier, C, and false as arguments.
          Note that the last argument is immaterial in this situation. */
    SetMutableBinding(getEnvironmentRecord(catchEnv), Identifier.name, C, false);
    /* 6. Set the running execution context‘s LexicalEnvironment to catchEnv. */
    setLexicalEnvironment(scope, catchEnv);
    /* 7. Let B be the result of evaluating Block. */
    B := JS_Interpreter_Stmt(Block, scope);
    /* 8. Set the running execution context‘s LexicalEnvironment to oldEnv. */
    setLexicalEnvironment(scope, oldEnv);
    /* 9. Return B. */
    return B
  }
};

function JS_Interpreter_VarDecl(variableDeclaration, scope) {
  match variableDeclaration with
  | { type: "VariableDeclarator", id: Identifier, init: null } -> {
    /* The production VariableDeclaration : Identifier is evaluated as follows: */

    /* 1. Return a String value containing the same sequence of characters as in the Identifier. */
    /* return Identifier.name */
    return Identifier
  }
  | { type: "VariableDeclarator", id: Identifier, init: Initialiser } -> {
    /* The production VariableDeclaration : Identifier Initialiser is evaluated as follows: */

    /* 1. Let lhs be the result of evaluating Identifier as described in 11.1.2. */
    lhs := JS_Interpreter_Expr(Identifier, scope);
    /* 2. Let rhs be the result of evaluating Initialiser. */
    rhs := JS_Interpreter_Expr(Initialiser, scope);
    /* 3. Let value be GetValue(rhs). */
    value := GetValue(rhs);
    /* 4. Call PutValue(lhs, value). */
    PutValue(lhs, value, getGlobalObject(getLexicalEnvironment(scope)));
    /* 5. Return a String value containing the same sequence of characters as in the Identifier. */
    /* return Identifier.name */
    return Identifier
  }
  | { type: "VariableDeclaration", declarations: VariableDeclarationListNoIn } -> {
    /* Pattern created specifically for the ForInStatement where the VariableDeclarationListNoIn can only contain one VariableDeclarator
       and where the String returned by this function is used in the evaluation of the ForInStatement */
    ret := null;
    i := 0;
    ldeclarations := l_len VariableDeclarationListNoIn;
    while (ldeclarations > i) {
      ret := JS_Interpreter_VarDecl(l_nth(VariableDeclarationListNoIn, i), scope);
      i := i + 1
    };

    return ret
  }
};

function JS_Interpreter_StmtList(stmts, scope) {
  V := 'empty;
  i := 0;
  lstmts := l_len stmts;
  while (i < lstmts) {
    stmt := JS_Interpreter_Stmt(l_nth(stmts, i), scope);
    if (isAnAbruptCompletion(stmt)) {
      return stmt
    };
    if (!(getCompletionValue(stmt) = 'empty)) {
      V := getCompletionValue(stmt)
    };
    i := i + 1
  };

  return newCompletion(getCompletionType(stmt), V, getCompletionTarget(stmt))
};

function JS_Interpreter_BinExpr(e, scope) {
  match e with
  | { type: "BinaryExpression", operator: "+", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* 11.6.1 The Addition operator ( + ) */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    lval := GetValue(lref);
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    rval := GetValue(rref);
    lprim := ToPrimitive(lval, "Number");
    rprim := ToPrimitive(rval, "Number");
    if ((Type(lprim) = "String") || (Type(rprim) = "String")) {
      return ToString(lprim) + ToString(rprim)
    };
    return ToNumber(lprim) + ToNumber(rprim)
  }
  | { type: "BinaryExpression", operator: "-", left: AdditiveExpression, right: MultiplicativeExpression } -> {
    /* 11.6.1 The Addition operator ( + ) */
    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToNumber(lval). */
    lnum := ToNumber(lval);
    /* 6. Let rnum be ToNumber(rval). */
    rnum := ToNumber(rval);
    /* 7. Return the result of applying the subtraction operation to lnum and rnum.
          See the note below 11.6.3. /* TODO */
    return lnum - rnum
  }
  | { type: "BinaryExpression", operator: "===", left: EqualityExpression, right: RelationalExpression } -> {
    /* 11.9.4 The Strict Equals Operator ( === ) */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    lval := GetValue(lref);
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    rval := GetValue(rref);

    return StrictEqualityOperator(rval, lval)
  }
  | { type: "BinaryExpression", operator: "*", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the * Operator */

    /* If either operand is NaN, the result is NaN. */
    if ((leftNum = 'NaN) && (rightNum = 'NaN)) {
      return 'NaN
    };

    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* TODO */

    /* Multiplication of an infinity by a zero results in NaN. */
    if (((rightNum = 0) || (rightNum = '+0) || (rightNum = '-0)) && ((leftNum = '+Infinity) || (leftNum = '-Infinity) || (leftNum = 'Infinity))) {
      return 'NaN
    };
    if (((leftNum = 0) || (leftNum = '+0) || (leftNum = '-0)) && ((rightNum = '+Infinity) || (rightNum = '-Infinity) || (rightNum = 'Infinity))) {
      return 'NaN
    };

    /* Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above. */
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && ((rightNum = '+Infinity) || (rightNum = 'Infinity))) {
      return '+Infinity
    };
    if ((leftNum = '-Infinity) && (rightNum = '-Infinity)) {
      return '+Infinity
    };
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && (rightNum = '-Infinity)) {
      return '-Infinity
    };
    if ((leftNum = '-Infinity) && ((rightNum = '+Infinity) || (rightNum = 'Infinity))) {
      return '-Infinity
    };

    /* Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* TODO */

    /* In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value
       using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign.
       If the magnitude is too small to represent, the result is then a zero of appropriate sign.
       The ECMAScript language requires support of gradual underflow as defined by IEEE 754. */
    /* TODO */
    return leftNum * rightNum
  }
  | { type: "BinaryExpression", operator: "/", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the / Operator */

    /* If either operand is NaN, the result is NaN. */
    if ((leftNum = 'NaN) && (rightNum = 'NaN)) {
      return 'NaN
    };

    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* TODO */

    /* Division of an infinity by an infinity results in NaN. */
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity) || (leftNum = '-Infinity)) && ((rightNum = '+Infinity) || (rightNum = 'Infinity) || (rightNum = '-Infinity))) {
      return 'NaN
    };

    /* Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above. */
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && ((rightNum = 0) || (rightNum = '+0))) {
      return '+Infinity
    };
    if ((leftNum = '-Infinity) && (rightNum = '-0)) {
      return '+Infinity
    };
    if (((leftNum = '+Infinity) || (leftNum = 'Infinity)) && (rightNum = '-0)) {
      return '-Infinity
    };
    if ((leftNum = '-Infinity) && ((rightNum = 0) || (rightNum = '+0))) {
      return '-Infinity
    };

    /* Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* TODO */

    /* Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above. */
    /* TODO */

    /* Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above. */
    /* TODO */

    /* Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above. */
    /* TODO */

    /* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and rounded
       to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent,
       the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the
       operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of
       gradual underflow as defined by IEEE 754.
    */
    return leftNum / rightNum
  }
  | { type: "BinaryExpression", operator: ">", left: RelationalExpression, right: ShiftExpression } -> {
    /* 11.8.2 The Greater-than Operator ( > ) */

    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is undefined, return false. Otherwise, return r. */
    if (r = 'undefined) {
      return false
    };

    return r
  }
};

function JS_Interpreter_IterationStatement(iterStmt, scope) {
  match iterStmt with
  | { type: "DoWhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.1 The do-while Statement */
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Let iterating be true. */
    iterating := true;
    /* 3. Repeat, while iterating is true */
    repeat {
      /* a. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* b. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* c. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* d. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* e. If ToBoolean(GetValue(exprRef)) is false, set iterating to false. */
      if (ToBoolean(GetValue(exprRef)) = false) {
        iterating := false
      }
    } until iterating = false;
    /* 4. Return (normal, V, empty); */
    return normalEmptyCompletion(V)
  }
  | { type: "WhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.2 The while Statement */
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Repeat */
    repeat {
      /* a. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* b. If ToBoolean(GetValue(exprRef)) is false, return (normal, V, empty). */
      if (ToBoolean(GetValue(exprRef)) = false) {
        return normalEmptyCompletion(V)
      };
      /* c. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* d. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, then */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
          /* 1. Return (normal, V, empty). */
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
  | { type: "ForStatement", init: Expr_or_VarDecl_or_Null } -> {
    if (Expr_or_VarDecl_or_Null = null) {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope)
    };

    match Expr_or_VarDecl_or_Null with
    | { type: "VariableDeclaration" } -> {
      return JS_Interpreter_ForStmt_VarDecl(iterStmt, scope)
    }
    | default -> {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope)
    }
  }
  | { type: "ForInStatement", left: lhsExpr_or_VarDecl } -> {
    /* 12.6.4 The for-in Statement */
    match lhsExpr_or_VarDecl with
    | { type: "VariableDeclaration", kind: "var" } -> {
      /* production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement */
      return JS_Interpreter_ForInStmt_VarDecl(iterStmt, scope)
    }
    | { type: "Identifier" } -> {
      /* production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement */
      return JS_Interpreter_ForInStmt_lhsExpr(iterStmt, scope)
    }
  }
};

function JS_Interpreter_SwitchStatement(switchStmt, scope) {
  match switchStmt with
  | { type: "SwitchStatement", discriminant: Expression, cases: CaseBlock, labelSet: currentLabelSet } -> {
    /* 12.11 The switch Statement */
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let R be the result of evaluating CaseBlock, passing it GetValue(exprRef) as a parameter. */
    R := JS_Interpreter_CaseBlock(CaseBlock, GetValue(exprRef), scope);
    /* 3. If R.type is break and R.target is in the current label set, return (normal, R.value, empty). */
    if ((getCompletionType(R) = 'break) && (getCompletionTarget(R) in_list currentLabelSet)) {
      return normalEmptyCompletion(getCompletionValue(R))
    };
    /* 4. Return R. */
    return R
  }
};

function JS_Interpreter_ForInStmt_lhsExpr(forInStmt, scope) {
  match forInStmt with
  | { type: "ForInStatement", left: LeftHandSideExpression, right: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* The production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement is evaluated as follows: */

    /* 1. Let exprRef be the result of evaluating the Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Let experValue be GetValue(exprRef). */
    experValue := GetValue(exprRef);
    /* 3. If experValue is null or undefined, return (normal, empty, empty). */
    if ((experValue = null) || (experValue = 'undefined)) {
      return normalEmptyCompletion('empty)
    };
    /* 4. Let obj be ToObject(experValue). */
    obj := ToObject(experValue);
    /* 5. Let V = empty. */
    V := 'empty;
    /* 6. Repeat */
    i := 0;
    obj_enums := getEnumerableProperties(obj);
    repeat {
      /* a. Let P be the name of the next property of obj whose [[Enumerable]] attribute is true.
            If there is no such property, return (normal, V, empty). */
      P := getNextPropertyName(obj_enums, i);
      i := i + 1;
      if (P = "None") {
        return normalEmptyCompletion(V)
      };
      /* b. Let lhsRef be the result of evaluating the LeftHandSideExpression ( it may be evaluated repeatedly). */
      lhsRef := JS_Interpreter_Expr(LeftHandSideExpression, scope);
      /* c. Call PutValue(lhsRef, P). */
      PutValue(lhsRef, P, getGlobalObject(getLexicalEnvironment(scope)));
      /* d. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* e. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* f. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* g. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !(getCompletionTarget(stmt) in_list currentLabelSet)) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
};

function JS_Interpreter_ForInStmt_VarDecl(forInStmt, scope) {
  match forInStmt with
  | { type: "ForInStatement", left: VariableDeclarationNoIn, right: Expression, body: Statement, labelSet: currentLabelSet } -> {
    /* The production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement is evaluated as follows: */

    /* 1. Let varName be the result of evaluating VariableDeclarationNoIn. */
    varName := JS_Interpreter_VarDecl(VariableDeclarationNoIn, scope);
    /* 2. Let exprRef be the result of evaluating the Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Let experValue be GetValue(exprRef). */
    experValue := GetValue(exprRef);
    /* 4. If experValue is null or undefined, return (normal, empty, empty). */
    if ((experValue = null) || (experValue = 'undefined)) {
      return normalEmptyCompletion('empty)
    };
    /* 5. Let obj be ToObject(experValue). */
    obj := ToObject(experValue);
    /* 6. Let V = empty. */
    V := 'empty;
    /* 7. Repeat */
    i := 0;
    obj_enums := getEnumerableProperties(obj);
    repeat {
      /* a. Let P be the name of the next property of obj whose [[Enumerable]] attribute is true.
            If there is no such property, return (normal, V, empty). */
      P := getNextPropertyName(obj_enums, i);
      i := i + 1;
      if (P = "None") {
        return normalEmptyCompletion(V)
      };
      /* b. Let varRef be the result of evaluating varName as if it were an Identifier Reference (11.1.2);
            it may be evaluated repeatedly. */
      varRef := JS_Interpreter_Expr(varName, scope);
      /* c. Call PutValue(varRef, P). */
      PutValue(varRef, P, getGlobalObject(getLexicalEnvironment(scope)));
      /* d. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* e. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* f. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* g. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !(getCompletionTarget(stmt) in_list currentLabelSet)) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
};

function JS_Interpreter_ForStmt_Expr(forStmt, scope) {
  match forStmt with
  | { type: "ForStatement", init: ExpressionNoIn, test: Expression1, update: Expression2, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.3 The for Statement
       The production IterationStatement : for (ExpressionNoIn opt ; Expression opt ; Expression opt ) Statement
       is evaluated as follows: */

    /* 1. If ExpressionNoIn is present, then. */
    if (!(ExpressionNoIn = null)) {
      /* a. Let exprRef be the result of evaluating ExpressionNoIn. */
      exprRef := JS_Interpreter_Expr(ExpressionNoIn, scope);
      /* b. Call GetValue(exprRef). (This value is not used but the call may have side-effects.) */
      GetValue(exprRef)
    };
    /* 2. Let V = empty. */
    V := 'empty;
    /* 3. Repeat */
    repeat {
      /* a. If the first Expression is present, then */
      if (!(Expression1 = null)) {
        /* i. Let testExprRef be the result of evaluating the first Expression. */
        testExprRef := JS_Interpreter_Expr(Expression1, scope);
        /* ii. If ToBoolean(GetValue(testExprRef)) is false, return (normal, V, empty). */
        if (ToBoolean(GetValue(testExprRef)) = false) {
          return normalEmptyCompletion(V)
        }
      };
      /* b. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* c. If stmt.value is not empty, let V = stmt.value */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V = getCompletionValue(stmt)
      };
      /* d. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !((getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* f. If the second Expression is present, then */
      if (!(Expression2 = null)) {
        /* i. Let incExprRef be the result of evaluating the second Expression. */
        incExprRef := JS_Interpreter_Expr(Expression2, scope);
        /* ii. Call GetValue(incExprRef). (This value is not used.) */
        GetValue(incExprRef)
      }
    }
  }
};

function JS_Interpreter_ForStmt_VarDecl(forStmt, scope) {
  match forStmt with
  | { type: "ForStatement", init: VariableDeclarationListNoIn, test: Expression1, update: Expression2, body: Statement, labelSet: currentLabelSet } -> {
    /* 12.6.3 The for Statement
       The production IterationStatement : for ( var VariableDeclarationListNoIn ; Expression opt ; Expression opt ) Statement
       is evaluated as follows: */

    /* 1. Evaluate VariableDeclarationListNoIn. */
    JS_Interpreter_Stmt(VariableDeclarationListNoIn);
    /* 2. Let V = empty. */
    V := 'empty;
    /* 3. Repeat */
    repeat {
      /* a. If the first Expression is present, then */
      if (!(Expression1 = null)) {
        /* i. Let testExprRef be the result of evaluating the first Expression. */
        testExprRef := JS_Interpreter_Expr(Expression1, scope);
        /* ii. If ToBoolean(GetValue(testExprRef)) is false, return (normal, V, empty). */
        if (ToBoolean(GetValue(testExprRef)) = false) {
          return normalEmptyCompletion(V)
        }
      };
      /* b. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope);
      /* c. If stmt.value is not empty, let V = stmt.value */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V = getCompletionValue(stmt)
      };
      /* d. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
      if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
        return normalEmptyCompletion(V)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || !((getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* f. If the second Expression is present, then */
      if (!(Expression2 = null)) {
        /* i. Let incExprRef be the result of evaluating the second Expression. */
        incExprRef := JS_Interpreter_Expr(Expression2, scope);
        /* ii. Call GetValue(incExprRef). (This value is not used.) */
        GetValue(incExprRef)
      }
    }
  }
};

function JS_Interpreter_CaseBlock(caseBlock, input, scope) {
  /* production CaseBlock : { CaseClauses opt } */
  if (l_nth(caseBlock, 1) = null) {
    casesA := l_nth(caseBlock, 0);
    return JS_Interpreter_CaseBlock_CaseClauses(casesA, input, scope)
  } else {
    /* production CaseBlock : { CaseClauses opt DefaultClause CaseClauses opt } */
    clausesA := l_nth(caseBlock, 0);
    defaultClause := l_nth(caseBlock, 1);
    clausesB := l_nth(caseBlock, 2);
    return JS_Interpreter_CaseBlock_ClausesA_DefaultClause_ClausesB(clausesA, defaultClause, clausesB, input, scope)
  }
};

function JS_Interpreter_CaseBlock_CaseClauses(caseClauses, input, scope) {
  /* 1. Let V = empty. */
  V := 'empty;
  /* 2. Let A be the list of CaseClause items in source text order. */
  A := caseClauses;
  /* 3. Let searching be true. */
  searching := true;
  /* 4. Repeat, while searching is true */
  i := 0;
  repeat {
    /* a. Let C be the next CaseClause in A. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (C = "None") {
      return normalEmptyCompletion(V)
    };
    /* b. Let clauseSelector be the result of evaluating C. */
    clauseSelector := JS_Interpreter_SwitchCase(C, scope);
    /* c. If input is equal to clauseSelector as defined by the === operator, then */
    if (StrictEqualityOperator(GetValue(clauseSelector), GetValue(input))) {
      /* i. Set searching to false. */
      searching := false;
      /* ii. If C has a StatementList, then */
      if (hasStatementList(C)) {
        /* 1. Evaluate C‘s StatementList and let R be the result. */
        R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
        /* 2. If R is an abrupt completion, then return R. */
        if (isAnAbruptCompletion(R)) {
          return R
        };
        /* 3. Let V = R.value. */
        V := getCompletionValue(R)
      }
    }
  } until searching = false;
  /* 5. Repeat */
  i := 0;
  repeat {
    /* a. Let C be the next CaseClause in A. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (C = "None") {
      return normalEmptyCompletion(V)
    };
    /* b. If C has a StatementList, then */
    if (hasStatementList(C)) {
      /* i. Evaluate C‘s StatementList and let R be the result. */
      R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
      /* ii. If R.value is not empty, then let V = R.value. */
      if (!(getCompletionValue(R) = 'empty)) {
        V := getCompletionValue(R)
      };
      /* iii. If R is an abrupt completion, then return (R.type, V, R.target). */
      if (isAnAbruptCompletion(R)) {
        return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
      }
    }
  }
};

function JS_Interpreter_CaseBlock_ClausesA_DefaultClause_ClausesB(clausesA, DefaultClause, clausesB, input, scope) {
  /* 1. Let V = empty. */
  V := 'empty;
  /* 2. Let A be the list of CaseClause items in the first CaseClauses, in source text order. */
  A := clausesA;
  /* 3. Let B be the list of CaseClause items in the second CaseClauses, in source text order. */
  B := clausesB;
  /* 4. Let found be false. */
  found := false;
  /* 5. Repeat letting C be in order each CaseClause in A */
  i := 0;
  repeat {
    C := getNextCaseClause(A, i);
    i := i + 1;
    if (!(C = "None")) {
      /* a. If found is false, then */
      if (found = false) {
        /* i. Let clauseSelector be the result of evaluating C. */
        clauseSelector := JS_Interpreter_SwitchCase(C, scope);
        /* ii. If input is equal to clauseSelector as defined by the === operator, then set found to true. */
        if (StrictEqualityOperator(GetValue(clauseSelector), GetValue(input))) {
          found := true
        }
      };
      /* b. If found is true, then */
      if (found = true) {
        /* i. If C has a StatementList, then */
        if (hasStatementList(C)) {
          /* 1. Evaluate C‘s StatementList and let R be the result. */
          R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
          /* 2. If R.value is not empty, then let V = R.value. */
          if (!(getCompletionValue(R) = 'empty)) {
            V := getCompletionValue(R)
          };
          /* 3. R is an abrupt completion, then return (R.type, V, R.target). */
          if (isAnAbruptCompletion(R)) {
            return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
          }
        }
      }
    }
  } until C = "None";
  /* 6. Let foundInB be false. */
  foundInB := false;
  /* 7. If found is false, then */
  i := 0;
  if (found = false) {
    /* a. Repeat, while foundInB is false and all elements of B have not been processed */
    repeat {
      /* i. Let C be the next CaseClause in B. */
      C := getNextCaseClause(B, i);
      i := i + 1;
      if (!(C = "None")) {
        /* ii. Let clauseSelector be the result of evaluating C. */
        clauseSelector := JS_Interpreter_SwitchCase(C, scope);
        /* iii. If input is equal to clauseSelector as defined by the === operator, then */
        if (StrictEqualityOperator(GetValue(clauseSelector), GetValue(input))) {
          /* 1. Set foundInB to true. */
          foundInB := true;
          /* 2. If C has a StatementList, then */
          if (hasStatementList(C)) {
            /* a  Evaluate C‘s StatementList and let R be the result. */
            R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
            /* b  If R.value is not empty, then let V = R.value. */
            if (!(getCompletionValue(R) = 'empty)) {
              V := getCompletionValue(R)
            };
            /* c  R is an abrupt completion, then return (R.type, V, R.target). */
            if (isAnAbruptCompletion(R)) {
              return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
            }
          }
        }
      }
    } until (foundInB = true) || (C = "None")
  };
  /* 8. If foundInB is false and the DefaultClause has a StatementList, then */
  if ((foundInB = false) && hasStatementList(DefaultClause)) {
    /* a. Evaluate the DefaultClause’s StatementList and let R be the result. */
    R := JS_Interpreter_StmtList(getCaseClauseStatementList(DefaultClause), scope);
    /* b. If R.value is not empty, then let V = R.value. */
    if (!(getCompletionValue(R) = 'empty)) {
      V := getCompletionValue(R)
    };
    /* c. If R is an abrupt completion, then return (R.type, V, R.target). */
    if (isAnAbruptCompletion(R)) {
      return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
    }
  };
  /* 9. Repeat (Note that if step 7.a.i has been performed this loop does not start at the beginning of B) */
  repeat {
    /* a. Let C be the next CaseClause in B. If there is no such CaseClause, return (normal, V, empty). */
    C := getNextCaseClause(B, i);
    i := i + 1;
    if (C = "None") {
      return normalEmptyCompletion(V)
    };
    /* b. If C has a StatementList, then */
    if (hasStatementList(C)) {
      /* i. Evaluate C‘s StatementList and let R be the result. */
      R := JS_Interpreter_StmtList(getCaseClauseStatementList(C), scope);
      /* ii. If R.value is not empty, then let V = R.value. */
      if (!(getCompletionValue(R) = 'empty)) {
        V := getCompletionValue(R)
      };
      /* iii. If R is an abrupt completion, then return (R.type, V, R.target). */
      if (isAnAbruptCompletion(R)) {
        return newCompletion(getCompletionType(R), V, getCompletionTarget(R))
      }
    }
  }
};

function JS_Interpreter_SwitchCase(switchCase, scope) {
  match switchCase with
  | { type: "SwitchCase", test: Expression } -> {
    return JS_Interpreter_Expr(Expression, scope)
  }
}
