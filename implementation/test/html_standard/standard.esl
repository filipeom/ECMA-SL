/* @name: "section 8.12" */
/**
 * 8.12 Algorithms for Object Internal Methods
 *
 * In the following algorithm descriptions, assume O is a native ECMAScript object, P is a String, Desc is a Property Description record, and Throw is a Boolean flag.
 */

/**
 * 8.12.1 [[GetOwnProperty]] (P)
 *
 * When the [[GetOwnProperty]] internal method of O is called with property name P, the following steps are taken:
 */
function GetOwnProperty(O, P) [
  "8.12.1",
  "When the [[GetOwnProperty]] internal method of <var>O</var> is called with property name <var>P</var>, the following steps are taken:",
  "However, if <var>O</var> is a String object it has a more elaborate [[GetOwnProperty]] internal method defined in <a href=\"#sec-15.5.5.2\">15.5.5.2</a>.",
  "[[GetOwnProperty]]"
] {
  print "GetOwnProperty";

  /* 1. If O doesn‘t have an own property with name P, return undefined. */
  if (!(P in_obj O.JSProperties)) {
    return 'undefined
  };

  /* 2. Let D be a newly created Property Descriptor with no fields. */
  D := NewPropertyDescriptor();
  /* 3. Let X be O‘s own property named P. */
  X := getJSProperty(O, P);

  /* 4. If X is a data property, then */
  if (IsDataPropertyDescriptor(X)) ["after-same:, then"] {
    /* a. Set D.[[Value]] to the value of X‘s [[Value]] attribute. */
    D.Value := X.Value;
    /* b. Set D.[[Writable]] to the value of X‘s [[Writable]] attribute */
    D.Writable := X.Writable
  }
  /* 5. Else X is an accessor property, so */
  else ["after-same: <i>X</i> is an accessor property, so"] {
    /* a. Set D.[[Get]] to the value of X‘s [[Get]] attribute. */
    D.Get := X.Get;
    /* b. Set D.[[Set]] to the value of X‘s [[Set]] attribute. */
    D.Set := X.Set
  };

  /* 6. Set D.[[Enumerable]] to the value of X‘s [[Enumerable]] attribute. */
  D.Enumerable := X.Enumerable;
  /* 7. Set D.[[Configurable]] to the value of X‘s [[Configurable]] attribute. */
  D.Configurable := X.Configurable;

  /* 8. Return D. */
  return D

  /* However, if O is a String object it has a more elaborate [[GetOwnProperty]] internal method defined in 15.5.5.2. */
};

/**
 * 8.12.2 [[GetProperty]] (P)
 *
 * When the [[GetProperty]] internal method of O is called with property name P, the following steps are taken:
 */
/* function GetProperty (O, P) { */
function GetProperty (O, P) [
  "8.12.2",
  "When the [[GetProperty]] internal method of <var>O</var> is called with property name <var>P</var>, the following steps are taken:",
  "",
  "[[GetProperty]]"
] {
  print "GetProperty";

  /** 1. Let prop be the result of calling the [[GetOwnProperty]] internal method of O with property name P. */
  prop := {O.GetOwnProperty}(O, P);

  /** 2. If prop is not undefined, return prop. */
  if (!(prop = 'undefined)) {
    return prop
  };

  /** 3. Let proto be the value of the [[Prototype]] internal property of O. */
  proto := O.Prototype;

  /** 4. If proto is null, return undefined. */
  if (proto = 'null) {
    return 'undefined
  };

  /** 5. Return the result of calling the [[GetProperty]] internal method of proto with argument P. */
  return {proto.GetProperty}(proto, P)
};

/**
 * 8.12.3 [[Get]] (P)
 *
 * When the [[Get]] internal method of O is called with property name P, the following steps are taken:
 */
function Get(O, P) [
  "8.12.3",
  "When the [[Get]] internal method of <var>O</var> is called with property name <var>P</var>, the following steps are taken:",
  "",
  "[[Get]]"
] {
  print "Get";

  /** 1. Let desc be the result of calling the [[GetProperty]] internal method of O with property name P. */
  desc := {O.GetProperty}(O, P);

  /** 2. If desc is undefined, return undefined. */
  if (desc = 'undefined) {
    return 'undefined
  };

  /** 3. If IsDataDescriptor(desc) is true, return desc.[[Value]]. */
  if (IsDataPropertyDescriptor(desc) = true) {
    return desc.Value
  };
  /** 4. Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be desc.[[Get]]. */
  gen_wrapper ["before-same:Otherwise, <a href=\"#sec-8.10.1\">IsAccessorDescriptor</a>(desc) must be true so, "] {
    getter := desc.Get
  };

  /** 5. If getter is undefined, return undefined. */
  if (getter = 'undefined) {
    return 'undefined
  };

  /** 6. Return the result calling the [[Call]] internal method of getter providing O as the this value and providing no arguments. */
  return {getter.Call}(null, null, getter, O, [])
};

/**
 * 8.12.4 [[CanPut]] (P)
 *
 * When the [[CanPut]] internal method of O is called with property name P, the following steps are taken:
 */
function CanPut(O, P) [
  "8.12.4",
  "When the [[CanPut]] internal method of <var>O</var> is called with property name <var>P</var>, the following steps are taken:",
  "Host objects may define additional constraints upon [[Put]] operations. If possible, host objects should not allow [[Put]] operations in situations where this definition of [[CanPut]] returns false.",
  "[[CanPut]]"
]{
  print "CanPut";

  /** 1. Let desc be the result of calling the[[GetOwnProperty]] internal method of O with argument P. */
  desc := {O.GetOwnProperty}(O, P);

  /** 2. If desc is not undefined, then */
  if (!(desc = 'undefined)) ["after-same:, then"] {
    /** a. If IsAccessorDescriptor(desc) is true, then */
    if (IsAccessorPropertyDescriptor(desc) = true) ["after-same:, then"] {
      /** i. If desc.[[Set]] is undefined, then return false. */
      if (desc.Set = 'undefined) ["after-same:then"]  {
        return false
      }
      /** ii. Else return true. */
      else {
        return true
      }
    }
    /** b. Else, desc must be a DataDescriptor so return the value of desc.[[Writable]]. */
    else ["after-same:, <i>desc</i> must be a DataDescriptor so"] {
      return desc.Writable
    }
  };
  /** 3. Let proto be the [[Prototype]] internal property of O. */
  proto := O.Prototype;

  /** 4. If proto is null, then return the value of the [[Extensible]] internal property of O. */
  if (proto = 'null) ["after-same:then"] {
    return O.Extensible
  };

  /** 5. Let inherited be the result of calling the [[GetProperty]] internal method of proto with property name P. */
  inherited := {proto.GetProperty}(proto, P);

  /** 6. If inherited is undefined, return the value of the [[Extensible]] internal property of O. */
  if (inherited = 'undefined) {
    return O.Extensible
  };

  /** 7. If IsAccessorDescriptor(inherited) is true, then */
  if (IsAccessorPropertyDescriptor(inherited) = true) ["after-same:, then"] {
    /** a. If inherited.[[Set]] is undefined, then return false. */
    if (inherited.Set = 'undefined) ["after-same:then"] {
      return false
    }
    /** b. Else return true. */
    else {
      return true
    }
  }
  /** 8. Else, inherited must be a DataDescriptor */
  else ["after-same:, <i>inherited</i> must be a DataDescriptor"] {
    /** a. If the [[Extensible]] internal property of O is false, return false. */
    if (O.Extensible = false) {
      return false
    }
    /** b. Else return the value of inherited.[[Writable]]. */
    else {
      return inherited.Writable
    }
  }
  /** Host objects may define additional constraints upon [[Put]] operations.
   *  If possible, host objects should not allow [[Put]] operations in situations where this definition of [[CanPut]] returns false. */
};

/**
 * 8.12.5 [[Put]] ( P, V, Throw )
 *
 * When the [[Put]] internal method of O is called with property P, value V, and Boolean flag Throw, the following steps are taken:
 */
function Put(O, P, V, Throw) [
  "8.12.5",
  "When the [[Put]] internal method of O is called with property P, value V, and Boolean flag Throw, the following steps are taken:",
  "",
  "[[Put]]"
] {
  print "Put";

  /** 1. If the result of calling the [[CanPut]] internal method of O with argument P is false, then */
  if ({O.CanPut}(O, P) = false) ["after-same:, then"] {
    /** a. If Throw is true, then throw a TypeError exception. */
    if (Throw = true) ["after-same:then"] {
      throw TypeErrorConstructorInternal()
    }
    /** b. Else return. */
    else {
      return
    }
  };
  /** 2. Let ownDesc be the result of calling the [[GetOwnProperty]] internal method of O with argument P. */
  ownDesc := {O.GetOwnProperty}(O, P);

  /** 3. If IsDataDescriptor(ownDesc) is true, then */
  if (IsDataPropertyDescriptor(ownDesc) = true) ["after-same:, then"] {
    /** a. Let valueDesc be the Property Descriptor {[[Value]]: V}. */
    valueDesc := PropertyDescriptor({
      Value: V
    });
    /** b. Call the [[DefineOwnProperty]] internal method of O passing P, valueDesc, and Throw as arguments. */
    {O.DefineOwnProperty}(O, P, valueDesc, Throw);

    /** c. Return. */
    return
  };

  /** 4. Let desc be the result of calling the [[GetProperty]] internal method of O with argument P.
   *     This may be either an own or inherited accessor property descriptor or an inherited data property descriptor. */
  gen_wrapper ["after-same:. This may be either an own or inherited <a href=\"#accessor-property-descriptor\">accessor property descriptor</a> or an inherited <a href=\"#data-property-descriptor\">data property descriptor</a>."] {
    desc := {O.GetProperty}(O, P)
  };

  /** 5. If IsAccessorDescriptor(desc) is true, then */
  if (IsAccessorPropertyDescriptor(desc) = true) ["after-same:, then"] {
    /** a. Let setter be desc.[[Set]] which cannot be undefined. */
    gen_wrapper ["after-same: which cannot be undefined"] {
      setter := desc.Set
    };
    /** b. Call the [[Call]] internal method of setter providing O as the this value and providing V as the sole argument. */
    {setter.Call}(null, null, setter, O, [V])
  }
  /** 6. Else, create a named data property named P on object O as follows */
  else ["after-same:, create a named data property named <i>P</i> on object <i>O</i> as follows"] {
    /** a. Let newDesc be the Property Descriptor {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}. */
    newDesc := PropertyDescriptor({
      Value: V,
      Writable: true,
      Enumerable: true,
      Configurable: true
    });

    /** b. Call the [[DefineOwnProperty]] internal method of O passing P, newDesc, and Throw as arguments. */
    {O.DefineOwnProperty}(O, P, newDesc, Throw)
  };

  /** 7. Return. */
  return
};

/**
 * 8.12.6 [[HasProperty]] (P)
 *
 * When the [[HasProperty]] internal method of O is called with property name P, the following steps are taken:
 */
function HasProperty(O, P) [
  "8.12.6",
  "When the [[HasProperty]] internal method of <var>O</var> is called with property name <var>P</var>, the following steps are taken:",
  "",
  "[[HasProperty]]"
] {
  print "HasProperty";

  /** 1. Let desc be the result of calling the [[GetProperty]] internal method of O with property name P. */
  desc := {O.GetProperty}(O, P);

  /** 2. If desc is undefined, then return false. */
  if (desc = 'undefined) ["after-same:then"] {
    return false
  }
  /** 3. Else return true. */
  else {
    return true
  }
};

/**
 * 8.12.7 [[Delete]] (P, Throw)
 *
 * When the [[Delete]] internal method of O is called with property name P and the Boolean flag Throw, the following steps are taken:
 */
function Delete(O, P, Throw) [
  "8.12.7",
  "When the [[Delete]] internal method of <var>O</var> is called with property name <var>P</var> and the Boolean flag <var>Throw</var>, the following steps are taken:",
  "",
  "[[Delete]]"
] {
  print "Delete";

  /** 1. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with property name P. */
  desc := {O.GetOwnProperty}(O, P);

  /** 2. If desc is undefined, then return true. */
  if (desc = 'undefined) ["after-same:then"] {
    return true
  };

  /** 3. If desc.[[Configurable]] is true, then */
  if (desc.Configurable = true) ["after-same:, then"] {
    /** a. Remove the own property with name P from O. */
    delete (O.JSProperties)[P];

    /** b. Return true. */
    return true
  }
  /** 4. Else if Throw, then throw a TypeError exception. */
  else {
    if (Throw) ["after-same:then"] {
      throw TypeErrorConstructorInternal()
    }
  };

  /** 5. Return false. */
  return false
};

/**
 * 8.12.8 [[DefaultValue]] (hint)
 *
 * When the [[DefaultValue]] internal method of O is called with hint String, the following steps are taken:
 */
function DefaultValue (O, hint) [
  "8.12.8",
  "",
  "When the [[DefaultValue]] internal method of <var>O</var> is called with no hint, then it behaves as if the hint were Number, unless <var>O</var> is a Date object
  (see <a href=\"#sec-15.9.6\">15.9.6</a>), in which case it behaves as if the hint were String.</p><p>
  The above specification of [[DefaultValue]] for native objects can return only <a href=\"#primitive_value\">primitive value</a>s. If a host object implements its own
  [[DefaultValue]] internal method, it must ensure that its [[DefaultValue]] internal method can return only <a href=\"#primitive_value\">primitive value</a>s.",
  "[[DefaultValue]]"
] {
  print "DefaultValue";
  gen_wrapper ["print_ignore"] {
    if (hint = null) {
      if (getInternalProperty(O, "Class") = "Date") {
        hint := 'String
      } else {
        hint := 'Number
      }
    }
  };

  /** When the [[DefaultValue]] internal method of O is called with hint String, the following steps are taken: */
  if (hint = 'String) [
    "split-if:When the [[DefaultValue]] internal method of <i>O</i> is called with hint String, the following steps are taken:"
  ] {
    /** 1. Let toString be the result of calling the [[Get]] internal method of object O with argument "toString". */
    toString := {O.Get}(O, "toString");

    /** 2. If IsCallable(toString) is true then, */
    if (IsCallable(toString) = true) ["after-same: then,"] {
      /** a. Let str be the result of calling the [[Call]] internal method of toString, with O as the this value and an empty argument list. */
      str := {toString.Call}(null, null, toString, O, []);

      /** b. If str is a primitive value, return str. */
      if (IsPrimitiveValue(str)) {
        return str
      }
    };

    /** 3. Let valueOf be the result of calling the [[Get]] internal method of object O with argument "valueOf". */
    valueOf := {O.Get}(O, "valueOf");

    /** 4. If IsCallable(valueOf) is true then, */
    if (IsCallable(valueOf) = true) ["after-same: then,"] {
      /** a. Let val be the result of calling the [[Call]] internal method of valueOf, with O as the this value and an empty argument list. */
      val := {valueOf.Call}(null, null, valueOf, O, []);

      /** b. If val is a primitive value, return val. */
      if (IsPrimitiveValue(val)) {
        return val
      }
    };

    /** 5. Throw a TypeError exception. */
    throw TypeErrorConstructorInternal()
  };
  /** When the [[DefaultValue]] internal method of O is called with hint Number, the following steps are taken: */
  if (hint = 'Number) [
    "split-if:When the [[DefaultValue]] internal method of <i>O</i> is called with hint Number, the following steps are taken:"
  ] {
    /** 1. Let valueOf be the result of calling the [[Get]] internal method of object O with argument "valueOf". */
    valueOf := {O.Get}(O, "valueOf");

    /** 2. If IsCallable(valueOf) is true then, */
    if (IsCallable(valueOf) = true) ["after-same: then,"] {
      /** a. Let val be the result of calling the [[Call]] internal method of valueOf, with O as the this value and an empty argument list. */
      val := {valueOf.Call}(null, null, valueOf, O, []);

      /** b. If val is a primitive value, return val. */
      if (IsPrimitiveValue(val)) {
        return val
      }
    };

    /** 3. Let toString be the result of calling the [[Get]] internal method of object O with argument "toString". */
    toString := {O.Get}(O, "toString");

    /** 4. If IsCallable(toString) is true then, */
    if (IsCallable(toString) = true) ["after-same: then"] {
      /** a. Let str be the result of calling the [[Call]] internal method of toString, with O as the this value and an empty argument list. */
      str := {toString.Call}(null, null, toString, O, []);

      /** b. If str is a primitive value, return str. */
      if (IsPrimitiveValue(str)) {
        return str
      }
    };

    /** 5. Throw a TypeError exception. */
    throw TypeErrorConstructorInternal()
  }

/** When the [[DefaultValue]] internal method of O is called with no hint, then it behaves as if the hint were Number,
 * unless O is a Date object (see 15.9.6), in which case it behaves as if the hint were String.
 *
 * The above specification of [[DefaultValue]] for native objects can return only primitive values.
 * If a host object implements its own [[DefaultValue]] internal method,
 * it must ensure that its [[DefaultValue]] internal method can return only primitive values.
 */
};

/**
 * 8.12.9 [[DefineOwnProperty]] (P, Desc, Throw)
 *
 * In the following algorithm, the term "Reject" means "If Throw is true, then throw a TypeError exception, otherwise return false".
 * The algorithm contains steps that test various fields of the Property Descriptor Desc for specific values.
 * The fields that are tested in this manner need not actually exist in Desc.
 * If a field is absent then its value is considered to be false.
 *
 * When the [[DefineOwnProperty]] internal method of O is called with property name P, property descriptor Desc, and Boolean flag Throw, the following steps are taken:
 */
function DefineOwnProperty(O, P, Desc, Throw) [
  "8.12.9",
  "In the following algorithm, the term \"Reject\" means \"If <span class=\"nt\">Throw</span> is <b>true</b>, then throw a <b>TypeError</b> exception, otherwise return <b>false</b>\".
  The algorithm contains steps that test various fields of the <a href=\"#sec-8.10\">Property Descriptor</a> <span class=\"nt\">Desc</span> for specific values. The fields that are tested in this manner need not actually
  exist in <span class=\"nt\">Desc</span>. If a field is absent then its value is considered to be <b>false</b>.</p><p>
  When the [[DefineOwnProperty]] internal method of <var>O</var> is called with property name <var>P</var>, <a href=\"#sec-8.10\">property descriptor</a> <span class=\"nt\">Desc</span>, and Boolean flag <span class=\"nt\">Throw</span>, the following steps are taken:",
  "However, if <var>O</var> is an Array object, it has a more elaborate [[DefineOwnProperty]] internal method defined in <a href=\"#sec-15.4.5.1\">15.4.5.1</a>.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> Step 10.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is <b>true</b>. This even permits changing the [[Value]] of a
  property whose [[Writable]] attribute is <b>false</b>. This is allowed because a <b>true</b> [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to <b>true</b>,
  a new [[Value]] is set, and then [[Writable]] is set to <b>false</b>.</p></div>",
  "[[DefineOwnProperty]]"
] {
  print "DefineOwnProperty";

  /** 1. Let current be the result of calling the [[GetOwnProperty]] internal method of O with property name P. */
  current := {O.GetOwnProperty}(O, P);

  /** 2. Let extensible be the value of the [[Extensible]] internal property of O. */
  extensible := O.Extensible;

  /** 3. If current is undefined and extensible is false, then Reject. */
  if ((current = 'undefined) && (extensible = false)) ["after-same:then"] {
    @Reject(Throw)
  };

  /** 4. If current is undefined and extensible is true, then: */
  if ((current = 'undefined) && (extensible = true)) ["after-same:, then"] {
    /** a. If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then: */
    if (IsGenericPropertyDescriptor(Desc) || (IsDataPropertyDescriptor(Desc) = true)) ["after-same:, then"] {
      /** i. Create an own data property named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc.
       *     If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value. */
      createOwnDataProperty(O, P, Desc)
    }
    /** b. Else, Desc must be an accessor Property Descriptor so: */
    else ["after-same:, <i>Desc</i> must be an <a href=\"#accessor-property-descriptor\">accessor Property Descriptor</a> so"] {
      /** i. Create an own accessor property named P of object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc.
       *     If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value. */
      createOwnAccessorProperty(O, P, Desc)
    };

    /** c. Return true. */
    return true
  };

  /** 5. Return true, if every field in Desc is absent. */
  if (EveryFieldIsAbsent(Desc)) {
    return true
  };

  /** 6. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the
   *     same value as the corresponding field in current when compared using the SameValue algorithm (9.12). */
  if (everyFieldInDescAlsoOccursInCurrent(Desc, current)) {
    return true
  };

  /** 7. If the [[Configurable]] field of current is false then: */
  if (current.Configurable = false) ["after-same: then"] {
    /** a. Reject, if the [[Configurable]] field of Desc is true. */
    if (("Configurable" in_obj Desc) &&& (Desc.Configurable = true)) {
      @Reject(Throw)
    };
    /** b. Reject, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other. */
    if (("Enumerable" in_obj Desc) &&& !(current.Enumerable = Desc.Enumerable)) {
      if (!Desc.Enumerable = current.Enumerable) {
        @Reject(Throw)
      }
    }
  };

  /** 8. If IsGenericDescriptor(Desc) is true, then no further validation is required. */
  if (IsGenericPropertyDescriptor(Desc) = true) ["after-same:, then no further validation is required."] {
  }
  /** 9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then: */
  elif (!(IsDataPropertyDescriptor(current) = IsDataPropertyDescriptor(Desc))) ["after-same: have different results, then"] {
    /** a. Reject, if the [[Configurable]] field of current is false. */
    if (current.Configurable = false) {
      @Reject(Throw)
    };

    /** b. If IsDataDescriptor(current) is true, then: */
    if (IsDataPropertyDescriptor(current) = true) ["after-same:, then"] {
      /** i. Convert the property named P of object O from a data property to an accessor property.
      *     Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and
      *     set the rest of the property’s attributes to their default values. */
      convertDataPropertyDescToAccessorPropertyDesc(O, P)
    }
    /** c. Else, */
    else {
      /** i. Convert the property named P of object O from an accessor property to a data property.
      *     Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and
      *     set the rest of the property’s attributes to their default values. */
      convertAccessorPropertyDescToDataPropertyDesc(O, P)
    }
  }
  /** 10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then: */
  elif ((IsDataPropertyDescriptor(current) = true) && (IsDataPropertyDescriptor(Desc) = true)) ["after-same:, then"] {
    /** a. If the [[Configurable]] field of current is false, then: */
    if (current.Configurable = false) ["after-same:, then"] {
      /** i. Reject, if the[[Writable]] field of current is false and the [[Writable]] field of Desc is true. */
      if ((current.Writable = false) && (Desc.Writable = true)) {
        @Reject(Throw)
      };

      /** ii. If the [[Writable]] field of current is false, then: */
      if (current.Writable = false) ["after-same:then"] {
        /** 1. Reject, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false. */
        if (("Value" in_obj Desc) && (SameValue(Desc.Value, current.Value) = false)) {
          @Reject(Throw)
        }
      }
    }
    /** b. else, the [[Configurable]] field of current is true, so any change is acceptable. */
    else ["after-same:, the [[Configurable]] field of current is <b>true</b>, so any change is acceptable."] {
    }
  }
  /** 11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true so, */
  else ["after-same:, <a href=\"#sec-8.10.1\">IsAccessorDescriptor</a>(current) and <a href=\"#sec-8.10.1\">IsAccessorDescriptor</a>(Desc) are both <b>true</b> so,"] {
    /** a. If the [[Configurable]] field of current is false, then: */
    if (current.Configurable = false) ["after-same:, then"] {
      /** i. Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false. */
      if (("Set" in_obj Desc) && (SameValue(Desc.Set, current.Set) = false)) {
        @Reject(Throw)
      };
      /** ii. Reject, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false. */
      if (("Get" in_obj Desc) && (SameValue(Desc.Get, current.Get) = false)) {
        @Reject(Throw)
      }
    }
  };
  /** 12. For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field. */
  setCorrespondinglyNamedAttributes(O, P, Desc);

  /** 13. Return true. */
  return true

  /**
   * However, if O is an Array object, it has a more elaborate[[DefineOwnProperty]] internal method defined in 15.4.5.1.
   *
   * NOTE Step 10.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is true.
   * This even permits changing the [[Value]] of a property whose [[Writable]] attribute is false.
   * This is allowed because a true [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to true,
   * a new [[Value]] is set, and then[[Writable]] is set to false.
   *
   */
};

/**
 * 8.10.1 IsAccessorDescriptor ( Desc )
 *
 * When the abstract operation IsAccessorDescriptor is called with property descriptor Desc, the following steps are taken:
 */
function IsAccessorPropertyDescriptor (Desc) [
  "8.10.1",
  "When the abstract operation IsAccessorDescriptor is called with <a href=\"#sec-8.10\">property descriptor</a> <span class=\"nt\">Desc</span>, the following steps are taken:",
  "",
  "IsAccessorDescriptor"
] {
  /** 1. If Desc is undefined, then return false. */
  if (Desc = 'undefined) ["after-same:then"] {
    return false
  };

  /** 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, then return false. */
  if (!("Get" in_obj Desc) && !("Set" in_obj Desc)) ["after-same:then"] {
    return false
  };

  /** 3. Return true. */
  return true
};

/**
 * 8.10.2 IsDataDescriptor ( Desc )
 *
 * When the abstract operation IsDataDescriptor is called with property descriptor Desc, the following steps are taken:
 */
function IsDataPropertyDescriptor (Desc) [
  "8.10.2",
  "When the abstract operation IsDataDescriptor is called with <a href=\"#sec-8.10\">property descriptor</a> <span class=\"nt\">Desc</span>, the following steps are taken:",
  "",
  "IsDataDescriptor"
] {
  /** 1. If Desc is undefined, then return false. */
  if (Desc = 'undefined) ["after-same:then"] {
    return false
  };
  /** 2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, then return false. */
  if (!("Value" in_obj Desc) && !("Writable" in_obj Desc)) ["after-same:then"] {
    return false
  };

  /** 3. Return true. */
  return true
};

/**
 * 8.10.3 IsGenericDescriptor ( Desc )
 *
 * When the abstract operation IsGenericDescriptor is called with property descriptor Desc, the following steps are taken:
 */
function IsGenericPropertyDescriptor (Desc) [
  "8.10.3",
  "When the abstract operation IsGenericDescriptor is called with <a href=\"#sec-8.10\">property descriptor</a> <span class=\"nt\">Desc</span>, the following steps are taken:",
  "",
  "IsGenericDescriptor"
] {
  /** 1. If Desc is undefined, then return false. */
  if (Desc = 'undefined) ["after-same:then"] {
    return false
  };
  /** 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, then return true. */
  if ((IsAccessorPropertyDescriptor(Desc) = false) && (IsDataPropertyDescriptor(Desc) = false)) ["after-same:then"] {
    return true
  };

  /** 3. Return false. */
  return false
};

/**
 * 8.10.4 FromPropertyDescriptor ( Desc )
 *
 * When the abstract operation FromPropertyDescriptor is called with property descriptor Desc, the following steps are taken:
 *
 * The following algorithm assumes that Desc is a fully populated Property Descriptor, such as that returned from [[GetOwnProperty]] (see 8.12.1).
 */
function FromPropertyDescriptor (Desc) [
  "8.10.4",
  "When the abstract operation FromPropertyDescriptor is called with <a href=\"#sec-8.10\">property descriptor</a> <span class=\"nt\">Desc</span>, the following steps are taken:</p><p>
  The following algorithm assumes that Desc is a <a href=\"#fully-populated\">fully populated</a> <a href=\"#sec-8.10\">Property Descriptor</a>, such as that returned from [[GetOwnProperty]] (see <a href=\"#sec-8.12.1\">8.12.1</a>)."
] {
  /** 1. If Desc is undefined, then return undefined. */
  if (Desc = 'undefined) ["after-same:then"] {
    return 'undefined
  };

  /** 2. Let obj be the result of creating a new object as if by the expression new Object() where Object is the standard built-in constructor with that name. */
  obj := ObjectConstructor(|global|, 'null, false, [null]);

  /** 3. If IsDataDescriptor(Desc) is true, then: */
  if (IsDataPropertyDescriptor(Desc) = true) ["after-same:, then"] {
    /** a. Call the [[DefineOwnProperty]] internal method of obj with arguments "value",
     *  Property Descriptor {[[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
    {obj.DefineOwnProperty}(obj, "value", PropertyDescriptor({
      Value: Desc.Value,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false);
    /** b. Call the [[DefineOwnProperty]] internal method of obj with arguments "writable",
     *  Property Descriptor {[[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
    {obj.DefineOwnProperty}(obj, "writable", PropertyDescriptor({
      Value: Desc.Writable,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false)
  }
  /** 4. Else, IsAccessorDescriptor(Desc) must be true, so: */
  else ["after-same:, <a href=\"#sec-8.10.1\">IsAccessorDescriptor</a>(<i>Desc</i>) must be <b>true</b>, so"] {
    /** a. Call the [[DefineOwnProperty]] internal method of obj with arguments "get",
     *  Property Descriptor {[[Value]]: Desc.[[Get]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
    {obj.DefineOwnProperty}(obj, "get", PropertyDescriptor({
      Value: Desc.Get,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false);
    /** b. Call the [[DefineOwnProperty]] internal method of obj with arguments "set",
     *  Property Descriptor {[[Value]]: Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
    {obj.DefineOwnProperty}(obj, "set", PropertyDescriptor({
      Value: Desc.Set,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false)
  };

  /** 5. Call the [[DefineOwnProperty]] internal method of obj with arguments "enumerable",
   *  Property Descriptor {[[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
  {obj.DefineOwnProperty}(obj, "enumerable", PropertyDescriptor({
    Value: Desc.Enumerable,
    Writable: true,
    Enumerable: true,
    Configurable: true
  }), false);

  /** 6. Call the [[DefineOwnProperty]] internal method of obj with arguments "configurable",
   *    Property Descriptor {[[Value]]: Desc.[[Configurable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. */
  {obj.DefineOwnProperty}(obj, "configurable", PropertyDescriptor({
    Value: Desc.Configurable,
    Writable: true,
    Enumerable: true,
    Configurable: true
  }), false);

   /** 7. Return obj. */
   return obj
};

/**
 * 8.10.5 ToPropertyDescriptor ( Obj )
 *
 * When the abstract operation ToPropertyDescriptor is called with object Obj, the following steps are taken:
 */
function ToPropertyDescriptor (Obj) [
  "8.10.5",
  "When the abstract operation ToPropertyDescriptor is called with object Obj, the following steps are taken:"
] {
  /** 1. If Type(Obj) is not Object throw a TypeError exception. */
  if (!(Type(Obj) = "Object")) {
    throw TypeErrorConstructorInternal()
  };

  /** 2. Let desc be the result of creating a new Property Descriptor that initially has no fields. */
  desc := NewPropertyDescriptor();

  /** 3. If the result of calling the [[HasProperty]] internal method of Obj with argument "enumerable" is true, then: */
  if ({Obj.HasProperty}(Obj, "enumerable") = true) ["after-same:, then"] {
    /** a. Let enum be the result of calling the [[Get]] internal method of Obj with "enumerable". */
    enum := {Obj.Get}(Obj, "enumerable");
    /** b. Set the [[Enumerable]] field of desc to ToBoolean(enum). */
    desc.Enumerable := ToBoolean(enum)
  };

  /** 4. If the result of calling the [[HasProperty]] internal method of Obj with argument "configurable" is true, then: */
  if ({Obj.HasProperty}(Obj, "configurable") = true) ["after-same:, then"] {
    /** a. Let conf be the result of calling the [[Get]] internal method of Obj with argument "configurable". */
    conf := {Obj.Get}(Obj, "configurable");
    /** b. Set the [[Configurable]] field of desc to ToBoolean(conf). */
    desc.Configurable := ToBoolean(conf)
  };

  /** 5. If the result of calling the [[HasProperty]] internal method of Obj with argument "value" is true, then: */
  if ({Obj.HasProperty}(Obj, "value") = true) ["after-same:, then"] {
    /** a. Let value be the result of calling the [[Get]] internal method of Obj with argument “value”. */
    value := {Obj.Get}(Obj, "value");
    /** b. Set the [[Value]] field of desc to value. */
    desc.Value := value
  };

  /** 6. If the result of calling the [[HasProperty]] internal method of Obj with argument "writable" is true, then: */
  if ({Obj.HasProperty}(Obj, "writable") = true) ["after-same:, then"] {
    /** a. Let writable be the result of calling the [[Get]] internal method of Obj with argument "writable". */
    writable := {Obj.Get}(Obj, "writable");
    /** b. Set the [[Writable]] field of desc to ToBoolean(writable). */
    desc.Writable := ToBoolean(writable)
  };

  /** 7. If the result of calling the [[HasProperty]] internal method of Obj with argument "get" is true, then: */
  if ({Obj.HasProperty}(Obj, "get") = true) ["after-same:, then"] {
    /** a. Let getter be the result of calling the [[Get]] internal method of Obj with argument "get". */
    getter := {Obj.Get}(Obj, "get");
    /** b. If IsCallable(getter) is false and getter is not undefined, then throw a TypeError exception. */
    if ((IsCallable(getter) = false) &&& !(getter = 'undefined)) ["after-same:, then"] {
      throw TypeErrorConstructorInternal()
    };
    /** c. Set the [[Get]] field of desc to getter. */
    desc.Get := getter
  };

  /** 8. If the result of calling the [[HasProperty]] internal method of Obj with argument "set" is true, then: */
  if ({Obj.HasProperty}(Obj, "set") = true) ["after-same:, then"] {
    /** a. Let setter be the result of calling the [[Get]] internal method of Obj with argument "set". */
    setter := {Obj.Get}(Obj, "set");
    /** b. If IsCallable(setter) is false and setter is not undefined, then throw a TypeError exception. */
    if ((IsCallable(setter) = false) &&& !(setter = 'undefined)) ["after-same:, then"] {
      throw TypeErrorConstructorInternal()
    };
    /** c. Set the [[Set]] field of desc to setter. */
    desc.Set := setter
  };

  /** 9. If either desc.[[Get]] or desc.[[Set]] are present, then: */
  if (("Get" in_obj desc) ||| ("Set" in_obj desc)) ["after-same:, then"] {
    /** a. If either desc.[[Value]] or desc.[[Writable]] are present, then throw a TypeError exception. */
    if (("Value" in_obj desc) ||| ("Writable" in_obj desc)) {
      throw TypeErrorConstructorInternal()
    }
  };

  /** 10. Return desc. */
  return desc
};

function GetValue(V) [
  "8.7.1",
  ""
] {
  print "GetValue";
  /* 1. If Type(V) is not Reference, return V. */
  if (!(Type(V) = "Reference")) {
    return V
  };

  /* 2. Let base be the result of calling GetBase(V). */
  base := GetBase(V);

  /* 3. If IsUnresolvableReference(V), throw a ReferenceError exception. */
  if (IsUnresolvableReference(V)) {
    throw ReferenceErrorConstructorInternal()
  };

  /* 4. If IsPropertyReference(V), then */
  if (IsPropertyReference(V)) ["after-same:, then"] {
    /* a. If HasPrimitiveBase(V) is false, then let get be the [[Get]] internal method of base,
          otherwise let get be the special [[Get]] internal method defined below. */
    if (HasPrimitiveBase(V) = false) ["after-same:then"] {
      get := base["Get"]
    } else ["replace-with:otherwise"] {
      get := "Get_internal"
    };

    /* b. Return the result of calling the get internal method using base as its this value,
          and passing GetReferencedName(V) for the argument. */
    return {get}(base, GetReferencedName(V))
  }
  /* 5. Else, base must be an environment record. */
  else ["after-same:, <i>base</i> must be an <a href=\"#sec-10.2\">environment record</a>."] {
    /* a. Return the result of calling the GetBindingValue (see 10.2.1) concrete method of base
          passing GetReferencedName(V) and IsStrictReference(V) as arguments. */
    return GetBindingValue(base, GetReferencedName(V), IsStrictReference(V))
  }
};

function PutValue(V, W) [
  "8.7.2",
  ""
] {
  print "PutValue";
  /* 1. If Type(V) is not Reference, throw a ReferenceError exception. */
  if (!(Type(V) = "Reference")) {
    throw ReferenceErrorConstructorInternal()
  };

  /* 2. Let base be the result of calling GetBase(V). */
  base := GetBase(V);

  /* 3. If IsUnresolvableReference(V), then */
  if (IsUnresolvableReference(V)) ["after-same:, then"] {
    /* a. If IsStrictReference(V) is true, then */
    if (IsStrictReference(V) = true) ["after-same:then"] {
      /* i. Throw ReferenceError exception. */
      throw ReferenceErrorConstructorInternal()
    };

    /* b. Call the [[Put]] internal method of the global object, passing GetReferencedName(V) for the property name,
          W for the value, and false for the Throw flag. */
    Put(|global|, GetReferencedName(V), W, false)
  }
  /* 4. Else if IsPropertyReference(V), then */
  elif (IsPropertyReference(V)) ["after-same:, then"] {
    /* a. If HasPrimitiveBase(V) is false, then let put be the [[Put]] internal method of base,
          otherwise let put be the special [[Put]] internal method defined below. */
    if (HasPrimitiveBase(V) = false) ["after-same:then"] {
      put := base["Put"]
    } else ["replace-with:otherwise"] {
      put := "Put_internal"
    };

    /* b. Call the put internal method using base as its this value, and passing GetReferencedName(V) for the property name,
          W for the value, and IsStrictReference(V) for the Throw flag. */
    {put}(base, GetReferencedName(V), W, IsStrictReference(V))
  }
  /* 5. Else base must be a reference whose base is an environment record. So, */
  else ["after-same: <i>base</i> must be a reference whose base is an <a href=\"#sec-10.2\">environment record</a>. So,"] {
    /* a. Call the SetMutableBinding (10.2.1) concrete method of base, passing GetReferencedName(V), W, and IsStrictReference(V) as arguments. */
    SetMutableBinding(base, GetReferencedName(V), W, IsStrictReference(V))
  };

  /* 6. Return. */
  return
};

function Get_internal(base, P) [
  "8.7.1.1",
  "The following [[Get]] internal method is used by GetValue when <var>V</var> is a <a href=\"#IsPropertyReference\">property reference</a> with a primitive base value.
  It is called using <i>base</i> as its <b>this</b> value and with property <var>P</var> as its argument. The following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span>The object that may be created in step 1 is not accessible outside of the above method. An implementation
  might choose to avoid the actual creation of the object. The only situation where such an actual property access that uses
  this internal method can have visible effect is when it invokes an accessor function.</p></div>",
  null
] {
  /* The following [[Get]] internal method is used by GetValue when V is a property reference with a primitive base
     value. It is called using base as its this value and with property P as its argument. The following steps are
     taken: */

  /* 1. Let O be ToObject(base). */
  O := ToObject(base);
  /* 2. Let desc be the result of calling the [[GetProperty]] internal method of O with property name P. */
  desc := {O.GetProperty}(O, P);
  /* 3. If desc is undefined, return undefined. */
  if (desc = 'undefined) {
    return 'undefined
  };
  /* 4. If IsDataDescriptor(desc) is true, return desc.[[Value]]. */
  if (IsDataPropertyDescriptor(desc) = true) {
    return desc.Value
  };
  /* 5. Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be desc.[[Get]] (see 8.10). */
  gen_wrapper ["before-same:Otherwise, <a href=\"#sec-8.10.1\">IsAccessorDescriptor</a>(desc) must be true so, "] {
    getter := desc.Get
  };
  /* 6. If getter is undefined, return undefined. */
  if (getter = 'undefined) {
    return 'undefined
  };
  /* 7. Return the result calling the [[Call]] internal method of getter providing base as the this value and providing
        no arguments. */
  return {getter.Call}(null, null, getter, base, [])

  /* NOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation
          might choose to avoid the actual creation of the object. The only situation where such an actual property access that uses
          this internal method can have visible effect is when it invokes an accessor function. */

};

function Put_internal(base, P, W, Throw) [
  "8.7.2.1",
  "The following [[Put]] internal method is used by PutValue when <var>V</var> is a <a href=\"#IsPropertyReference\">property reference</a> with a primitive base value.
  It is called using <i>base</i> as its <b>this</b> value and with property <var>P</var>, value <i>W</i>, and Boolean flag <span class=\"nt\">Throw</span> as arguments. The following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span>The object that may be created in step 1 is not accessible outside of the above method. An implementation
  might choose to avoid the actual creation of that transient object. The only situations where such an actual property
  assignment that uses this internal method can have visible effect are when it either invokes an accessor function or is in
  violation of a <span class=\"nt\">Throw</span> predicated error check. When <span class=\"nt\">Throw</span> is <b>true</b> any property assignment that would create a new property
  on the transient object throws an error.</p></div>",
  null
] {
  /* The following [[Put]] internal method is used by PutValue when V is a property reference with a primitive base
     value. It is called using base as its this value and with property P, value W, and Boolean flag Throw as
     arguments. The following steps are taken: */

  /* 1. Let O be ToObject(base). */
  O := ToObject(base);
  /* 2. If the result of calling the [[CanPut]] internal method of O with argument P is false, then */
  if ({O.CanPut}(O, P) = false) ["after-same:, then"] {
    /* a. If Throw is true, then throw a TypeError exception. */
    if (Throw = true) { throw TypeErrorConstructorInternal() }
    /* b. Else return. */
    else { return }
  };
  /* 3. Let ownDesc be the result of calling the [[GetOwnProperty]] internal method of O with argument P. */
  ownDesc := {O.GetOwnProperty}(O, P);
  /* 4. If IsDataDescriptor(ownDesc) is true, then */
  if (IsDataPropertyDescriptor(ownDesc) = true) ["after-same:, then"] {
    /* a. If Throw is true, then throw a TypeError exception. */
    if (Throw = true) { throw TypeErrorConstructorInternal() }
    /* b. Else return. */
    else { return }
  };
  /* 5. Let desc be the result of calling the [[GetProperty]] internal method of O with argument P. This may be
        either an own or inherited accessor property descriptor or an inherited data property descriptor. */
  gen_wrapper ["after-same:. This may be either an own or inherited <a href=\"#accessor-property-descriptor\">accessor property descriptor</a> or an inherited <a href=\"#data-property-descriptor\">data property descriptor</a>"] {
    desc := {O.GetProperty}(O, P)
  };
  /* 6. If IsAccessorDescriptor(desc) is true, then */
  if (IsAccessorPropertyDescriptor(desc) = true) ["after-same:, then"] {
    /* a. Let setter be desc.[[Set]] which cannot be undefined. */
    gen_wrapper ["after-same: which cannot be <b>undefined</b>"] {
      setter := desc.Set
    };
    /* b. Call the [[Call]] internal method of setter providing base as the this value and an argument list
          containing only W. */
    {setter.Call}(null, null, setter, base, [W])
  }
  /* 7. Else, this is a request to create an own property on the transient object O */
    /* a. If Throw is true, then throw a TypeError exception. */
  else ["after-same:, this is a request to create an own property on the transient object <i>O</i>"] {
    if (Throw = true) {
      throw TypeErrorConstructorInternal()
    }
  };
  /* 8. Return. */
  return

  /* NOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation
          might choose to avoid the actual creation of that transient object. The only situations where such an actual property
          assignment that uses this internal method can have visible effect are when it either invokes an accessor function or is in
          violation of a Throw predicated error check. When Throw is true any property assignment that would create a new property
          on the transient object throws an error. */
};

function ToPrimitive(input, PreferredType) [
  "9.1",
  "The abstract operation ToPrimitive takes an <i>input</i> argument and an optional argument <i>PreferredType</i>. The abstract operation ToPrimitive converts its <i>input</i> argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint <i>PreferredType</i> to favour that type. Conversion occurs according to Table 10:"
] {
  switch (Type(input)) [
    "Table 10 — ToPrimitive Conversions"
  ] {
    case "Undefined": { return input }
    case "Null": { return input }
    case "Boolean": { return input }
    case "Number": { return input }
    case "String": { return input }
    case "Object": { return DefaultValue(input, PreferredType) }
  }
};

/* 9.2 ToBoolean */
function ToBoolean(argument) [
  "9.2",
  "The abstract operation ToBoolean converts its argument to a value of type Boolean according to Table 11:"
] {
  switch (Type(argument)) [
    "Table 11 — ToBoolean Conversions"
  ] {
    case "Undefined": { return false }
    case "Null": { return false }
    case "Boolean": { return argument }
    case "Number": {
      if ((argument = 0.) || (argument = -(0.)) || (argument = NaN)) {
        return false
      } else {
        return true
      }
    }
    case "String": {
      if (argument = "") {
        return false
      } else {
        return true
      }
    }
    case "Object": { return true }
  }
};

/* 9.3 ToNumber */
function ToNumber(argument) [
  "9.3",
  "The abstract operation ToNumber converts its argument to a value of type Number according to Table 12:"
] {
  switch (Type(argument)) [
    "Table 12 — To Number Conversions"
  ] {
    case "Undefined": { return NaN }
    case "Null": { return 0. }
    case "Boolean": {
      if (argument = true) {
        return 1.
      };
      if (argument = false) {
        return 0.
      }
    }
    case "Number": { return argument }
    case "String": { return float_of_string argument }
    case "Object": {
      /* Apply the following steps: */

      /* 1. Let primValue be ToPrimitive(input argument, hint Number). */
      primValue := ToPrimitive(argument, 'Number);
      /* 2. Return ToNumber(primValue). */
      return ToNumber(primValue)
    }
  }
};

/* 9.4 ToInteger */
function ToInteger(argument) {
  /* The abstract operation ToInteger converts its argument to an integral numeric value. This abstract operation
     functions as follows: */

  /* Let number be the result of calling ToNumber on the input argument. */
  number := ToNumber(argument);
  /* If number is NaN, return +0. */
  /* If number is +0, -0, +Infinity, or -Infinity, return number. */
  /* Return the result of computing sign(number) x floor(abs(number)). */
  return to_int(number)
};

/* 9.5 ToInt32: (Signed 32 Bit Integer) */
function ToInt32(argument) {
  /* The abstract operation ToInt32 converts its argument to one of 2^32 integer values in the range -2^31 through
    2^31 - 1, inclusive. This abstract operation functions as follows: */

  /* 1. Let number be the result of calling ToNumber on the input argument. */
  number := ToNumber(argument);
  /* 2. If number is NaN, +0, -0, +Infinity, or -Infinity, return +0. */
  return to_int32(number)
  /* 3. Let posInt be sign(number) * floor(abs(number)). */
  /* 4. Let int32bit be posInt modulo 2^32 ; that is, a finite integer value k of Number type with positive sign and less
        than 2^32 in magnitude such that the mathematical difference of posInt and k is mathematically an integer
        multiple of 2^32 . */
  /* 5. If int32bit is greater than or equal to 2^31 , return int32bit - 2^32 , otherwise return int32bit. */

  /* NOTE Given the above definition of ToInt32:
          * The ToInt32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that
            value unchanged.
          * ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of x. (It is to preserve this latter property that +Infinity and -Infinity are
            mapped to +0.)
          * ToInt32 maps -0 to +0. */
};

/* 9.6 ToUint32: (Unsigned 32 Bit Integer) */
function ToUint32(argument) {
  /* The abstract operation ToUint32 converts its argument to one of 2^32 integer values in the range 0 through 2^32 - 1,
     inclusive. This abstraction operation functions as follows: */

  /* 1. Let number be the result of calling ToNumber on the input argument. */
  number := ToNumber(argument);
  /* 2. If number is NaN, +0, -0, +Infinity, or -Infinity, return +0. */
  return to_uint32(number)
  /* 3. Let posInt be sign(number) x floor(abs(number)). */
  /* 4. Let int32bit be posInt modulo 2^32 ; that is, a finite integer value k of Number type with positive sign and less
        than 2^32 in magnitude such that the mathematical difference of posInt and k is mathematically an integer
        multiple of 2^32 . */
  /* 5. Return int32bit. */

  /* NOTE Given the above definition of ToUint32:
          * Step 5 is the only difference between ToUint32 and ToInt32.
          * The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second
            application leaves that value unchanged.
          * ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of x. (It is to preserve this latter property
            that +Infinity and -Infinity are mapped to +0.)
          * ToUint32 maps -0 to +0. */
};

/* 9.7 ToUint16: (Unsigned 16 Bit Integer) */
function ToUint16(argument) {
  /* The abstract operation ToUint16 converts its argument to one of 2^16 integer values in the range 0 through 2^16 - 1,
     inclusive. This abstract operation functions as follows: */

  /* 1. Let number be the result of calling ToNumber on the input argument. */
  number := ToNumber(argument);
  /* 2. If number is NaN, +0, -0, +Infinity, or -Infinity, return +0. */
  /* 3. Let posInt be sign(number) x floor(abs(number)). */
  /* 4. Let int16bit be posInt modulo 2 16 ; that is, a finite integer value k of Number type with positive sign and less
        than 2 16 in magnitude such that the mathematical difference of posInt and k is mathematically an integer
        multiple of 2^16 . */
  /* 5. Return int16bit. */
  return to_uint16(number)

  /* NOTE Given the above definition of ToUint16:
     * The substitution of 2 16 for 2 32 in step 4 is the only difference between ToUint32 and ToUint16.
     * ToUint16 maps -0 to +0 */
};

/* 9.8 ToString */
function ToString(argument) [
  "9.8",
  "The abstract operation ToString converts its argument to a value of type String according to Table 13:"
] {
  switch(Type(argument)) [
    "Table 13 — ToString Conversions"
  ] {
    case "Undefined": { return "undefined" }
    case "Null": { return "null" }
    case "Boolean": {
      if (argument = true) {
        return "true"
      };
      if (argument = false) {
        return "false"
      }
    }
    case "Number": { return float_to_string argument }
    case "String": { return argument }
    case "Object": {
      /* Apply the following steps: */
      /* 1. Let primValue be ToPrimitive(input argument, hint String). */
      primValue := ToPrimitive(argument, 'String);
      /* 2. Return ToString(primValue). */
      return ToString(primValue)
    }
  }
};

/* 9.9 ToObject */
/* The abstract operation ToObject converts its argument to a value of type Object according to Table 14: */
function ToObject(argument) [
  "9.9",
  "The abstract operation ToObject converts its argument to a value of type Object according to Table 14:"
] {
  switch(Type(argument)) [
    "Table 14 — ToObject"
  ] {
    case "Undefined": { throw TypeErrorConstructorInternal() }
    case "Null": { throw TypeErrorConstructorInternal() }
    case "Boolean": { return BooleanConstructor(|global|, true, false, [argument]) }
    case "Number": { return NumberConstructor(|global|, true, false, [argument]) }
    case "String": { return StringConstructor(|global|, true, false, [argument]) }
    case "Object": { return argument }
  }
};

/* 9.10 CheckObjectCoercible */
/* The abstract operation CheckObjectCoercible throws an error if its argument is a value that cannot be
   converted to an Object using ToObject. It is defined by Table 15: */
function CheckObjectCoercible(V) [
  "9.10",
  "The abstract operation CheckObjectCoercible throws an error if its argument is a value that cannot be
  converted to an Object using <a href=\"#sec-9.9\">ToObject</a>. It is defined by Table 15:"
] {
  switch (Type(argument)) [
    "Table 15 — CheckObjectCoercible Results"
  ] {
    case "Undefined": { throw TypeErrorConstructorInternal() }
    case "Null": { throw TypeErrorConstructorInternal() }
    case "Boolean": { return }
    case "Number": { return }
    case "String": { return }
    case "Object": { return }
  }
};

/* 9.11 IsCallable */
/* The abstract operation IsCallable determines if its argument, which must be an ECMAScript language value,
   is a callable function Object according to Table 16: */
  function IsCallable(V) [
  "9.11",
  "The abstract operation IsCallable determines if its argument, which must be an ECMAScript language value,
  is a callable function Object according to Table 16:"
] {
  switch (Type(argument)) [
    "Table 16 — IsCallable Results"
  ] {
    case "Undefined": { return false }
    case "Null": { return false }
    case "Boolean": { return false }
    case "Number": { return false }
    case "String": { return false }
    case "Object": {
      if ("Call" in_obj argument) {
        return true
      } else {
        return false
      }
    }
  }
};

/* 9.12 The SameValue Algorithm
  The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false.
  Such a comparison is performed as follows: */
function SameValue (x, y) [
  "9.12",
  "The internal comparison abstract operation SameValue(<i>x</i>, <i>y</i>), where <i>x</i> and <i>y</i> are ECMAScript language values,
  produces <b>true</b> or <b>false</b>. Such a comparison is performed as follows:",
  "",
  "The SameValue Algorithm"
] {
  /* 1. If Type(x) is different from Type(y), return false. */
  if (!(Type(x) = Type(y))) { return false };
  /* 2. If Type(x) is Undefined, return true. */
  if (Type(x) = "Undefined") { return true };
  /* 3. If Type(x) is Null, return true. */
  if (Type(x) = "Null") { return true };
  /* 4. If Type(x) is Number, then. */
  if (Type(x) = "Number") ["after-same:, then."] {
    /* a. If x is NaN and y is NaN, return true. */
    if ((x = NaN) && (y = NaN)) { return true };
    /* b. If x is +0 and y is -0, return false. */
    if (isZero(x) && isMinusZero(y)) { return false };
    /* c. If x is -0 and y is +0, return false. */
    if (isMinusZero(x) && isZero(y)) { return false };
    /* d. If x is the same Number value as y, return true. */
    if (sameNumber(x, y)) { return true };
    /* e. Return false. */
    return false
  };
  /* 5. If Type(x) is String, then return true if x and y are exactly the same sequence of characters
    (same length and same characters in corresponding positions); otherwise, return false. */
  if (Type(x) = "String") {
    if (sameSequenceOfCharacters(x, y)) {
      return true
    };
    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  };
  /* 6. If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false. */
  if (Type(x) = "Boolean") {
    if ((x = true && y = true) || (x = false && y = false)) {
      return true
    };
    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  };
  /* 7. Return true if x and y refer to the same object. Otherwise, return false. */
  if (sameObject(x, y)) {
    return true
  };
  gen_wrapper ["before-same:Otherwise, "] {
    return false
  }
};

/* 10.2.1.1.1 HasBinding(N) */
/* The concrete environment record method HasBinding for declarative environment records simply determines
    if the argument identifier is one of the identifiers bound by the record: */
function HasBindingDeclarativeEnvRecord(declarativeEnvRec, N) [
  "10.2.1.1.1",
  "The concrete environment record method HasBinding for declarative environment records simply determines
  if the argument identifier is one of the identifiers bound by the record:",
  "",
  "HasBinding"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. If envRec has a binding for the name that is the value of N, return true. */
  if (N in_obj envRec) {
    return true
  };
  gen_wrapper ["before-same:If it does not have such a binding, "] {
    /* 3. If it does not have such a binding, return false. */
    return false
  }
};

/* 10.2.1.1.2 CreateMutableBinding (N, D) */
/* The concrete Environment Record method CreateMutableBinding for declarative environment records creates
    a new mutable binding for the name N that is initialised to the value undefined. A binding must not already
    exist in this Environment Record for N. If Boolean argument D is provided and has the value true the new
    binding is marked as being subject to deletion. */
function CreateMutableBindingDeclarative(declarativeEnvRec, N, D) [
  "10.2.1.1.2",
  "The concrete Environment Record method CreateMutableBinding for declarative environment records creates
  a new mutable binding for the name <var>N</var> that is initialised to the value <b>undefined</b>. A binding must not already
  exist in this Environment Record for <var>N</var>. If Boolean argument <i>D</i> is provided and has the value <b>true</b> the new
  binding is marked as being subject to deletion.",
  "",
  "CreateMutableBinding"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. Assert: envRec does not already have a binding for N. */
  assert !(N in_obj envRec);
  /* 3. Create a mutable binding in envRec for N and set its bound value to undefined. If D is true record that
        the newly created binding may be deleted by a subsequent DeleteBinding call. */
  createMutableBinding(envRec, N, 'undefined);
  if (D = true) {
    setBindingDeletable(envRec, N, true)
  };

  return
};

/* 10.2.1.1.3 SetMutableBinding (N,V,S) */
/* The concrete Environment Record method SetMutableBinding for declarative environment records attempts to
    change the bound value of the current binding of the identifier whose name is the value of the argument N to
    the value of argument V. A binding for N must already exist. If the binding is an immutable binding, a
    TypeError is thrown if S is true. */
function SetMutableBindingDeclarative(declarativeEnvRec, N, V, S) [
  "10.2.1.1.3",
  "The concrete Environment Record method SetMutableBinding for declarative environment records attempts to
  change the bound value of the current binding of the identifier whose name is the value of the argument N to
  the value of argument V. A binding for N must already exist. If the binding is an immutable binding, a
  TypeError is thrown if S is true.",
  "",
  "SetMutableBinding"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. Assert: envRec must have a binding for N. */
  assert (N in_obj envRec);
  /* 3. If the binding for N in envRec is a mutable binding, change its bound value to V. */
  if (isMutableBinding(envRec, N)) {
    setBindingValue(envRec, N, V)
  } else ["after-same: this must be an attempt to change the value of an <a href=\"#immutable-binding\">immutable binding</a> so "] {
  /* 4. Else this must be an attempt to change the value of an immutable binding so if S if true throw a TypeError exception. */
    if (S = true) {
      throw TypeErrorConstructorInternal()
    }
  };

  return
};

/* 10.2.1.1.4 GetBindingValue(N,S) */
/* The concrete Environment Record method GetBindingValue for declarative environment records simply
    returns the value of its bound identifier whose name is the value of the argument N. The binding must already
    exist. If S is true and the binding is an uninitialised immutable binding throw a ReferenceError exception. */
function GetBindingValueDeclarative(declarativeEnvRec, N, S) [
  "10.2.1.1.4",
  "The concrete Environment Record method GetBindingValue for declarative environment records simply returns the value of its bound identifier
  whose name is the value of the argument <var>N</var>. The binding must already exist. If <var>S</var> is <b>true</b> and the binding is an
  uninitialized <a href=\"#immutable-binding\">immutable binding</a> throw a <b>ReferenceError</b> exception.",
  "",
  "GetBindingValue"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. Assert: envRec has a binding for N. */
  assert (N in_obj envRec);
  /* 3. If the binding for N in envRec is an uninitialised immutable binding, then */
  if (isUninitialisedBinding(envRec, N)) ["after-same:, then"] {
    /* a. If S is false, return the value undefined, otherwise throw a ReferenceError exception. */
    if (S = false) {
      return 'undefined
    };
    gen_wrapper ["before-same:Otherwise "] {
      throw ReferenceErrorConstructorInternal()
    }
  }
  /* 4. Else, return the value currently bound to N in envRec. */
  else {
    return getBindingValue(envRec, N)
  }
};

/* 10.2.1.1.5 DeleteBinding (N) */
/* The concrete Environment Record method DeleteBinding for declarative environment records can only delete
    bindings that have been explicitly designated as being subject to deletion. */
function DeleteBindingDeclarative(declarativeEnvRec, N) [
  "10.2.1.1.5",
  "The concrete Environment Record method DeleteBinding for declarative environment records can only delete
  bindings that have been explicitly designated as being subject to deletion.",
  "",
  "DeleteBinding"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. If envRec does not have a binding for the name that is the value of N, return true. */
  if (!(N in_obj envRec)) {
    return true
  };
  /* 3. If the binding for N in envRec is cannot be deleted, return false. */
  if (isBindingCannotBeDeleted(envRec, N)) {
    return false
  };
  /* 4. Remove the binding for N from envRec. */
  delete envRec[N];
  /* 5. Return true. */
  return true
};

/* 10.2.1.1.6 ImplicitThisValue() */
/* Declarative Environment Records always return undefined as their ImplicitThisValue. */
function ImplicitThisValueDeclarative(declarativeEnvRec) [
  "10.2.1.1.6",
  "Declarative Environment Records always return <b>undefined</b> as their ImplicitThisValue.",
  "",
  "ImplicitThisValue"
] {
  /* 1. Return undefined. */
  return 'undefined
};

/* 10.2.1.1.7 CreateImmutableBinding (N) */
/* The concrete Environment Record method CreateImmutableBinding for declarative environment records
  creates a new immutable binding for the name N that is initialised to the value undefined.
  A binding must not already exist in this environment record for N. */
function CreateImmutableBindingDeclarative(declarativeEnvRec, N) [
  "10.2.1.1.7",
  "The concrete Environment Record method CreateImmutableBinding for declarative environment records
  creates a new <a href=\"#immutable-binding\">immutable binding</a> for the name <var>N</var> that is initialised to the
  value <b>undefined</b>. A binding must not already exist in this environment record for <var>N</var>.",
  "",
  "CreateImmutableBinding"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. Assert: envRec does not already have a binding for N. */
  assert !(N in_obj envRec);
  /* 3. Create an immutable binding in envRec for N and record that it is uninitialised. */
  createImmutableBinding(envRec, N);
  setBindingInitialised(envRec, N, false);

  return
};

/* 10.2.1.1.8 InitializeImmutableBinding (N,V) */
/* The concrete Environment Record method InitializeImmutableBinding for declarative environment records is
  used to set the bound value of the current binding of the identifier whose name is the value of the argument N
  to the value of argument V. An uninitialised immutable binding for N must already exist. */
function InitializeImmutableBindingDeclarative(declarativeEnvRec, N, V) [
  "10.2.1.1.8",
  "The concrete Environment Record method InitializeImmutableBinding for declarative environment records is
  used to set the bound value of the current binding of the identifier whose name is the value of the argument <var>N</var>
  to the value of argument <var>V</var>. An uninitialised <a href=\"#immutable-binding\">immutable binding</a> for <var>N</var> must already exist.",
  "",
  "InitializeImmutableBinding"
] [
  "declarativeEnvRec:the declarative environment record for which the method was invoked"
] {
  /* 1. Let envRec be the declarative environment record for which the method was invoked. */
  envRec := declarativeEnvRec;
  /* 2. Assert: envRec must have an uninitialised immutable binding for N. */
  assert (hasUninitialisedImmutableBinding(envRec, N));
  /* 3. Set the bound value for N in envRec to V. */
  setBindingValue(envRec, N, V);
  /* 4. Record that the immutable binding for N in envRec has been initialised. */
  setBindingInitialised(envRec, N, true);

  return
};

/* 10.2.1.2.1 HasBinding(N) */
/* The concrete Environment Record method HasBinding for object environment records determines if its
    associated binding object has a property whose name is the value of the argument N: */
function HasBindingObjectEnvRecord(objectEnvRec, N) [
  "10.2.1.2.1",
  "The concrete Environment Record method HasBinding for object environment records determines if its
  associated <a href=\"x10.2.1.2\">binding object</a> has a property whose name is the value of the argument <var>N</var>:",
  "",
  "HasBinding"
] [
  "objectEnvRec:the object environment record for which the method was invoked"
] {
  /* 1. Let envRec be the object environment record for which the method was invoked. */
  envRec := objectEnvRec;
  /* 2. Let bindings be the binding object for envRec. */
  bindings := getBindingObject(envRec);
  /* 3. Return the result of calling the [[HasProperty]] internal method of bindings, passing N as the property name. */
  return {bindings.HasProperty}(bindings, N)
};

/* 10.2.1.2.2 CreateMutableBinding (N, D) */
/* The concrete Environment Record method CreateMutableBinding for object environment records creates in
    an environment record‘s associated binding object a property whose name is the String value and initialises it
    to the value undefined. A property named N must not already exist in the binding object. If Boolean argument
    D is provided and has the value true the new property‘s [[Configurable]] attribute is set to true,
    otherwise it is set to false. */
function CreateMutableBindingObject(objectEnvRec, N, D) [
  "10.2.1.2.2",
  "The concrete Environment Record method CreateMutableBinding for object environment records creates in
  an environment record‘s associated <a href=\"x10.2.1.2\">binding object</a> a property whose name is the String value and initialises it
  to the value <b>undefined</b>. A property named <var>N</var> must not already exist in the <a href=\"x10.2.1.2\">binding object</a>.
  If Boolean argument <i>D</i> is provided and has the value <b>true</b> the new property‘s [[Configurable]] attribute is set to <b>true</b>,
  otherwise it is set to <b>false</b>.",
  "",
  "CreateMutableBinding"
] [
  "objectEnvRec:the object environment record for which the method was invoked"
] {
  /* 1. Let envRec be the object environment record for which the method was invoked. */
  envRec := objectEnvRec;
  /* 2. Let bindings be the binding object for envRec. */
  bindings := getBindingObject(envRec);
  /* 3. Assert: The result of calling the [[HasProperty]] internal method of bindings,
        passing N as the property name, is false. */
  assert ({bindings.HasProperty}(bindings, N) = false);
  /* 4. If D is true then let configValue be true otherwise let configValue be false. */
  if (D = true) ["after-same:then "] {
    configValue := true
  } else ["replace-with:otherwise"] {
    configValue := false
  };
  /* 5. Call the [[DefineOwnProperty]] internal method of bindings, passing N, Property Descriptor
        {[[Value]]:undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configValue},
        and true as arguments. */
  {bindings.DefineOwnProperty}(bindings, N, PropertyDescriptor({
    Value: 'undefined,
    Writable: true,
    Enumerable: true,
    Configurable: configValue
  }), true);

  return
};

/* 10.2.1.2.3 SetMutableBinding (N,V,S) */
/* The concrete Environment Record method SetMutableBinding for object environment records attempts to set
    the value of the environment record‘s associated binding object‘s property whose name is the value of the
    argument N to the value of argument V. A property named N should already exist but if it does not or is not
    currently writable, error handling is determined by the value of the Boolean argument S. */
function SetMutableBindingObject(objectEnvRec, N, V, S) [
  "10.2.1.2.3",
  "The concrete Environment Record method SetMutableBinding for object environment records attempts to set
  the value of the environment record‘s associated <a href=\"x10.2.1.2\">binding object</a>‘s property whose name is the value of the
  argument <var>N</var> to the value of argument <var>V</var>. A property named <var>N</var> should already exist but if it does not or is not
  currently writable, error handling is determined by the value of the Boolean argument <var>S</var>.",
  "",
  "SetMutableBinding"
] [
  "objectEnvRec:the object environment record for which the method was invoked"
] {
  /* 1. Let envRec be the object environment record for which the method was invoked. */
  envRec := objectEnvRec;
  /* 2. Let bindings be the binding object for envRec. */
  bindings := getBindingObject(envRec);
  /* 3. Call the [[Put]] internal method of bindings with arguments N, V, and S. */
  {bindings.Put}(bindings, N, V, S);

  return
};

/* 10.2.1.2.4 GetBindingValue(N,S) */
/* The concrete Environment Record method GetBindingValue for object environment records returns the value
    of its associated binding object‘s property whose name is the String value of the argument identifier N.
    The property should already exist but if it does not the result depends upon the value of the S argument: */
function GetBindingValueObject(objectEnvRec, N, S) [
  "10.2.1.2.4",
  "The concrete Environment Record method GetBindingValue for object environment records returns the value
  of its associated <a href=\"x10.2.1.2\">binding object</a>‘s property whose name is the String value of the argument identifier <var>N</var>.
  The property should already exist but if it does not the result depends upon the value of the <var>S</var> argument:",
  "",
  "GetBindingValue"
] [
  "objectEnvRec:the object environment record for which the method was invoked"
] {
  /* 1. Let envRec be the object environment record for which the method was invoked. */
  envRec := objectEnvRec;
  /* 2. Let bindings be the binding object for envRec. */
  bindings := getBindingObject(envRec);
  /* 3. Let value be the result of calling the [[HasProperty]] internal method of bindings, passing N as the property name. */
  value := {bindings.HasProperty}(bindings, N);
  /* 4. If value is false, then */
  if (value = false) ["after-same:, then"] {
    /* a. If S is false, return the value undefined, otherwise throw a ReferenceError exception. */
    if (S = false) {
      return 'undefined
    };
    gen_wrapper ["before-same:Otherwise "] {
      throw ReferenceErrorConstructorInternal()
    }
  };
  /* 5. Return the result of calling the [[Get]] internal method of bindings, passing N for the argument. */
  return {bindings.Get}(bindings, N)
};

/* 10.2.1.2.5 DeleteBinding (N) */
/* The concrete Environment Record method DeleteBinding for object environment records can only delete
    bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the
    value true. */
function DeleteBindingObject(objectEnvRec, N) [
  "10.2.1.2.5",
  "The concrete Environment Record method DeleteBinding for object environment records can only delete
  bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the
  value <b>true</b>.",
  "",
  "DeleteBinding"
] [
  "objectEnvRec:the object environment record for which the method was invoked"
] {
  /* 1. Let envRec be the object environment record for which the method was invoked. */
  envRec := objectEnvRec;
  /* 2. Let bindings be the binding object for envRec. */
  bindings := getBindingObject(envRec);
  /* 3. Return the result of calling the [[Delete]] internal method of bindings, passing N and false as arguments. */
  return {bindings.Delete}(bindings, N, false)
};

/* 10.2.1.2.6 ImplicitThisValue() */
/* Object Environment Records return undefined as their ImplicitThisValue unless their provideThis flag is true. */
function ImplicitThisValueObject(objectEnvRec) [
  "10.2.1.2.6",
  "Object Environment Records return undefined as their ImplicitThisValue unless their provideThis flag is true.",
  "",
  "ImplicitThisValue"
] [
  "objectEnvRec:the object environment record for which the method was invoked"
] {
  /* 1. Let envRec be the object environment record for which the method was invoked. */
  envRec := objectEnvRec;
  /* 2. If the provideThis flag of envRec is true, return the binding object for envRec. */
  if (getProvideThis(envRec) = true) {
    return getBindingObject(envRec)
  };
  /* 3. Otherwise, return undefined. */
  gen_wrapper ["before-same:Otherwise, "] {
    return 'undefined
  }
};

/* 10.2.2.1 GetIdentifierReference (lex, name, strict) */
/* The abstract operation GetIdentifierReference is called with a Lexical Environment lex, an identifier String
    name, and a Boolean flag strict. The value of lex may be null. When called, the following steps are performed: */
function GetIdentifierReference(lex, name, strict) [
  "10.2.2.1",
  "The abstract operation GetIdentifierReference is called with a <a href=\"#sec-10.2\">Lexical Environment</a> <var>lex</var>, an identifier String
  <var>name</var>, and a Boolean flag <var>strict</var>. The value of <var>lex</var> may be <b>null</b>. When called, the following steps are performed:"
] {
  print "GetIdentifierReference";
  /* 1. If lex is the value null, then */
  if (lex = 'null) ["after-same:then"] {
    /* a. Return a value of type Reference whose base value is undefined, whose referenced name is name,
          and whose strict mode flag is strict. */
    return newValueReference('undefined, name, strict)
  };
  /* 2. Let envRec be lex‘s environment record. */
  envRec := getEnvironmentRecord(lex);
  /* 3. Let exists be the result of calling the HasBinding(N) concrete method of envRec passing name as the argument N. */
  exists := HasBinding(envRec, name);
  /* 4. If exists is true, then */
  if (exists = true) ["after-same:then"] {
    /* a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict mode flag is strict. */
    return newValueReference(envRec, name, strict)
  }
  /* 5. Else */
  else {
    /* a. Let outer be the value of lex’s outer environment reference. */
    outer := getOuterEnvironmentReference(lex);
    /* b. Return the result of calling GetIdentifierReference passing outer, name, and strict as arguments. */
    return GetIdentifierReference(outer, name, strict)
  }
};

/* 10.2.2.2 NewDeclarativeEnvironment (E) */
/* When the abstract operation NewDeclarativeEnvironment is called with either a Lexical Environment or null
    as argument E the following steps are performed: */
function NewDeclarativeEnvironment(E) [
  "10.2.2.2",
  "When the abstract operation NewDeclarativeEnvironment is called with either a <a href=\"#sec-10.2\">Lexical Environment</a>
  or <b>null</b> as argument <i>E</i> the following steps are performed:"
] {
  /* 1. Let env be a new Lexical Environment. */
  env := newLexicalEnvironment();
  /* 2. Let envRec be a new declarative environment record containing no bindings. */
  envRec := newDeclarativeEnvironmentRecord();
  /* 3. Set env’s environment record to be envRec. */
  setEnvironmentRecord(env, envRec);
  /* 4. Set the outer lexical environment reference of env to E. */
  setOuterLexicalEnvironmentReference(env, E);
  /* 5. Return env. */
  return env
};

/* 10.2.2.3 NewObjectEnvironment (O, E) */
/* When the abstract operation NewObjectEnvironment is called with an Object O and a Lexical Environment E (or null)
    as arguments, the following steps are performed: */
function NewObjectEnvironment(O, E) [
  "10.2.2.3",
  "When the abstract operation NewObjectEnvironment is called with an Object <var>O</var> and a <a href=\"#sec-10.2\">Lexical Environment</a> <i>E</i>
  (or <b>null</b>) as arguments, the following steps are performed:"
] {
  /* 1. Let env be a new Lexical Environment. */
  env := newLexicalEnvironment();
  /* 2. Let envRec be a new object environment record containing O as the binding object. */
  envRec := newObjectEnvironmentRecord(O);
  /* 3. Set env’s environment record to be envRec. */
  setEnvironmentRecord(env, envRec);
  /* 4. Set the outer lexical environment reference of env to E. */
  setOuterLexicalEnvironmentReference(env, E);
  /* 5. Return env. */
  return env
};

/* 10.4.1 Entering Global Code */
/* The following steps are performed when control enters the execution context for global code: */
function EnteringGlobalCode(program) [
  "10.4.1",
  "The following steps are performed when control enters the execution context for <a href=\"#global-code\">global code</a>:",
  "",
  "Entering Global Code"
] [
  "program:<a href=\"#global-code\">global code</a>"
] {
  gen_wrapper ["print_ignore"] {
    /* globalObject := initGlobalObject(program.strict); */
    globalObject := optimizeInitGlobalObject(program.strict)
  };

  /* 1. Initialise the execution context using the global code as described in 10.4.1.1. */
  globalScope := InitialGlobalExecutionContext(globalObject, program);

  /* 2. Perform Declaration Binding Instantiation as described in 10.5 using the global code. */
  DeclarationBindingInstantiation(program, [], globalScope, null);

  gen_wrapper ["print_ignore"] {
    return globalScope
  }
};

/* 10.4.1.1 Initial Global Execution Context */
/* The following steps are performed to initialise a global execution context for ECMAScript code C: */
function InitialGlobalExecutionContext(globalObject, program) [
  "10.4.1.1",
  "The following steps are performed to initialise a global execution context for ECMAScript code <i>C</i>:",
  "",
  "Initial Global Execution Context"
] [
  "globalEnv:<a href=\"#sec-10.2.3\">Global Environment</a>"
] {
  gen_wrapper ["print_ignore"] {
    globalExecCtx := createExecutionContext();

    globalEnv := GlobalEnvironment(globalObject)
  };

  /* 1. Set the VariableEnvironment to the Global Environment. */
  setVariableEnvironment(globalExecCtx, globalEnv);
  /* 2. Set the LexicalEnvironment to the Global Environment. */
  setLexicalEnvironment(globalExecCtx, globalEnv);
  /* 3. Set the ThisBinding to the global object. */
  setThisBinding(globalExecCtx, |global|);

  gen_wrapper ["print_ignore"] {
    setContainedInStrictCode(globalExecCtx, isStrictModeCode(program, globalExecCtx));

    return globalExecCtx
  }
};

/* 10.4.2 Entering Eval Code */
/* The following steps are performed when control enters the execution context for eval code: */
function EnteringEvalCode(evalCode, ref, callingExecCtx) [
  "10.4.2",
  "The following steps are performed when control enters the execution context for <a href=\"#eval-code\">eval code</a>:",
  "",
  "Entering Eval Code"
] [
  "evalCode:<a href=\"#eval-code\">eval code</a>"
] {
  gen_wrapper ["print_ignore"] {
    evalCode.strict := isStrictModeCode(evalCode, callingExecCtx)
  };

  /* 1. If there is no calling context or if the eval code is not being evaluated by a direct call (15.1.2.1.1) to the eval
        function then, */
  if (!isDirectCall(ref, callingExecCtx)) ["after-same: then,"] {
    /* a. Initialise the execution context as if it was a global execution context using the eval code as C as
          described in 10.4.1.1. */
    evalExecCtx := InitialGlobalExecutionContext(|global|, evalCode)
  /* 2. Else, */
  } else {
    gen_wrapper ["print_ignore"] {
      evalExecCtx := createExecutionContext()
    };
    /* a. Set the ThisBinding to the same value as the ThisBinding of the calling execution context. */
    setThisBinding(evalExecCtx, getThisBinding(callingExecCtx));
    /* b. Set the LexicalEnvironment to the same value as the LexicalEnvironment of the calling execution
          context. */
    setLexicalEnvironment(evalExecCtx, getLexicalEnvironment(callingExecCtx));
    /* c. Set the VariableEnvironment to the same value as the VariableEnvironment of the calling execution
          context. */
    setVariableEnvironment(evalExecCtx, getVariableEnvironment(callingExecCtx));

    gen_wrapper ["print_ignore"] {
      setContainedInStrictCode(evalExecCtx, isStrict)
    }
  };
  /* 3. If the eval code is strict code, then */
  if (isStrictModeCode(evalCode, callingExecCtx)) ["after-same:, then"] {
    /* a. Let strictVarEnv be the result of calling NewDeclarativeEnvironment passing the
          LexicalEnvironment as the argument. */
    strictVarEnv := NewDeclarativeEnvironment(getLexicalEnvironment(evalExecCtx));
    /* b. Set the LexicalEnvironment to strictVarEnv. */
    setLexicalEnvironment(evalExecCtx, strictVarEnv);
    /* c. Set the VariableEnvironment to strictVarEnv. */
    setVariableEnvironment(evalExecCtx, strictVarEnv)
  };
  /* 4. Perform Declaration Binding Instantiation as described in 10.5 using the eval code. */
  DeclarationBindingInstantiation(evalCode, [], evalExecCtx, null);

  gen_wrapper ["print_ignore"] {
    return evalExecCtx
  }
};

/* 10.4.3 Entering Function Code */
/* The following steps are performed when control enters the execution context for function code contained in function object F,
   a caller provided thisArg, and a caller provided argumentsList: */
function EnteringFunctionCode(F, thisArg, argumentsList) [
  "10.4.3",
  "The following steps are performed when control enters the execution context for <a href=\"#function-code\">function code</a>
  contained in function object <var>F</var>, a caller provided <i>thisArg</i>, and a caller provided <i>argumentsList</i>:",
  "",
  "Entering Function Code"
] {
  gen_wrapper ["print_ignore"] {
    functionExecCtx := createExecutionContext();
    setContainedInStrictCode(functionExecCtx, isStrictFunctionObject(F))
  };

  /* 1. If the function code is strict code, set the ThisBinding to thisArg. */
  if (isStrictModeCode(getFunctionCode(F), functionExecCtx)) {
    setThisBinding(functionExecCtx, thisArg)
  }
  /* 2. Else if thisArg is null or undefined, set the ThisBinding to the global object. */
  elif ((thisArg = 'null) || (thisArg = 'undefined)) {
    setThisBinding(functionExecCtx, |global|)
  }
  /* 3. Else if Type(thisArg) is not Object, set the ThisBinding to ToObject(thisArg). */
  elif (!(Type(thisArg) = "Object")) {
    setThisBinding(functionExecCtx, ToObject(thisArg))
  }
  /* 4. Else set the ThisBinding to thisArg. */
  else {
    setThisBinding(functionExecCtx, thisArg)
  };
  /* 5. Let localEnv be the result of calling NewDeclarativeEnvironment passing the value of the [[Scope]] internal
        property of F as the argument. */
  localEnv := NewDeclarativeEnvironment(F.Scope);
  /* 6. Set the LexicalEnvironment to localEnv. */
  setLexicalEnvironment(functionExecCtx, localEnv);
  /* 7. Set the VariableEnvironment to localEnv. */
  setVariableEnvironment(functionExecCtx, localEnv);
  /* 8. Let code be the value of F‘s [[Code]] internal property. */
  code := F.Code;
  /* 9. Perform Declaration Binding Instantiation using the function code code and argumentsList as described in 10.5. */
  DeclarationBindingInstantiation(code, argumentsList, functionExecCtx, F);

  gen_wrapper ["print_ignore"] {
    return functionExecCtx
  }
};


/* 10.5 Declaration Binding Instantiation */

/* Every execution context has an associated VariableEnvironment. Variables and functions declared in
   ECMAScript code evaluated in an execution context are added as bindings in that VariableEnvironment‘s
   Environment Record. For function code, parameters are also added as bindings to that Environment Record. */

/* Which Environment Record is used to bind a declaration and its kind depends upon the type of ECMAScript
   code executed by the execution context, but the remainder of the behaviour is generic. On entering an
   execution context, bindings are created in the VariableEnvironment as follows using the caller provided code
   and, if it is function code, argument List args: */

function DeclarationBindingInstantiation(code, args, runningExecCtx, F) [
  "10.5",
  "Every execution context has an associated VariableEnvironment. Variables and functions declared in
   ECMAScript code evaluated in an execution context are added as bindings in that VariableEnvironment‘s <a href=\"#sec-10.2.1\">Environment Record</a>.
   For <a href=\"#function-code\">function code</a>, parameters are also added as bindings to that  <a href=\"#sec-10.2.1\">Environment Record</a>.</p>
   <p>Which <a href=\"#sec-10.2.1\">Environment Record</a> is used to bind a declaration and its kind depends upon the type of ECMAScript
   code executed by the execution context, but the remainder of the behaviour is generic. On entering an
   execution context, bindings are created in the VariableEnvironment as follows using the caller provided <var>code</var>
   and, if it is <a href=\"#function-code\">function code</a>, argument <a href=\"#sec-8.8\">List</a> <var>args</var>:",
   "",
   "Declaration Binding Instantiation"
] [
  "F:the function whose [[Call]] internal method initiated execution of <i>code</i>"
] {
  /* 1. Let env be the environment record component of the running execution context‘s VariableEnvironment. */
  env := getEnvRecOfRunningExecCtx(runningExecCtx);
  /* 2. If code is eval code, then let configurableBindings be true else let configurableBindings be false. */
  if (isEvalCode(code)) {
    configurableBindings := true
  } else {
    configurableBindings := false
  };
  /* 3. If code is strict mode code, then let strict be true else let strict be false. */
  if (isStrictModeCode(code, runningExecCtx)) {
    strict := true
  } else {
    strict := false
  };
  /* 4. If code is function code, then */
  if (isFunctionCode(code)) ["after-same:, then"] {
    /* a. Let func be the function whose [[Call]] internal method initiated execution of code. Let names be
          the value of func‘s [[FormalParameters]] internal property. */
    func := F;
    names := func.FormalParameters;
    /* b. Let argCount be the number of elements in args. */
    argCount := l_len args;
    /* c. Let n be the number 0. */
    n := 0;
    /* d. For each String argName in names, in list order do */
    foreach (argName : names) ["after-same:, in list order do"] {
      /* i. Let n be the current value of n plus 1. */
      n := n + 1;
      /* ii. If n is greater than argCount, let v be undefined otherwise let v be the value of the n‘th
             element of args. */
      if (n > argCount) {
        v := 'undefined
      } else ["replace-with:otherwise"] {
        v := l_nth(args, n - 1)
      };
      /* iii. Let argAlreadyDeclared be the result of calling env’s HasBinding concrete method passing
              argName as the argument. */
      argAlreadyDeclared := HasBinding(env, argName);
      /* iv. If argAlreadyDeclared is false, call env’s CreateMutableBinding concrete method passing
             argName as the argument. */
      if (argAlreadyDeclared = false) {
        CreateMutableBinding(env, argName, false) /* TODO the third argument is optional as in the method signature */
      };
      /* v. Call env’s SetMutableBinding concrete method passing argName, v, and strict as the
            arguments. */
      SetMutableBinding(env, argName, v, strict)
    }
  };
  /* 5. For each FunctionDeclaration f in code, in source text order do */
  foreach (f : getFunctionDeclarationsInCode(code)) ["after-same:, in source text order do"] ["f:<i><a href=\"#sec-13\">FunctionDeclaration</a></i>"] {
    /* a. Let fn be the Identifier in FunctionDeclaration f. */
    fn := getIdentifierFunctionDeclaration(f);
    /* b. Let fo be the result of instantiating FunctionDeclaration f as described in Clause 13. */
    fo := JS_Interpreter_FunctionDeclaration(f, runningExecCtx);
    /* c. Let funcAlreadyDeclared be the result of calling env’s HasBinding concrete method passing fn as
          the argument. */
    funcAlreadyDeclared := HasBinding(env, fn);
    /* d. If funcAlreadyDeclared is false, call env’s CreateMutableBinding concrete method passing fn and
          configurableBindings as the arguments. */
    if (funcAlreadyDeclared = false) {
      CreateMutableBinding(env, fn, configurableBindings)
    }
    /* e. Else if env is the environment record component of the global environment then */
    elif (env = |global|) ["after-same: then"] {
      /* i. Let go be the global object. */
      go := |global|;
      /* ii. Let existingProp be the resulting of calling the [[GetProperty]] internal method of go with
            argument fn. */
      existingProp := {go.GetProperty}(go, fn);
      /* iii. If existingProp.[[Configurable]] is true, then */
      if (existingProp.Configurable = true) ["after-same:, then"] {
        /* 1. Call the [[DefineOwnProperty]] internal method of go, passing fn, Property
              Descriptor {[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true ,
              [[Configurable]]: configurableBindings }, and true as arguments. */
        {go.DefineOwnProperty}(go, fn, PropertyDescriptor({
          Value: 'undefined,
          Writable: true,
          Enumerable: true,
          Configurable: configurableBindings
        }), true)
      } else {
        /* iv. Else if IsAccessorPropertyDescriptor(existingProp) or existingProp does not have attribute values
                {[[Writable]]: true, [[Enumerable]]: true}, then */
        if (IsAccessorPropertyDescriptor(existingProp) || !(existingProp.Writable = true) || !(existingProp.Enumerable = true)) ["after-same:then"] {
          /* 1. Throw a TypeError exception. */
          throw TypeErrorConstructorInternal()
        }
      }
    };
    /* f. Call env’s SetMutableBinding concrete method passing fn, fo, and strict as the arguments. */
    SetMutableBinding(env, fn, fo, strict)
  };
  /* 6. Let argumentsAlreadyDeclared be the result of calling env’s HasBinding concrete method passing
      "arguments" as the argument. */
  argumentsAlreadyDeclared := HasBinding(env, "arguments");
  /* 7. If code is function code and argumentsAlreadyDeclared is false, then */
  if (isFunctionCode(code) && (argumentsAlreadyDeclared = false)) ["after-same:, then"] {
    /* a. Let argsObj be the result of calling the abstract operation CreateArgumentsObject (10.6) passing
          func, names, args, env and strict as arguments. */
    argsObj := CreateArgumentsObject(func, names, args, env, strict, getVariableEnvironment(runningExecCtx));
    /* b. If strict is true, then */
    if (strict = true) ["after-same:, then"] {
      /* i. Call env‘s CreateImmutableBinding concrete method passing the String "arguments" as
            the argument. */
      CreateImmutableBinding(env, "arguments");
      /* ii. Call env‘s InitializeImmutableBinding concrete method passing "arguments" and
             argsObj as arguments. */
      InitializeImmutableBinding(env, "arguments", argsObj)
    }
    /* c. Else, */
    else {
      /* i. Call env‘s CreateMutableBinding concrete method passing the String "arguments" as the argument. */
      CreateMutableBinding(env, "arguments", false); /* TODO the third argument is optional as in the method signature */
      /* ii. Call env‘s SetMutableBinding concrete method passing "arguments", argsObj, and false
             as arguments. */
      SetMutableBinding(env, "arguments", argsObj, false)
    }
  };
  /* 8. For each VariableDeclaration and VariableDeclarationNoIn d in code, in source text order do */
  foreach (d : getVariableDeclarationsInCode(code)) ["after-same:, in source text order do"] ["d:<i>VariableDeclaration</i> and <i>VariableDeclarationNoIn</i>"] {
    /* a. Let dn be the Identifier in d. */
    dn := getIdentifierVariableDeclaration(d);
    /* b. Let varAlreadyDeclared be the result of calling env’s HasBinding concrete method passing dn as the
          argument. */
    varAlreadyDeclared := HasBinding(env, dn);
    /* c. If varAlreadyDeclared is false, then */
    if (varAlreadyDeclared = false) ["after-same:, then"] {
      /* i. Call env‘s CreateMutableBinding concrete method passing dn and configurableBindings as
            the arguments. */
      CreateMutableBinding(env, dn, configurableBindings);
      /* ii. Call env‘s SetMutableBinding concrete method passing dn, undefined, and strict as the
             arguments.*/
      SetMutableBinding(env, dn, 'undefined, strict)
    }
  };

  return
};

/* 10.6 Arguments Object */

/* When control enters an execution context for function code, an arguments object is created unless (as
   specified in 10.5) the identifier arguments occurs as an Identifier in the function‘s FormalParameterList or
   occurs as the Identifier of a VariableDeclaration or FunctionDeclaration contained in the function code. */
/* The arguments object is created by calling the abstract operation CreateArgumentsObject with arguments func
   the function object whose code is to be evaluated, names a List containing the function‘s formal parameter
   names, args the actual arguments passed to the [[Call]] internal method, env the variable environment for the
   function code, and strict a Boolean that indicates whether or not the function code is strict code. When
   CreateArgumentsObject is called the following steps are performed: */
function CreateArgumentsObject(func, names, args, env, lexicalEnvironment, strict) [
  "10.6",
  "When control enters an execution context for <a href=\"#function-code\">function code</a>, an arguments object is created unless (as
  specified in <a href=\"#sec-10.5\">10.5</a>) the identifier <code><b>arguments</b></code> occurs as an <span class=\"nt\">Identifier</span> in the function‘s
  <span class=\"nt\">FormalParameterList</span> or occurs as the <span class=\"nt\">Identifier</span> of a <span class=\"nt\">VariableDeclaration</span> or
  <span class=\"nt\"><a href=\"#sec-13\">FunctionDeclaration</a></span> contained in the <a href=\"#function-code\">function code</a>.</p>
  <p>The arguments object is created by calling the abstract operation CreateArgumentsObject with arguments <var>func</var>
  the function object whose code is to be evaluated, <var>names</var> a <a href=\"#sec-8.8\">List</a> containing the function‘s formal parameter
  names, <var>args</var> the actual arguments passed to the [[Call]] internal method, <var>env</var> the variable environment for the
  <a href=\"#function-code\">function code</a>, and <var>strict</var> a Boolean that indicates whether or not the <a href=\"#function-code\">function code</a>
  is <a href=\"#sec-10.1.1\">strict code</a>. When CreateArgumentsObject is called the following steps are performed:",
  "",
  "Arguments Object"
] [
  "ObjectConstructor:the standard built-in Object constructor (<a href=\"#sec-15.2.2\">15.2.2</a>)"
] {
  /* 1. Let len be the number of elements in args. */
  len := l_len args;
  /* 2. Let obj be the result of creating a new ECMAScript object. */
  obj := NewECMAScriptObject();
  /* 3. Set all the internal methods of obj as specified in 8.12. */
  setAllInternalMethodsOfObject(obj);
  /* 4. Set the [[Class]] internal property of obj to "Arguments". */
  setInternalProperty(obj, "Class", "Arguments");
  /* 5. Let Object be the standard built-in Object constructor (15.2.2). */
  Object := ObjectConstructor;
  /* 6. Set the [[Prototype]] internal property of obj to the standard built-in Object prototype object (15.2.4). */
  setInternalProperty(obj, "Prototype", getObjectPrototype(strict));
  /* 7. Call the [[DefineOwnProperty]] internal method on obj passing "length", the Property Descriptor
        {[[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}, and false as arguments. */
  {obj.DefineOwnProperty}(obj, "length", PropertyDescriptor({
    Value: int_to_float len,
    Writable: true,
    Enumerable: false,
    Configurable: true
  }), false);
  /* 8. Let map be the result of creating a new object as if by the expression new Object() where Object is
        the standard built-in constructor with that name */
  map := ObjectConstructor(|global|, 'null, strict, [null]);
  /* 9. Let mappedNames be an empty List. */
  mappedNames := [];
  /* 10. Let indx = len - 1. */
  indx := len - 1;
  /* 11. Repeat while indx >= 0, */
  while (indx >= 0) {
    /* a. Let val be the element of args at 0-origined list position indx. */
    val := l_nth(args, indx);
    /* b. Call the [[DefineOwnProperty]] internal method on obj passing ToString(indx), the property
          descriptor {[[Value]]: val, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and
          false as arguments. */
    {obj.DefineOwnProperty}(obj, ToString(int_to_float indx), PropertyDescriptor({
      Value: val,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false);
    /* c. If indx is less than the number of elements in names, then */
    if (indx < l_len names) ["after-same:, then"] {
      /* i. Let name be the element of names at 0-origined list position indx. */
      name := l_nth(names, indx);
      /* ii. If strict is false and name is not an element of mappedNames, then */
      if ((strict = false) && !(name in_list mappedNames)) ["after-same:, then"] {
        /* 1. Add name as an element of the list mappedNames. */
        mappedNames := l_add(mappedNames, name);
        /* 2. Let g be the result of calling the MakeArgGetter abstract operation with arguments
              name and env. */
        g := MakeArgGetter(name, lexicalEnvironment);
        /* 3. Let p be the result of calling the MakeArgSetter abstract operation with arguments
              name and env. */
        p := MakeArgSetter(name, lexicalEnvironment);
        /* 4. Call the [[DefineOwnProperty]] internal method of map passing ToString(indx), the
              Property Descriptor {[[Set]]: p, [[Get]]: g, [[Configurable]]: true}, and false as
              arguments. */
        {map.DefineOwnProperty}(map, ToString(int_to_float indx), PropertyDescriptor({
          Set: p,
          Get: g,
          Configurable: true
        }), false)
      }
    };
    /* d. Let indx = indx - 1 */
    indx := indx - 1
  };
  /* 12. If mappedNames is not empty, then */
  if (l_len mappedNames > 0) ["after-same:, then"] {
    /* a. Set the [[ParameterMap]] internal property of obj to map. */
    setInternalProperty(obj, "ParameterMap", map);
    /* b. Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]] internal methods of obj
          to the definitions provided below. */
    setInternalProperty(obj, "Get", "ArgumentsObjectGet");
    setInternalProperty(obj, "GetOwnProperty", "ArgumentsObjectGetOwnProperty");
    setInternalProperty(obj, "DefineOwnProperty", "ArgumentsObjectDefineOwnProperty");
    setInternalProperty(obj, "Delete", "ArgumentsObjectDelete")
  };
  /* 13. If strict is false, then */
  if (strict = false) ["after-same:, then"] {
    /* a. Call the [[DefineOwnProperty]] internal method on obj passing "callee", the property descriptor
          {[[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}, and false as
          arguments. */
    {obj.DefineOwnProperty}(obj, "callee", PropertyDescriptor({
      Value: func,
      Writable: true,
      Enumerable: false,
      Configurable: true
    }), false)
  }
  /* 14. Else, strict is true so */
  else ["after-same:, strict is <b>true</b> so"] {
    /* a. Let thrower be the [[ThrowTypeError]] function Object (13.2.3). */
    thrower := createThrowTypeErrorFunctionObject(getFunctionPrototype(strict), strict);
    /* b. Call the [[DefineOwnProperty]] internal method of obj with arguments "caller",
          PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]:
          false}, and false. */
    {obj.DefineOwnProperty}(obj, "caller", PropertyDescriptor({
      Get: thrower,
      Set: thrower,
      Enumerable: false,
      Configurable: false
    }), false);
    /* c. Call the [[DefineOwnProperty]] internal method of obj with arguments "callee",
          PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]:
          false}, and false. */
    {obj.DefineOwnProperty}(obj, "callee", PropertyDescriptor({
      Get: thrower,
      Set: thrower,
      Enumerable: false,
      Configurable: false
    }), false)
  };
  /* 15. Return obj */
  return obj
};

/* The abstract operation MakeArgGetter called with String name and environment record env creates a function
  object that when executed returns the value bound for name in env. It performs the following steps: */
function MakeArgGetter(name, lexicalEnvironment) [
  "10.6.1",
  "The abstract operation <i>MakeArgGetter</i> called with String <var>name</var> and <a href=\"#sec-10.2\">environment record</a> <var>env</var>
  creates a function object that when executed returns the value bound for <var>name</var> in <var>env</var>. It performs the following steps:",
  "",
  null
] {
  /* 1. Let body be the result of concatenating the Strings "return ", name, and ";". */
  body := makeArgGetterLetBodyAuxFunction(name);
  /* 2. Return the result of creating a function object as described in 13.2 using no FormalParameterList, body for
        FunctionBody, env as Scope, and true for Strict. */
  return CreateFunctionObject([], body, lexicalEnvironment, true, null)
};

/* The abstract operation MakeArgSetter called with String name and environment record env creates a function
  object that when executed sets the value bound for name in env. It performs the following steps: */
function MakeArgSetter(name, lexicalEnvironment) [
  "10.6.2",
  "The abstract operation <i>MakeArgSetter</i> called with String <var>name</var> and <a href=\"#sec-10.2\">environment record</a> <var>env</var>
  creates a function object that when executed sets the value bound for <var>name</var> in <var>env</var>. It performs the following steps:",
  "",
  null
] {
  /* 1. Let param be the String name concatenated with the String "_arg". */
  param := makeArgSetterLetParamAuxFunction(name);
  /* 2. Let body be the String "<name> = <param>;" with <name> replaced by the value of name and <param>
        replaced by the value of param. */
  body := makeArgSetterLetBodyAuxFunction(name, param);
  /* 3. Return the result of creating a function object as described in 13.2 using a List containing the single String
        param as FormalParameterList, body for FunctionBody, env as Scope, and true for Strict. */
  return CreateFunctionObject(["param"], body, lexicalEnvironment, true, null)
};

/* The [[Get]] internal method of an arguments object for a non-strict mode function with formal parameters when
  called with a property name P performs the following steps: */
function ArgumentsObjectGet(argumentsObject, P) [
  "10.6.3",
  "The [[Get]] internal method of an arguments object for a non-strict mode function with formal parameters when
  called with a property name <var>P</var> performs the following steps:",
  "",
  null
] [
  "argumentsObject:arguments object"
] {
  /* 1. Let map be the value of the [[ParameterMap]] internal property of the arguments object. */
  map := argumentsObject.ParameterMap;
  /* 2. Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the
        argument. */
  isMapped := {map.GetOwnProperty}(map, P);
  /* 3. If the value of isMapped is undefined, then */
  if (isMapped = 'undefined) ["after-same:, then"] {
    /* a. Let v be the result of calling the default [[Get]] internal method (8.12.3) on the arguments object
          passing P as the argument. */
    v := Get(argumentsObject, P);
    /* b. If P is "caller" and v is a strict mode Function object, throw a TypeError exception. */
    if ((P = "caller") &&& isStrictFunctionObject(v)) {
      throw TypeErrorConstructorInternal()
    };
    /* c. Return v. */
    return v
  }
  /* 4. Else, map contains a formal parameter mapping for P so, */
  else ["after-same:, <i>map</i> contains a formal parameter mapping for <i>P</i> so,"] {
    /* a. Return the result of calling the [[Get]] internal method of map passing P as the argument. */
    return {map.Get}(map, P)
  }
};

/* The [[GetOwnProperty]] internal method of an arguments object for a non-strict mode function with formal
  parameters when called with a property name P performs the following steps: */
function ArgumentsObjectGetOwnProperty(argumentsObject, P) [
  "10.6.4",
  "The [[GetOwnProperty]] internal method of an arguments object for a non-strict mode function with formal
  parameters when called with a property name <var>P</var> performs the following steps:",
  "",
  null
] [
  "argumentsObject:arguments object"
] {
  /* 1. Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on the arguments
        object passing P as the argument. */
  desc := GetOwnProperty(argumentsObject, P);
  /* 2. If desc is undefined then return desc. */
  if (desc = 'undefined) {
    return desc
  };
  /* 3. Let map be the value of the [[ParameterMap]] internal property of the arguments object. */
  map := argumentsObject.ParameterMap;
  /* 4. Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the
        argument. */
  isMapped := {map.GetOwnProperty}(map, P);
  /* 5. If the value of isMapped is not undefined, then */
  if (!(isMapped = 'undefined)) ["after-same: then"] {
    /* a. Set desc.[[Value]] to the result of calling the [[Get]] internal method of map passing P as the argument. */
    desc.Value := {map.Get}(map, P)
  };
  /* 6. Return desc. */
  return desc
};

/* The [[DefineOwnProperty]] internal method of an arguments object for a non-strict mode function with formal
  parameters when called with a property name P, Property Descriptor Desc, and Boolean flag Throw performs
  the following steps: */
function ArgumentsObjectDefineOwnProperty(argumentsObject, P, Desc, Throw) [
  "10.6.5",
  "The [[DefineOwnProperty]] internal method of an arguments object for a non-strict mode function with formal
  parameters when called with a property name <var>P</var>, <a href=\"#sec-8.10\">Property Descriptor</a> <span class=\"nt\">Desc</span>,
  and Boolean flag <span class=\"nt\">Throw</span> performs the following steps:",
  "",
  null
] [
  "argumentsObject:arguments object"
] {
  /* 1. Let map be the value of the [[ParameterMap]] internal property of the arguments object. */
  map := argumentsObject.ParameterMap;
  /* 2. Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the
        argument. */
  isMapped := {map.GetOwnProperty}(map, P);
  /* 3. Let allowed be the result of calling the default [[DefineOwnProperty]] internal method (8.12. 9) on the
        arguments object passing P, Desc, and false as the arguments. */
  allowed := DefineOwnProperty(argumentsObject, P, Desc, false);
  /* 4. If allowed is false, then */
  if (allowed = false) ["after-same:, then"] {
    /* a. If Throw is true then throw a TypeError exception, otherwise return false. */
    if (Throw = true) {
      throw TypeErrorConstructorInternal()
    } else ["replace-with:otherwise"] {
      return false
    }
  };
  /* 5. If the value of isMapped is not undefined, then */
  if (!(isMapped = 'undefined)) ["after-same:, then"] {
    /* a. If IsAccessorDescriptor(Desc) is true, then */
    if (IsAccessorPropertyDescriptor(Desc) = true) ["after-same:, then"] {
      /* i. Call the [[Delete]] internal method of map passing P, and false as the arguments. */
      {map.Delete}(map, P, false)
    }
    /* b. Else */
    else {
      /* i.If Desc.[[Value]] is present, then */
      if ("Value" in_obj Desc) ["after-same:, then"] {
        /* 1. Call the [[Put]] internal method of map passing P, Desc.[[Value]], and Throw as the arguments. */
        {map.Put}(map, P, Desc.Value, Throw)
      };
      /* ii. If Desc.[[Writable]] is present and its value is false, then */
      if (("Writable" in_obj Desc) && (Desc.Writable = false)) ["after-same:, then"] {
        /* 1. Call the [[Delete]] internal method of map passing P and false as arguments. */
        {map.Delete}(map, P, false)
      }
    }
  };
  /* 6. Return true. */
  return true
};

/* The [[Delete]] internal method of an arguments object for a non-strict mode function with formal parameters
  when called with a property name P and Boolean flag Throw performs the following steps: */
function ArgumentsObjectDelete(argumentsObject, P, Throw) [
  "10.6.6",
  "The [[Delete]] internal method of an arguments object for a non-strict mode function with formal parameters
  when called with a property name <var>P</var> and Boolean flag <span class=\"nt\">Throw</span> performs the following steps:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> For non-strict mode functions the array index (defined in <a href=\"#sec-15.4\">15.4</a>) named data properties of an arguments object
  whose numeric name values are less than the number of formal parameters of the corresponding function object initially share their values
  with the corresponding argument bindings in the function’s execution context. This means that changing the property changes the
  corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is deleted and then
  redefined or if the property is changed into an accessor property. For strict mode functions, the values of the arguments object‘s properties
  are simply a copy of the arguments passed to the function and there is no dynamic linkage between the property values and the
  formal parameter values.</p></div>
  <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> The ParameterMap object and its property values are used as a device for specifying the arguments object
  correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties are not directly
  accessible from ECMAScript code. An ECMAScript implementation does not need to actually create or use such objects to implement the
  specified semantics.</p></div>
  <div class=\"note\"><p><span class=\"nh\">NOTE 3</span> Arguments objects for strict mode functions define non-configurable accessor properties named \"<code><b>caller</b></code>\"
  and \"<code><b>callee</b></code>\" which throw a <b>TypeError</b> exception on access. The \"<code><b>calle</b></code>\" property has a more specific
  meaning for non-strict mode functions and a \"<code><b>calle</b></code>\" property has historically been provided as an implementation-defined
  extension by some ECMAScript implementations. The strict mode definition of these properties exists to ensure that neither of them is defined
  in any other manner by conforming ECMAScript implementations.</p></div>",
  null
] [
  "argumentsObject:arguments object"
] {
  /* 1. Let map be the value of the [[ParameterMap]] internal property of the arguments object. */
  map := argumentsObject.ParameterMap;
  /* 2. Let isMapped be the result of calling the [[GetOwnProperty]] internal method of map passing P as the
        argument. */
  isMapped := {map.GetOwnProperty}(map, P);
  /* 3. Let result be the result of calling the default [[Delete]] internal method (8.12.7) on the arguments object
        passing P and Throw as the arguments. */
  result := Delete(argumentsObject, P, Throw);
  /* 4. If result is true and the value of isMapped is not undefined, then */
  if ((result = true) && !(isMapped = 'undefined)) ["after-same:, then"] {
    /* a. Call the [[Delete]] internal method of map passing P, and false as the arguments. */
    {map.Delete}(map, P, false)
  };
  /* 5. Return result. */
  return result
};

/* 13.2 Creating Function Objects */
/* Given an optional parameter list specified by FormalParameterList, a body specified by FunctionBody, a Lexical
   Environment specified by Scope, and a Boolean flag Strict, a Function object is constructed as follows: */
function CreateGeneralFunctionObject(FunctionPrototype, FormalParameterList, FunctionBody, Scope, Strict, n) [
  "13.2",
  "Given an optional parameter list specified by <span class=\"nt\">FormalParameterList</span>, a body specified by <span class=\"nt\"><a href=\"#sec-13\">FunctionBody</a></span>,
  a <a href=\"#sec-10.2\">Lexical Environment</a> specified by <span class=\"nt\">Scope</span>, and a Boolean flag <span class=\"nt\">Strict</span>, a Function object is constructed as follows:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span> A <code><b>prototype</b></code> property is automatically created for every function, to allow for the possibility
  that the function will be used as a constructor.</p></div>",
  "Creating Function Objects"
] [
  "FunctionPrototype:the standard built-in Function prototype object as specified in <a href=\"#sec-15.3.3.1\">15.3.3.1</a>",
  "FunctionBody:<i><a href=\"#sec-13\">FunctionBody</a></i>"
] {
  /* 1. Create a new native ECMAScript object and let F be that object. */
  F := NewECMAScriptObject();
  /* 2. Set all the internal methods, except for [[Get]], of F as described in 8.12. */
  setAllInternalMethodsExceptGet(F);
  /* 3. Set the [[Class]] internal property of F to "Function". */
  setInternalProperty(F, "Class", "Function");
  /* 4. Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in 15.3.3.1. */
  setInternalProperty(F, "Prototype", FunctionPrototype);
  /* 5. Set the [[Get]] internal property of F as described in 15.3.5.4. */
  setInternalProperty(F, "Get", "GetF");
  /* 6. Set the [[Call]] internal property of F as described in 13.2.1. */
  setInternalProperty(F, "Call", "Call");
  /* 7. Set the [[Construct]] internal property of F as described in 13.2.2. */
  setInternalProperty(F, "Construct", "Construct");
  /* 8. Set the [[HasInstance]] internal property of F as described in 15.3.5.3. */
  setInternalProperty(F, "HasInstance", "HasInstance");
  /* 9. Set the [[Scope]] internal property of F to the value of Scope. */
  setInternalProperty(F, "Scope", Scope);
  /* 10. Let names be a List containing, in left to right textual order, the Strings corresponding to the identifiers of
        FormalParameterList. If no parameters are specified, let names be the empty list. */
  gen_wrapper ["after-same:. If no parameters are specified, let <i>names</i> be the empty list"] {
    names := listOfIdentifiersOf(FormalParameterList)
  };
  /* 11. Set the [[FormalParameters]] internal property of F to names. */
  setInternalProperty(F, "FormalParameters", names);
  /* 12. Set the [[Code]] internal property of F to FunctionBody. */
  setInternalProperty(F, "Code", FunctionBody);
  /* 13. Set the [[Extensible]] internal property of F to true. */
  setInternalProperty(F, "Extensible", true);
  /* 14. Let len be the number of formal parameters specified in FormalParameterList. If no parameters are specified,
        let len be 0. */
  gen_wrapper ["after-same:. If no parameters are specified, let <i>len</i> be 0"] {
    len := numberOfFormalParameters(FormalParameterList)
  };
  /* 15. Call the [[DefineOwnProperty]] internal method of F with arguments "length", Property Descriptor {[[Value]]:
        len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
  {F.DefineOwnProperty}(F, "length", PropertyDescriptor({
    Value: int_to_float len,
    Writable: false,
    Enumerable: false,
    Configurable: false
  }), false);

  if (!(typeof FunctionBody = __$Str)) [
    "split-if:"
  ] {
    /* 16. Let proto be the result of creating a new object as would be constructed by the expression new Object()
        where Object is the standard built-in constructor with that name. */
    proto := ObjectConstructor(|global|, 'null, Strict, [null]);
    /* 17. Call the [[DefineOwnProperty]] internal method of proto with arguments "constructor", Property Descriptor
          {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}, and false. */
    {proto.DefineOwnProperty}(proto, "constructor", PropertyDescriptor({
      Value: F,
      Writable: true,
      Enumerable: false,
      Configurable: true
    }), false);
    /* 18. Call the [[DefineOwnProperty]] internal method of F with arguments "prototype", Property Descriptor
          {[[Value]]: proto, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
    {F.DefineOwnProperty}(F, "prototype", PropertyDescriptor({
      Value: proto,
      Writable: true,
      Enumerable: false,
      Configurable: false
    }), false)
  };
  /* 19. If Strict is true, then */
  if (Strict = true) ["after-same:, then"] {
    /* a. Let thrower be the [[ThrowTypeError]] function Object (13.2.3). */
    thrower := createThrowTypeErrorFunctionObject(FunctionPrototype, Strict);
    /* b. Call the [[DefineOwnProperty]] internal method of F with arguments "caller", PropertyDescriptor
          {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
    {F.DefineOwnProperty}(F, "caller", PropertyDescriptor({
      Get: thrower,
      Set: thrower,
      Enumerable: false,
      Configurable: false
    }), false);
    /* c. Call the [[DefineOwnProperty]] internal method of F with arguments "arguments", PropertyDescriptor
          {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
    {F.DefineOwnProperty}(F, "arguments", PropertyDescriptor({
      Get: thrower,
      Set: thrower,
      Enumerable: false,
      Configurable: false
    }), false)
  };

  gen_wrapper ["print_ignore"] {
    if (n = null) {
      setInternalProperty(F, "internalLength", int_to_float len)
    } else {
      setInternalProperty(F, "internalLength", n)
    };

    setInternalProperty(F, "strict", Strict)
  };

  /* 20. Return F. */
  return F
};

/* 13.2.1 [[Call]] */
/* When the [[Call]] internal method for a Function object F is called with a this value and a list of arguments,
  the following steps are taken: */
function Call(externalScope, ref, F, this, args) [
  "13.2.1",
  "When the [[Call]] internal method for a Function object <var>F</var> is called with a this value and a list of arguments, the following steps are taken:",
  "",
  "[[Call]]"
] {
  gen_wrapper ["print_ignore"] {
    if (("Code" in_obj F) &&& (typeof F.Code = __$Str) &&& (F.Code = "GlobalObjectEval")) {
      args := completeArgs(args, F);
      return {F.Code}(externalScope, ref, this, F.strict, args)
    };
    if (("Code" in_obj F) &&& ((typeof F.Code = __$Str) || (typeof F.Code = __$Curry))) {
      args := completeArgs(args, F);
      return {F.Code}(F.Scope, this, F.strict, args)
    }
  };

  /* 1. Let funcCtx be the result of establishing a new execution context for function code using the value of F's
        [[FormalParameters]] internal property, the passed arguments List args, and the this value as described in 10.4.3. */
  funcCtx := EnteringFunctionCode(F, this, args);

  /* 2. Let result be the result of evaluating the FunctionBody that is the value of F's [[Code]] internal property.
        If F does not have a [[Code]] internal property or if its value is an empty FunctionBody,
        then result is (normal, undefined, empty). */
  if (!("Code" in_obj F) ||| isValueAnEmptyFunctionBody(F.Code)) {
    result := normalEmptyCompletion('undefined)
  } else {
    result := JS_Interpreter_FunctionBody(F.Code, funcCtx)
  };

  /* 3. Exit the execution context funcCtx, restoring the previous execution context. */
  exitExecutionContext(funcCtx);

  /* 4. If result.type is throw then throw result.value. */
  if (getCompletionType(result) = 'throw) ["after-same: then"] {
    throw getCompletionValue(result)
  };
  /* 5. If result.type is return then return result.value. */
  if (getCompletionType(result) = 'return) ["after-same: then"] {
    return getCompletionValue(result)
  };
  /* 6. Otherwise result.type must be normal. Return undefined. */
  gen_wrapper ["before-same:Otherwise <i>result</i>.type must be normal, "] {
    return 'undefined
  }
};

/* 13.2.2 [[Construct]] */
/* When the [[Construct]] internal method for a Function object F is called with a possibly empty list of arguments,
  the following steps are taken: */
function Construct(externalScope, ref, F, argumentsList) [
  "13.2.2",
  "When the [[Construct]] internal method for a Function object <var>F</var> is called with a possibly empty list of arguments, the following steps are taken:",
  "",
  "[[Construct]]"
] [
  "argumentsList:argument list passed into [[Construct]]"
] {
  /* 1. Let obj be a newly created native ECMAScript object. */
  obj := NewECMAScriptObject();
  /* 2. Set all the internal methods of obj as specified in 8.12. */
  setAllInternalMethodsOfObject(obj);
  /* 3. Set the [[Class]] internal property of obj to "Object". */
  setInternalProperty(obj, "Class", "Object");
  /* 4. Set the [[Extensible]] internal property of obj to true. */
  setInternalProperty(obj, "Extensible", true);
  /* 5. Let proto be the value of calling the [[Get]] internal property of F with argument "prototype". */
  proto := {F.Get}(F, "prototype");
  /* 6. If Type(proto) is Object, set the [[Prototype]] internal property of obj to proto. */
  if (Type(proto) = "Object") {
    setInternalProperty(obj, "Prototype", proto)
  };
  /* 7. If Type(proto) is not Object, set the [[Prototype]] internal property of obj to the standard built-in Object prototype
        object as described in 15.2.4. */
  if (!(Type(proto) = "Object")) {
    setInternalProperty(obj, "Prototype", getObjectPrototype(F.strict))
  };
  /* 8. Let result be the result of calling the [[Call]] internal property of F, providing obj as the this value and providing the
        argument list passed into [[Construct]] as args. */
  result := {F.Call}(externalScope, ref, F, obj, argumentsList);
  /* 9. If Type(result) is Object then return result. */
  if (Type(result) = "Object") ["after-same: then"] {
    return result
  };
  /* 10. Return obj */
  return obj
};

/* 13.2.3 The [[ThrowTypeError]] Function Object */
/* The [[ThrowTypeError]] object is a unique function object that is defined once as follows: */
function createThrowTypeErrorFunctionObject(functionPrototypeObject, strict) [
  "13.2.3",
  "The [[ThrowTypeError]] object is a unique function object that is defined once as follows:",
  "",
  "The [[ThrowTypeError]] Function Object"
] [
  "functionPrototypeObject:the standard built-in Function prototype object as specified in <a href=\"#sec-15.3.3.1\">15.3.3.1</a>"
] {
  /* 1. Create a new native ECMAScript object and let F be that object. */
  F := NewECMAScriptObject();
  /* 2. Set all the internal methods of F as described in 8.12. */
  setAllInternalMethodsOfObject(F);
  /* 3. Set the [[Class]] internal property of F to "Function". */
  setInternalProperty(F, "Class", "Function");
  /* 4. Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in 15.3.3.1. */
  setInternalProperty(F, "Prototype", functionPrototypeObject);
  /* 5. Set the [[Call]] internal property of F as described in 13.2.1. */
  setInternalProperty(F, "Call", "Call");
  /* 6. Set the [[Scope]] internal property of F to the Global Environment. */
  setInternalProperty(F, "Scope", getGlobalEnvironment(|global|));
  /* 7. Set the [[FormalParameters]] internal property of F to an empty List. */
  setInternalProperty(F, "FormalParameters", []);
  /* 8. Set the [[Code]] internal property of F to be a FunctionBody that unconditionally throws a TypeError exception and
        performs no other action. */
  setInternalProperty(F, "Code", "internalTypeErrorThrower");
  /* 9. Call the [[DefineOwnProperty]] internal method of F with arguments "length", Property Descriptor {[[Value]]: 0,
        [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
  {F.DefineOwnProperty}(F, "length", PropertyDescriptor({
    Value: int_to_float 0,
    Writable: false,
    Enumerable: false,
    Configurable: false
  }), false);
  /* 10. Set the [[Extensible]] internal property of F to false. */
  setInternalProperty(F, "Extensible", false);
  /* 11. Let [[ThrowTypeError]] be F. */
  ThrowTypeError := F;

  gen_wrapper ["print_ignore"] {
    setInternalProperty(F, "internalLength", 0.)
  };

  return F
};


/* 15.2.2.1 new Object ( [ value ] ) */
/* When the Object constructor is called with no arguments or with one argument value, the following steps are taken: */
function ObjectConstructor(globalObject, this, strict, params) [
  "15.2.2.1",
  "When the <code><b>Object</b></code> constructor is called with no arguments or with one argument <i>value</i>, the following steps are taken:",
  "",
  "new Object"
] {
  gen_wrapper ["print_ignore"]{
    value := getOptionalParam(params, 0)
  };

  /* 1. If value is supplied, then */
  if (!(value = null)) ["after-same:, then"] {
    /* a. If Type(value) is Object, then */
    if (Type(value) = "Object") ["after-same:, then"] {
      /* i. If the value is a native ECMAScript object, do not create a new object but simply return value. */
      if (isJavaScriptObject(value)) ["after-same:do not create a new object but simply"] {
        return value
      };
      /* ii. If the value is a host object, then actions are taken and a result is returned in an
            implementation-dependent manner that may depend on the host object. */
      if (isHostObject(value, this)) ["after-same:then actions are taken and"] {
        return hostObjectReturn()
      }
    };
    /* b. If Type(value) is String, return ToObject(value). */
    if (Type(value) = "String") {
      return ToObject(value)
    };
    /* c. If Type(value) is Boolean, return ToObject(value). */
    if (Type(value) = "Boolean") {
      return ToObject(value)
    };
    /* d. If Type(value) is Number, return ToObject(value). */
    if (Type(value) = "Number") {
      return ToObject(value)
    }
  };
  /* 2. Assert: The argument value was not supplied or its type was Null or Undefined. */
  assert((value = null) ||| (Type(value) = "Null") ||| (Type(value) = "Undefined"));
  /* 3. Let obj be a newly created native ECMAScript object. */
  obj := NewECMAScriptObject();
  /* 4. Set the [[Prototype]] internal property of obj to the standard built-in Object prototype object (15.2.4). */
  setInternalProperty(obj, "Prototype", getObjectPrototype(strict));
  /* 5. Set the [[Class]] internal property of obj to "Object". */
  setInternalProperty(obj, "Class", "Object");
  /* 6. Set the [[Extensible]] internal property of obj to true. */
  setInternalProperty(obj, "Extensible", true);
  /* 7. Set all the internal methods of obj as specified in 8.12. */
  setAllInternalMethodsOfObject(obj);
  /* 8. Return obj. */
  return obj
};

/* 15.2.3.2 Object.getPrototypeOf ( O ) */
/* -When the getPrototypeOf function is called with argument O, the following steps are taken: */
function ObjectGetPrototypeOf(globalObject, this, strict, params) [
  "15.2.3.2",
  "When the <code><b>getPrototypeOf</b></code> function is called with argument O, the following steps are taken:",
  "",
  "Object.getPrototypeOf"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Return the value of the [[Prototype]] internal property of O. */
  return getInternalProperty(O, "Prototype")
};

/* 15.2.3.3 Object.getOwnPropertyDescriptor ( O, P ) */
/* When the getOwnPropertyDescriptor function is called, the following steps are taken: */
function ObjectGetOwnPropertyDescriptor(globalObject, this, strict, params) [
  "15.2.3.3",
  "When the <b>getOwnPropertyDescriptor</b> function is called, the following steps are taken:",
  "",
  "Object.getOwnPropertyDescriptor"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0);
    P := l_nth(params, 1)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let name be ToString(P). */
  name := ToString(P);
  /* 3. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with argument name. */
  desc := {O.GetOwnProperty}(O, name);
  /* 4. Return the result of calling FromPropertyDescriptor(desc) (8.10.4). */
  return FromPropertyDescriptor(desc)
};

/* 15.2.3.4 Object.getOwnPropertyNames ( O ) */
/* When the getOwnPropertyNames function is called, the following steps are taken: */
function ObjectGetOwnPropertyNames(globalObject, this, strict, params) [
  "15.2.3.4",
  "When the <b>getOwnPropertyNames</b> function is called, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span> If <var>O</var> is a String instance, the set of own properties processed in step 4 includes the implicit properties
  defined in <a href=\"#sec-15.5.5.2\">15.5.5.2</a> that correspond to character positions within the object’s [[PrimitiveValue]] String.</p></div>",
  "Object.getOwnPropertyNames"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let array be the result of creating a new object as if by the expression new Array () where Array is the
        standard built-in constructor with that name. */
  array := ArrayConstructor(globalObject, this, strict, []);
  /* 3. Let n be 0. */
  n := 0;

  /* 4. For each named own property P of O */
  foreach (P : getOwnProperties(O)) [] ["P:named own property"] {
    /* a. Let name be the String value that is the name of P. */
    name := getStringValue(P);
    /* b. Call the [[DefineOwnProperty]] internal method of array with arguments ToString(n), the
          PropertyDescriptor {[[Value]]: name, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]:
          true}, and false. */
    {array.DefineOwnProperty}(array, ToString(int_to_float n), PropertyDescriptor({
      Value: name,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false);
    /* c. Increment n by 1. */
    n := n + 1
  };
  /* 5. Return array. */
  return array

  /* NOTE If O is a String instance, the set of own properties processed in step 4 includes the implicit properties defined
          in 15.5.5.2 that correspond to character positions within the object‘s [[PrimitiveValue]] String. */
};

/* 15.2.3.5 Object.create ( O [, Properties] ) */
/* The create function creates a new object with a specified prototype. When the create function is called, the
  following steps are taken: */
function ObjectCreate(globalObject, this, strict, params) [
  "15.2.3.5",
  "The <b>create</b> function creates a new object with a specified prototype. When the <b>create</b> function is called, the
  following steps are taken:",
  "",
  "Object.create"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0);
    Properties := getOptionalParam(params, 1)
  };

  /* 1. If Type(O) is not Object or Null throw a TypeError exception. */
  if (!(Type(O) = "Object") && !(Type(O) = "Null")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let obj be the result of creating a new object as if by the expression new Object() where Object is the
        standard built-in constructor with that name */
  obj := ObjectConstructor(globalObject, this, strict, []);
  /* 3. Set the [[Prototype]] internal property of obj to O. */
  setInternalProperty(obj, "Prototype", O);
  /* 4. If the argument Properties is present and not undefined, add own properties to obj as if by calling the
        standard built-in function Object.defineProperties with arguments obj and Properties. */
  if (!(Properties = null) &&& !(Properties = 'undefined)) {
    ObjectDefineProperties(globalObject, this, strict, [obj, Properties])
  };
  /* 5. Return obj. */
  return obj
};

/* 15.2.3.6 Object.defineProperty ( O, P, Attributes ) */
/* The defineProperty function is used to add an own property and/or update the attributes of an existing own
  property of an object. When the defineProperty function is called, the following steps are taken: */
function ObjectDefineProperty(globalObject, this, strict, params) [
  "15.2.3.6",
  "The <b>defineProperty</b> function is used to add an own property and/or update the attributes of an existing own
  property of an object. When the <b>defineProperty</b> function is called, the following steps are taken:",
  "",
  "Object.defineProperty"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0);
    P := l_nth(params, 1);
    Attributes := l_nth(params, 2)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let name be ToString(P). */
  name := ToString(P);
  /* 3. Let desc be the result of calling ToPropertyDescriptor with Attributes as the argument. */
  desc := ToPropertyDescriptor(Attributes);
  /* 4. Call the [[DefineOwnProperty]] internal method of O with arguments name, desc, and true. */
  {O.DefineOwnProperty}(O, name, desc, true);
  /* 5. Return O. */
  return O
};

/* 15.2.3.7 Object.defineProperties ( O, Properties ) */
/* The defineProperties function is used to add own properties and/or update the attributes of existing own
    properties of an object. When the defineProperties function is called, the following steps are taken: */
function ObjectDefineProperties(globalObject, this, strict, params) [
  "15.2.3.7",
  "The <b>defineProperties</b> function is used to add own properties and/or update the attributes of existing own
  properties of an object. When the <b>defineProperties</b> function is called, the following steps are taken:",
  "If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration
  order must be used to order the list elements in step 3 of this algorithm.",
  "Object.defineProperties"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0);
    Properties := l_nth(params, 1)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let props be ToObject(Properties). */
  props := ToObject(Properties);
  /* 3. Let names be an internal list containing the names of each enumerable own property of props. */
  names := getOwnEnumerableProperties(props);
  /* 4. Let descriptors be an empty internal List. */
  descriptors := [];
  /* 5. For each element P of names in list order, */
  foreach (P : names) ["after-same: in list order,"] ["P:element"] {
    /* a. Let descObj be the result of calling the [[Get]] internal method of props with P as the argument. */
    descObj := {props.Get}(props, P);
    /* b. Let desc be the result of calling ToPropertyDescriptor with descObj as the argument. */
    desc := ToPropertyDescriptor(descObj);
    /* c. Append the pair (a two element List) consisting of P and desc to the end of descriptors. */
    descriptors := l_add(descriptors, [P, desc])
  };
  /* 6. For each pair from descriptors in list order, */
  foreach (pair : descriptors) ["after-same: in list order,"] {
    /* a. Let P be the first element of pair. */
    P := l_nth(pair, 0);
    /* b. Let desc be the second element of pair. */
    desc := l_nth(pair, 1);
    /* c. Call the [[DefineOwnProperty]] internal method of O with arguments P, desc, and true. */
    {O.DefineOwnProperty}(O, P, desc, true)
  };
  /* 7. Return O. */
  return O

  /* If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration
     order must be used to order the list elements in step 3 of this algorithm. */
};

/* 15.2.3.8 Object.seal ( O ) */
/* When the seal function is called, the following steps are taken: */
function ObjectSeal(globalObject, this, strict, params) [
  "15.2.3.8",
  "When the <b>seal</b> function is called, the following steps are taken:",
  "",
  "Object.seal"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. For each named own property name P of O, */
  foreach (P : O) [] ["P:named own property name"] {
    /* a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. */
    desc := {O.GetOwnProperty}(O, P);
    /* b. If desc.[[Configurable]] is true, set desc.[[Configurable]] to false. */
    if (desc.Configurable = true) {
      setInternalProperty(desc, "Configurable", false)
    };
    /* c. Call the [[DefineOwnProperty]] internal method of O with P, desc, and true as arguments. */
    {O.DefineOwnProperty}(O, P, desc, true)
  };
  /* 3. Set the [[Extensible]] internal property of O to false. */
  setInternalProperty(O, "Extensible", false);
  /* 4. Return O. */
  return O
};

/* 15.2.3.9 Object.freeze ( O ) */
/* When the freeze function is called, the following steps are taken: */
function ObjectFreeze(globalObject, this, strict, params) [
  "15.2.3.9",
  "When the <b>freeze</b> function is called, the following steps are taken:",
  "",
  "Object.freeze"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. For each named own property name P of O, */
  foreach (P : O) [] ["P:named own property name"] {
    /* a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. */
    desc := {O.GetOwnProperty}(O, P);
    /* b. If IsDataDescriptor(desc) is true, then */
    if (IsDataPropertyDescriptor(desc) = true) ["after-same: then"] {
      /* i. If desc.[[Writable]] is true, set desc.[[Writable]] to false. */
      if (desc.Writable = true) {
        setInternalProperty(desc, "Writable", false)
      }
    };
    /* c. If desc.[[Configurable]] is true, set desc.[[Configurable]] to false. */
    if (desc.Configurable = true) {
      setInternalProperty(desc, "Configurable", false)
    };
    /* d. Call the [[DefineOwnProperty]] internal method of O with P, desc, and true as arguments. */
    {O.DefineOwnProperty}(O, P, desc, true)
  };
  /* 3. Set the [[Extensible]] internal property of O to false. */
  setInternalProperty(O, "Extensible", false);
  /* 4. Return O. */
  return O
};

/* 15.2.3.10 Object.preventExtensions ( O ) */
/* When the preventExtensions function is called, the following steps are taken: */
function ObjectPreventExtensions(globalObject, this, strict, params) [
  "15.2.3.10",
  "When the <b>preventExtensions</b> function is called, the following steps are taken:",
  "",
  "Object.preventExtensions"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Set the [[Extensible]] internal property of O to false. */
  setInternalProperty(O, "Extensible", false);
  /* 3. Return O. */
  return O
};

/* 15.2.3.11 Object.isSealed ( O ) */
/* When the isSealed function is called with argument O, the following steps are taken: */
function ObjectIsSealed(globalObject, this, strict, params) [
  "15.2.3.11",
  "When the <b>isSealed</b> function is called with argument <var>O</var>, the following steps are taken:",
  "",
  "Object.isSealed"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. For each named own property name P of O, */
  foreach (P : O) [] ["P:named own property name"] {
    /* a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. */
    desc := {O.GetOwnProperty}(O, P);
    /* b. If desc.[[Configurable]] is true, then return false. */
    if (desc.Configurable = true) {
      return false
    }
  };
  /* 3. If the [[Extensible]] internal property of O is false, then return true. */
  if (getInternalProperty(O, "Extensible") = false) {
    return true
  };
  /* 4. Otherwise, return false. */
  gen_wrapper ["before-same:Otherwise, "] {
    return false
  }
};

/* 15.2.3.12 Object.isFrozen ( O ) */
/* When the isFrozen function is called with argument O, the following steps are taken: */
function ObjectIsFrozen(globalObject, this, strict, params) [
  "15.2.3.12",
  "When the <b>isFrozen</b> function is called with argument <var>O</var>, the following steps are taken:",
  "",
  "Object.isFrozen"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. For each named own property name P of O, */
  foreach (P : O) [] ["P:named own property name"] {
    /* a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. */
    desc := {O.GetOwnProperty}(O, P);
    /* b. If IsDataDescriptor(desc) is true then */
    if (IsDataPropertyDescriptor(desc) = true) {
      /* i. If desc.[[Writable]] is true, return false. */
      if (desc.Writable = true) {
        return false
      }
    };
    /* c. If desc.[[Configurable]] is true, then return false. */
    if (getInternalProperty(desc, "Configurable") = true) {
      return false
    }
  };
  /* 3. If the [[Extensible]] internal property of O is false, then return true. */
  if (getInternalProperty(O, "Extensible") = false) ["after-same:, then"] {
    return true
  };
  /* 4. Otherwise, return false. */
  gen_wrapper ["before-same:Otherwise, "] {
    return false
  }
};

/* 15.2.3.13 Object.isExtensible ( O ) */
/* When the isExtensible function is called with argument O, the following steps are taken: */
function ObjectIsExtensible(globalObject, this, strict, params) [
  "15.2.3.13",
  "When the <b>isExtensible</b> function is called with argument <var>O</var>, the following steps are taken:",
  "",
  "Object.isExtensible"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If Type(O) is not Object throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Return the Boolean value of the [[Extensible]] internal property of O. */
  return getInternalProperty(O, "Extensible")
};

/* 15.2.3.14 Object.keys ( O ) */
/* When the keys function is called with argument O, the following steps are taken: */
function ObjectKeys(globalObject, this, strict, params) [
  "15.2.3.14",
  "When the <b>keys</b> function is called with argument <var>O</var>, the following steps are taken:",
  "If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration
  order must be used in step 5 of this algorithm.",
  "Object.keys"
] {
  gen_wrapper ["print_ignore"] {
    O := l_nth(params, 0)
  };

  /* 1. If the Type(O) is not Object, throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let n be the number of own enumerable properties of O */
  n := l_len getOwnEnumerableProperties(O);
  /* 3. Let array be the result of creating a new Object as if by the expression new Array(n) where Array is
        the standard built-in constructor with that name. */
  array := ArrayConstructor(globalObject, this, strict, [n]);
  /* 4. Let index be 0. */
  index := 0;
  /* 5. For each own enumerable property of O whose name String is P */
  foreach (P : getOwnEnumerableProperties(O)) [] ["P:own enumerable property whose name String is"] {
    /* a. Call the [[DefineOwnProperty]] internal method of array with arguments ToString(index), the
          PropertyDescriptor {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true},
          and false. */
    {array.DefineOwnProperty}(array, ToString(int_to_float index), PropertyDescriptor({
      Value: P,
      Writable: true,
      Enumerable: true,
      Configurable: true
    }), false);
    /* b. Increment index by 1. */
    index := index + 1
  };
  /* 6. Return array. */
  return array

  /* If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration
    order must be used in step 5 of this algorithm. */
};

/* 15.2.4.2 Object.prototype.toString ( ) */
/* When the toString method is called, the following steps are taken: */
function ObjectPrototypeToString(globalObject, this, strict, params) [
  "15.2.4.2",
  "When the <b>toString</b> method is called, the following steps are taken:",
  "",
  "Object.prototype.toString"
] [
  "this:the this value"
] {
  /* 1. If the this value is undefined, return "[object Undefined]". */
  if (this = 'undefined) {
    return "[object Undefined]"
  };
  /* 2. If the this value is null, return "[object Null]". */
  if (this = 'null) {
    return "[object Null]"
  };
  /* 3. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 4. Let class be the value of the [[Class]] internal property of O. */
  class := getInternalProperty(O, "Class");
  /* 5. Return the String value that is the result of concatenating the three Strings "[object ", class, and "]". */
  return s_concat ["[object ", class, "]"]
};

/* 15.2.4.3 Object.prototype.toLocaleString ( ) */
/* When the toLocaleString method is called, the following steps are taken: */
function ObjectPrototypeToLocaleString(globalObject, this, strict, params) [
  "15.2.4.3",
  "When the <b>toLocaleString</b> method is called, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> This function is provided to give all Objects a generic <code><b>toLocaleString</b></code> interface, even though
  not all may use it. Currently, <code><b>Array</b></code>, <code><b>Number</b></code>, and <code><b>Date</b></code> provide their own
  locale-sensitive <code><b>toLocaleString</b></code> methods.</p></div>
  <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> The first parameter to this function is likely to be used in a future version of this standard; it is recommended
  that implementations do not use this parameter position for anything else.</p></div>",
  "Object.prototype.toLocaleString"
] ["this:the this value"] {
  /* 1. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 2. Let toString be the result of calling the [[Get]] internal method of O passing "toString" as the argument. */
  toString := {O.Get}(O, "toString");
  /* 3. If IsCallable(toString) is false, throw a TypeError exception. */
  if (IsCallable(toString) = false) {
    throw TypeErrorConstructorInternal()
  };
  /* 4. Return the result of calling the [[Call]] internal method of toString passing O as the this value and no
        arguments. */
  return {toString.Call}(null, null, toString, O, [])

  /* NOTE 1 This function is provided to give all Objects a generic toLocaleString interface, even though not all may
            use it. Currently, Array, Number, and Date provide their own locale-sensitive toLocaleString methods. */

  /* NOTE 2 The first parameter to this function is likely to be used in a future version of this standard; it is recommended
            that implementations do not use this parameter position for anything else. */
};

/* 15.2.4.4 Object.prototype.valueOf ( ) */
/* When the valueOf method is called, the following steps are taken: */
function ObjectPrototypeValueOf(globalObject, this, strict, params) [
  "15.2.4.4",
  "When the <b>valueOf</b> method is called, the following steps are taken:",
  "",
  "Object.prototype.valueOf"
] ["this:the this value"] {
  /* 1. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 2. If O is the result of calling the Object constructor with a host object (15.2.2.1), then */
  if (isHostObject(O, this)) ["after-same: then"] {
    /* a. Return either O or another value such as the host object originally passed to the constructor. The
          specific result that is returned is implementation-defined. */
    return hostObjectValueOf(O, this)
  };
  /* 3. Return O. */
  return O
};

/* 15.2.4.5 Object.prototype.hasOwnProperty (V) */
/* When the hasOwnProperty method is called with argument V, the following steps are taken: */
function ObjectPrototypeHasOwnProperty(globalObject, this, strict, params) [
  "15.2.4.5",
  "When the <b>hasOwnProperty</b> method is called with argument <var>V</var>, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> Unlike [[HasProperty]] (<a href=\"#sec-8.12.6\">8.12.6</a>), this method does not consider objects in the prototype chain.</p></div>
  <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1
  in previous editions of this specification will continue to be thrown even if the <b>this</b> value is <b>undefined</b> or <b>null</b>.</p></div>",
  "Object.prototype.hasOwnProperty"
] {
  gen_wrapper ["print_ignore"] {
    V := l_nth(params, 0)
  };

  /* 1. Let P be ToString(V). */
  P := ToString(V);
  /* 2. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 3. Let desc be the result of calling the [[GetOwnProperty]] internal method of O passing P as the argument. */
  desc := {O.GetOwnProperty}(O, P);
  /* 4. If desc is undefined, return false. */
  if (desc = 'undefined) { return false };
  /* 5. Return true. */
  return true

  /* NOTE 1 Unlike [[HasProperty]] (8.12.6), this method does not consider objects in the prototype chain. */

  /* NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1
            in previous editions of this specification will continue to be thrown even if the this value is undefined or null. */
};

/* 15.2.4.6 Object.prototype.isPrototypeOf (V) */
/* When the isPrototypeOf method is called with argument V, the following steps are taken: */
function ObjectPrototypeIsPrototypeOf(globalObject, this, strict, params) [
  "15.2.4.6",
  "When the <b>isPrototypeOf</b> method is called with argument <var>V</var>, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span> The ordering of steps 1 and 2 is chosen to preserve the behaviour specified by previous editions
  of this specification for the case where V is not an object and the this value is undefined or null.</p></div>",
  "Object.prototype.isPrototypeOf"
] {
  gen_wrapper ["print_ignore"] {
    V := l_nth(params, 0)
  };

  /* 1. If V is not an object, return false. */
  if (!(Type(V) = "Object")) { return false };
  /* 2. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 3. Repeat */
  repeat {
    /* a. Let V be the value of the [[Prototype]] internal property of V. */
    V := getInternalProperty(V, "Prototype");
    /* b. if V is null, return false */
    if (V = 'null) { return false };
    /* c. If O and V refer to the same object, return true. */
    if (sameObject(O, V)) { return true }
  }

  /* NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour specified by previous editions of this
          specification for the case where V is not an object and the this value is undefined or null. */
};

/* 15.2.4.7 Object.prototype.propertyIsEnumerable (V) */
/* When the propertyIsEnumerable method is called with argument V, the following steps are taken: */
function ObjectPrototypePropertyIsEnumerable(globalObject, this, strict, params) [
  "15.2.4.7",
  "When the <b>propertyIsEnumerable</b> method is called with argument <var>V</var>, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> This method does not consider objects in the prototype chain.</p></div>
  <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1
  in previous editions of this specification will continue to be thrown even if the <b>this</b> value is <b>undefined</b> or <b>null</b>.</p></div>",
  "Object.prototype.propertyIsEnumerable"
] {
  gen_wrapper ["print_ignore"] {
    V := l_nth(params, 0)
  };

  /* 1. Let P be ToString(V). */
  P := ToString(V);
  /* 2. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 3. Let desc be the result of calling the [[GetOwnProperty]] internal method of O passing P as the argument. */
  desc := {O.GetOwnProperty}(O, P);
  /* 4. If desc is undefined, return false. */
  if (desc = 'undefined) { return false };
  /* 5. Return the value of desc.[[Enumerable]]. */
  return getInternalProperty(desc, "Enumerable")

  /* NOTE 1 This method does not consider objects in the prototype chain. */
  /* NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1
            in previous editions of this specification will continue to be thrown even if the this value is undefined or null. */
};

/* 15.3.2.1 new Function (p1, p2, ... , pn, body) */
/* The last argument specifies the body (executable code) of a function; any preceding arguments specify formal
  parameters. */
/* When the Function constructor is called with some arguments p1, p2, ... , pn, body (where n might be 0, that
  is, there are no "p" arguments, and where body might also not be provided), the following steps are taken: */
function FunctionConstructor(globalObject, this, strict, params) [
  "15.3.2.1",
  "The last argument specifies the body (executable code) of a function; any preceding arguments specify formal
  parameters.</p>
  <p>When the <code>Function</code> constructor is called with some arguments <var>p1</var>, <var>p2</var>, ... ,
  <var>pn</var>, <var>body</var> (where <var>n</var> might be 0, that is, there are no \"<var>p</var>\" arguments,
  and where <var>body</var> might also not be provided), the following steps are taken:",
  "A <code>prototype</code> property is automatically created for every function, to provide for the possibility that the
  function will be used as a constructor.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> It is permissible but not necessary to have one argument for each formal
  parameter to be specified. For example, all three of the following expressions produce the same result:</p>
  <pre>new Function(\"a\", \"b\", \"c\", \"return a+b+c\")</pre>
  <pre>new Function(\"a, b, c\", \"return a+b+c\")</pre>
  <pre>new Function(\"a,b\", \"c\", \"return a+b+c\")</pre></div>",
  "new Function"
] {
  /* 1. Let argCount be the total number of arguments passed to this function invocation. */
  argCount := l_len params;
  /* 2. Let P be the empty String. */
  P := "";
  /* 3. If argCount = 0, let body be the empty String. */
  if (argCount = 0) {
    body := ""
  }
  /* 4. Else if argCount = 1, let body be that argument. */
  elif (argCount = 1) {
    body := l_nth(params, 0)
  }
  /* 5. Else, argCount > 1 */
  else ["after-same:, argCount > 1"] {
    /* a. Let firstArg be the first argument. */
    firstArg := l_nth(params, 0);
    /* b. Let P be ToString(firstArg). */
    P := ToString(firstArg);
    /* c. Let k be 2. */
    k := 2;
    /* d. Repeat, while k < argCount */
    while(k < argCount) {
      /* i. Let nextArg be the k‘th argument. */
      nextArg := l_nth(params, k - 1);
      /* ii. Let P be the result of concatenating the previous value of P, the String "," (a comma), and
              ToString(nextArg). */
      P := s_concat [P, ",", ToString(nextArg)];
      /* iii. Increase k by 1. */
      k := k + 1
    };
    /* e. Let body be the k‘th argument. */
    body := l_nth(params, k - 1)
  };
  /* 6. Let body be ToString(body). */
  body := ToString(body);

  gen_wrapper ["print_ignore"] {
    body := parseBody(P, body, strict);
    P := parseParams(P)
  };
  /* 7. If P is not parsable as a FormalParameterList opt then throw a SyntaxError exception. */
  if (!isParsableAsFormalParametersList(P)) { /* TODO */
    throw SyntaxErrorConstructorInternal()
  };
  /* 8. If body is not parsable as FunctionBody then throw a SyntaxError exception. */
  if (!isParsableAsFunctionBody(body)) {
    throw SyntaxErrorConstructorInternal()
  };
  /* 9. If body is strict mode code (see 10.1.1) then let strict be true, else let strict be false. */
  if (isBuiltInFunctionBodyStrictModeCode(body)) {
    strict := true
  } else {
    strict := false
  };
  /* 10. If strict is true, throw any exceptions specified in 13.1 that apply. */
  if (strict = true) {
    throwAnyApplicableExceptions(body)
  };
  /* 11. Return a new Function object created as specified in 13.2 passing P as the FormalParameterList opt and body
         as the FunctionBody. Pass in the Global Environment as the Scope parameter and strict as the Strict flag. */
  return CreateFunctionObject(P, body, getGlobalEnvironment(globalObject), strict, null)

  /* A prototype property is automatically created for every function, to provide for the possibility that the
     function will be used as a constructor. */

  /* NOTE It is permissible but not necessary to have one argument for each formal parameter to be specified. For
          example, all three of the following expressions produce the same result: */

  /*                new Function("a", "b", "c", "return a+b+c")                    */
  /*                new Function("a, b, c", "return a+b+c")                        */
  /*                new Function("a,b", "c", "return a+b+c")                       */
};

/* 15.3.4.2 Function.prototype.toString ( ) */
function FunctionPrototypeToString(globalObject, this, strict, params) {
  /* An implementation-dependent representation of the function is returned. This representation has the syntax of
     a FunctionDeclaration. Note in particular that the use and placement of white space, line terminators, and
     semicolons within the representation String is implementation-dependent. */
  /* The toString function is not generic; it throws a TypeError exception if its this value is not a Function
     object. Therefore, it cannot be transferred to other kinds of objects for use as a method. */
  if (!isFunctionObject(this)) {
    throw TypeErrorConstructorInternal()
  };
  return "function () {}"
  /* TODO section_15.3_implementation_dependent */
};

/* 15.3.4.3 Function.prototype.apply (thisArg, argArray) */
/* When the apply method is called on an object func with arguments thisArg and argArray, the following steps
   are taken: */
function FunctionPrototypeApply(globalObject, func, strict, params) [
  "15.3.4.3",
  "When the <code>apply</code> method is called on an object <var>func</var> with arguments <var>thisArg</var> and
  <var>argArray</var>, the following steps are taken:",
  "The <code>length</code> property of the <code>apply</code> method is <b>2</b>.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> The thisArg value is passed without modification as the <b>this</b> value. This is a
  change from Edition 3, where a <b>undefined</b> or <b>null</b> thisArg is replaced with the global object and <a href=\"#sec-9.9\">ToObject</a>
  is applied to all other values and that result is passed as the <b>this</b> value.</p></div>",
  "Function.prototype.apply"
] {
  gen_wrapper ["print_ignore"] {
    thisArg := l_nth(params, 0);
    argArray := l_nth(params, 1)
  };
  /* 1. If IsCallable(func) is false, then throw a TypeError exception. */
  if (IsCallable(func) = false) ["after-same:then"] {
    throw TypeErrorConstructorInternal()
  };
  /* 2. If argArray is null or undefined, then */
  if ((argArray = 'null) ||| (argArray = 'undefined)) ["after-same:then"] {
    /* a. Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value
          and an empty list of arguments. */
    return {func.Call}(null, null, func, thisArg, [])
  };
  /* 3. If Type(argArray) is not Object, then throw a TypeError exception. */
  if (!(Type(argArray) = "Object")) ["after-same:then"] {
    throw TypeErrorConstructorInternal()
  };
  /* 4. Let len be the result of calling the [[Get]] internal method of argArray with argument "length". */
  len := {argArray.Get}(argArray, "length");
  /* 5. Let n be ToUint32(len). */
  n := ToUint32(len);
  /* 6. Let argList be an empty List. */
  argList := [];
  /* 7. Let index be 0. */
  index := 0.;
  /* 8. Repeat while index < n */
  while(index < n) {
    /* a. Let indexName be ToString(index). */
    indexName := ToString(index);
    /* b. Let nextArg be the result of calling the [[Get]] internal method of argArray with indexName as the
          argument. */
    nextArg := {argArray.Get}(argArray, indexName);
    /* c. Append nextArg as the last element of argList. */
    argList := l_add(argList, nextArg);
    /* d. Set index to index + 1. */
    index := index + 1.
  };
  /* 9. Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value and
        argList as the list of arguments. */
  return {func.Call}(null, null, func, thisArg, argList)

  /* The length property of the apply method is 2. */

  /* NOTE The thisArg value is passed without modification as the this value. This is a change from Edition 3, where a
          undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that result is
          passed as the this value. */
};

/* 15.3.4.4 Function.prototype.call (thisArg [ , arg1 [ , arg2, ... ] ] ) */
/* When the call method is called on an object func with argument thisArg and optional arguments arg1, arg2
  etc, the following steps are taken: */
function FunctionPrototypeCall(globalObject, func, strict, params) [
  "15.3.4.4",
  "When the <code>call</code> method is called on an object <var>func</var> with argument <var>thisArg</var> and optional
  arguments <var>arg1</var>, <var>arg2</var> etc, the following steps are taken:",
  "The <code>length</code> property of the <code>call</code> method is <b>1</b>.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> The thisArg value is passed without modification as the <b>this</b> value. This is a
  change from Edition 3, where a <b>undefined</b> or <b>null</b> thisArg is replaced with the global object and <a href=\"#sec-9.9\">ToObject</a>
  is applied to all other values and that result is passed as the <b>this</b> value.</p></div>",
  "Function.prototype.call"
] {
  gen_wrapper ["print_ignore"] {
    thisArg := l_nth(params, 0);
    args := tl params
  };

  /* 1. If IsCallable(func) is false, then throw a TypeError exception. */
  if (IsCallable(func) = false) ["after-same:then"] {
    throw TypeErrorConstructorInternal()
  };
  /* 2. Let argList be an empty List. */
  argList := [];
  /* 3. If this method was called with more than one argument then in left to right order starting with arg1 append
        each argument as the last element of argList */
  if (!(args = [])) {
    argList := args
  };
  /* 4. Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value and
        argList as the list of arguments. */
  return {func.Call}(null, null, func, thisArg, argList)

  /* The length property of the call method is 1. */

  /* NOTE The thisArg value is passed without modification as the this value. This is a change from Edition 3, where a
          undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that result is
          passed as the this value. */
};

/* 15.3.4.5 Function.prototype.bind (thisArg [, arg1 [, arg2, ...]]) */
/* The bind method takes one or more arguments, thisArg and (optionally) arg1, arg2, etc, and returns a new
  function object by performing the following steps: */
function FunctionPrototypeBind(globalObject, this, strict, params) [
  "15.3.4.5",
  "The bind method takes one or more arguments, <var>thisArg</var> and (optionally) <var>arg1</var>, <var>arg2</var>, etc,
  and returns a new function object by performing the following steps:",
  "The <code>length</code> property of the <code>bind</code> method is <b>1</b>.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> Function objects created using <code>Function.prototype.bind</code> do not have a
  <code>prototype</code> property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties.</p></div>",
  "Function.prototype.bind"
] ["this:the <b>this</b> value"] {
  gen_wrapper ["print_ignore"] {
    thisArg := l_nth(params, 0);
    args := tl params
  };

  /* 1. Let Target be the this value. */
  Target := this;
  /* 2. If IsCallable(Target) is false, throw a TypeError exception. */
  if (IsCallable(Target) = false) {
    throw TypeErrorConstructorInternal()
  };
  /* 3. Let A be a new (possibly empty) internal list of all of the argument values provided after thisArg (arg1, arg2
        etc), in order. */
  A := args;
  /* 4. Let F be a new native ECMAScript object . */
  F := NewECMAScriptObject();
  /* 5. Set all the internal methods, except for [[Get]], of F as specified in 8.12. */
  setAllInternalMethodsExceptGet(F);
  /* 6. Set the [[Get]] internal property of F as specified in 15.3.5.4. */
  setInternalProperty(F, "Get", "GetF");
  /* 7. Set the [[TargetFunction]] internal property of F to Target. */
  setInternalProperty(F, "TargetFunction", Target);
  /* 8. Set the [[BoundThis]] internal property of F to the value of thisArg. */
  setInternalProperty(F, "BoundThis", thisArg);
  /* 9. Set the [[BoundArgs]] internal property of F to A. */
  setInternalProperty(F, "BoundArgs", A);
  /* 10. Set the [[Class]] internal property of F to "Function". */
  setInternalProperty(F, "Class", "Function");
  /* 11. Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in
         15.3.3.1. */
  setInternalProperty(F, "Prototype", getFunctionPrototype(strict));
  /* 12. Set the [[Call]] internal property of F as described in 15.3.4.5.1. */
  setInternalProperty(F, "Call", "CallBind");
  /* 13. Set the [[Construct]] internal property of F as described in 15.3.4.5.2. */
  setInternalProperty(F, "Construct", "ConstructBind");
  /* 14. Set the [[HasInstance]] internal property of F as described in 15.3.4.5.3. */
  setInternalProperty(F, "HasInstance", "HasInstanceBind");
  /* 15. If the [[Class]] internal property of Target is "Function", then */
  if (getInternalProperty(Target, "Class") = "Function") ["after-same:, then"] {
    /* a. Let L be the length property of Target minus the length of A. */
    L := getDescriptorValue(getJSProperty(Target, "length")) - (int_to_float (l_len A));
    /* b. Set the length own property of F to either 0 or L, whichever is larger. */
    if (L > 0.) {
      setJSProperty(F, "length", newDataPropertyDescriptorFull(L, false, false, false));
      gen_wrapper ["print_ignore"] {
        setInternalProperty(F, "internalLength", L)
      }
    } else {
      setJSProperty(F, "length", newDataPropertyDescriptorFull(0., false, false, false));
      gen_wrapper ["print_ignore"] {
        setInternalProperty(F, "internalLength", 0.)
      }
    }
  }
  /* 16. Else set the length own property of F to 0. */
  else {
    setJSProperty(F, "length", newDataPropertyDescriptorFull(0., false, false, false));
    gen_wrapper ["print_ignore"] {
      setInternalProperty(F, "internalLength", 0.)
    }
  };
  /* 17. Set the attributes of the length own property of F to the values specified in 15.3.5.1. */

  /* 18. Set the [[Extensible]] internal property of F to true. */
  setInternalProperty(F, "Extensible", true);
  /* 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3). */
  thrower := createThrowTypeErrorFunctionObject(getFunctionPrototype(strict), strict);
  /* 20. Call the [[DefineOwnProperty]] internal method of F with arguments "caller", PropertyDescriptor
        {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
  {F.DefineOwnProperty}(F, "caller", PropertyDescriptor({
    Get: thrower,
    Set: thrower,
    Enumerable: false,
    Configurable: false
  }), false);
  /* 21. Call the [[DefineOwnProperty]] internal method of F with arguments "arguments", PropertyDescriptor
        {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false. */
  {F.DefineOwnProperty}(F, "arguments", PropertyDescriptor({
    Get: thrower,
    Set: thrower,
    Enumerable: false,
    Configurable: false
  }), false);
  /* 22. Return F. */
  return F

  /* The length property of the bind method is 1. */

  /* NOTE Function objects created using Function.prototype.bind do not have a prototype property or the
          [[Code]], [[FormalParameters]], and [[Scope]] internal properties. */
};

/* 15.3.4.5.1 [[Call]] */
/* When the [[Call]] internal method of a function object, F, which was created using the bind function is called
  with a this value and a list of arguments ExtraArgs, the following steps are taken: */
function CallBind(externalScope, ref, F, this, ExtraArgs) [
  "15.3.4.5.1",
  "When the [[Call]] internal method of a function object, <var>F</var>, which was created using the bind function is
  called with a <b>this</b> value and a list of arguments <span class=\"nt\">ExtraArgs</span>, the following steps are taken:",
  "",
  "[[Call]]"
] {
  /* 1. Let boundArgs be the value of F’s [[BoundArgs]] internal property. */
  boundArgs := getInternalProperty(F, "BoundArgs");
  /* 2. Let boundThis be the value of F’s [[BoundThis]] internal property. */
  boundThis := getInternalProperty(F, "BoundThis");
  /* 3. Let target be the value of F’s [[TargetFunction]] internal property. */
  target := getInternalProperty(F, "TargetFunction");
  /* 4. Let args be a new list containing the same values as the list boundArgs in the same order followed by the
        same values as the list ExtraArgs in the same order. */
  args := l_concat(boundArgs, ExtraArgs);
  /* 5. Return the result of calling the [[Call]] internal method of target providing boundThis as the this value and
        providing args as the arguments. */
  return {target.Call}(externalScope, ref, target, boundThis, args)
};

/* 15.3.4.5.2 [[Construct]] */
/* When the [[Construct]] internal method of a function object, F that was created using the bind function is called
  with a list of arguments ExtraArgs, the following steps are taken: */
function ConstructBind(externalScope, ref, F, ExtraArgs) [
  "15.3.4.5.2",
  "When the [[Construct]] internal method of a function object, <var>F</var> that was created using the bind function is
  called with a list of arguments <span class=\"nt\">ExtraArgs</span>, the following steps are taken:",
  "",
  "[[Construct]]"
] {
  /* 1. Let target be the value of F’s [[TargetFunction]] internal property. */
  target := getInternalProperty(F, "TargetFunction");
  /* 2. If target has no [[Construct]] internal method, a TypeError exception is thrown. */
  if (!("Construct" in_obj target)) {
    throw TypeErrorConstructorInternal()
  };
  /* 3. Let boundArgs be the value of F’s [[BoundArgs]] internal property. */
  boundArgs := getInternalProperty(F, "BoundArgs");
  /* 4. Let args be a new list containing the same values as the list boundArgs in the same order followed by the
        same values as the list ExtraArgs in the same order. */
  args := l_concat(boundArgs, ExtraArgs);
  /* 5. Return the result of calling the [[Construct]] internal method of target providing args as the arguments. */
  return {target.Construct}(externalScope, ref, target, args)
};

/* 15.3.4.5.3 [[HasInstance]] (V) */
/* When the [[HasInstance]] internal method of a function object F, that was created using the bind function is
  called with argument V, the following steps are taken: */
function HasInstanceBind(F, V) [
  "15.3.4.5.3",
  "When the [[HasInstance]] internal method of a function object <var>F</var>, that was created using the bind function
  is called with argument <var>V</var>, the following steps are taken:",
  "",
  "[[HasInstance]]"
] {
  /* 1. Let target be the value of F’s [[TargetFunction]] internal property. */
  target := getInternalProperty(F, "TargetFunction");
  /* 2. If target has no [[HasInstance]] internal method, a TypeError exception is thrown. */
  if (!("HasInstance" in_obj target)) {
    throw TypeErrorConstructorInternal()
  };
  /* 3. Return the result of calling the [[HasInstance]] internal method of target providing V as the argument. */
  return {target.HasInstance}(target, V)
};

/* 15.3.5.3 [[HasInstance]] (V) */
/* Assume F is a Function object. */
/* When the [[HasInstance]] internal method of F is called with value V, the following steps are taken: */
function HasInstance(F, V) [
  "15.3.5.3",
  "Assume <var>F</var> is a Function object.</p>
  <p>When the [[HasInstance]] internal method of <var>F</var> is called with value <var>V</var>, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span> Function objects created using <code>Function.prototype.bind</code>
  have a different implementation of [[HasInstance]] defined in <a href=\"#sec-15.3.4.5.3\">15.3.4.5.3</a>.</p></div>",
  "[[HasInstance]]"
] {
  /* 1. If V is not an object, return false. */
  if (!(Type(V) = "Object")) {
    return false
  };
  /* 2. Let O be the result of calling the [[Get]] internal method of F with property name "prototype". */
  O := {F.Get}(F, "prototype");
  /* 3. If Type(O) is not Object, throw a TypeError exception. */
  if (!(Type(O) = "Object")) {
    throw TypeErrorConstructorInternal()
  };
  /* 4. Repeat */
  repeat {
    /* a. Let V be the value of the [[Prototype]] internal property of V. */
    V := getInternalProperty(V, "Prototype");
    /* b. If V is null, return false. */
    if (V = 'null) {
      return false
    };
    /* c. If O and V refer to the same object, return true. */
    if (sameObject(O, V)) {
      return true
    }
  }

  /* NOTE Function objects created using Function.prototype.bind have a different implementation of
          [[HasInstance]] defined in 15.3.4.5.3. */
};

/* 15.3.5.4 [[Get]] (P) */
/* Function objects use a variation of the [[Get]] internal method used for other native ECMAScript objects (8.12.3). */
/* Assume F is a Function object. When the [[Get]] internal method of F is called with property name P, the
  following steps are taken: */
function GetF(F, P) [
  "15.3.5.4",
  "Function objects use a variation of the [[Get]] internal method used for other native ECMAScript objects (<a href=\"#sec-8.12.3\">8.12.3</a>).</p>
  <p>Assume <var>F</var> is a Function object. When the [[Get]] internal method of <var>F</var> is called with property name
  <var>P</var>, the following steps are taken:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span> Function objects created using <code>Function.prototype.bind</code> use the default
  [[Get]] internal method.</p></div>",
  "[[Get]]"
] {
  /* 1. Let v be the result of calling the default [[Get]] internal method (8.12.3) on F passing P as the property name
        argument. */
  v := Get(F, P);
  /* 2. If P is "caller" and v is a strict mode Function object, throw a TypeError exception. */
  if ((P = "caller") &&& isStrictFunctionObject(v)) {
    throw TypeErrorConstructorInternal()
  };
  /* 3. Return v. */
  return v

  /* NOTE Function objects created using Function.prototype.bind use the default [[Get]] internal method. */
};

/* 11 Expressions */
function JS_Interpreter_Expr(e, scope) [
  "11",
  "",
  "",
  "Expressions"
] {
  match e with
  | default -> {
    return JS_Interpreter_LeftHandSide_Expressions(e, scope)
  }
};

/* 11.2 Left-Hand-Side Expressions */
function JS_Interpreter_LeftHandSide_Expressions(e, scope) [
  "11.2",
  "",
  "",
  "Left-Hand-Side Expressions"
] {
  match e with
  /* 11.2.1 Property Accessors */
  /* The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows: */
  | { type: "MemberExpression", object: MemberExpression, property: Expression } [
    "11.2.1",
    "",
    "<span class=\"nt\">MemberExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">MemberExpression</span>
    <code class=\"t\">[</code> <span class=\"nt\">Expression</span> <code class=\"t\">]</code>",
    "The production <span class=\"prod\"><span class=\"nt\">CallExpression</span> <span class=\"geq\">:</span>
    <span class=\"nt\">CallExpression</span> <code class=\"t\">[</code> <span class=\"nt\">Expression</span> <code class=\"t\">]</code></span>
    is evaluated in exactly the same manner, except that the contained <span class=\"nt\">CallExpression</span> is evaluated in step 1.",
    "Property Accessors"
  ] -> {
    /* 1. Let baseReference be the result of evaluating MemberExpression. */
    baseReference := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let baseValue be GetValue(baseReference). */
    baseValue := GetValue(baseReference);
    /* 3. Let propertyNameReference be the result of evaluating Expression. */
    propertyNameReference := JS_Interpreter_Expr(Expression, scope);
    /* 4. Let propertyNameValue be GetValue(propertyNameReference). */
    propertyNameValue := GetValue(propertyNameReference);
    /* 5. Call CheckObjectCoercible(baseValue). */
    CheckObjectCoercible(baseValue);
    /* 6. Let propertyNameString be ToString(propertyNameValue). */
    propertyNameString := ToString(propertyNameValue);
    /* 7. If the syntactic production that is being evaluated is contained in strict mode code,
          let strict be true, else let strict be false. */
    if (isContainedInStrictCode(scope)) {
      strict := true
    } else {
      strict := false
    };
    /* 8. Return a value of type Reference whose base value is baseValue and whose referenced name is
          propertyNameString, and whose strict mode flag is strict. */
    return newPropertyReference(baseValue, propertyNameString, strict)
  }
  /* 11.2.2 The new Operator */
  /* The production MemberExpression : new MemberExpression Arguments is evaluated as follows: */
  | { type: "NewExpression", callee: MemberExpression, arguments: Arguments } [
    "11.2.2",
    "",
    "<span class=\"nt\">MemberExpression</span> <span class=\"geq\">:</span> <code class=\"t\">new</code> <span class=\"nt\">MemberExpression</span> <span class=\"nt\">Arguments</span>",
    "",
    "The <span style=\"font-family: monospace\">new</span> Operator"
  ] -> {
    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let constructor be GetValue(ref). */
    constructor := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(constructor) is not Object, throw a TypeError exception. */
    if (!(Type(constructor) = "Object")) {
      throw TypeErrorConstructorInternal()
    };
    /* 5. If constructor does not implement the [[Construct]] internal method, throw a TypeError exception. */
    if (!("Construct" in_obj constructor)) {
      throw TypeErrorConstructorInternal()
    };
    /* 6. Return the result of calling the [[Construct]] internal method on constructor, providing the list argList as the
          argument values. */
    return {constructor.Construct}(scope, ref, constructor, argList)
  }
  /* 11.2.3 Function Calls */
  /* The production CallExpression : MemberExpression Arguments is evaluated as follows: */
  | { type: "CallExpression", callee: MemberExpression, arguments: Arguments } [
    "11.2.3",
    "",
    "<span class=\"nt\">CallExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">MemberExpression</span> <span class=\"nt\">Arguments</span>",
    "The production <span class=\"prod\"><span class=\"nt\">CallExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">CallExpression</span> <span class=\"nt\">Arguments</span></span>
    is evaluated in exactly the same manner, except that the contained <span class=\"nt\">CallExpression</span> is evaluated in step 1.</p>
    <div class=\"note\"><p><span class=\"nh\">NOTE</span> The returned result will never be of type <a href=\"#sec-8.7\">Reference</a> if
    <var>func</var> is a native ECMAScript object. Whether calling a host object can return a value of type <a href=\"#sec-8.7\">Reference</a> is implementation-dependent.
    If a value of type <a href=\"#sec-8.7\">Reference</a> is returned, it must be a non-strict Property <a href=\"#sec-8.7\">Reference</a>.</p></div>",
    "Function Calls"
  ] -> {
    /* 1. Let ref be the result of evaluating MemberExpression. */
    ref := JS_Interpreter_Expr(MemberExpression, scope);
    /* 2. Let func be GetValue(ref). */
    func := GetValue(ref);
    /* 3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (see 11.2.4). */
    argList := JS_Interpreter_Arguments(Arguments, scope);
    /* 4. If Type(func) is not Object, throw a TypeError exception. */
    if (!(Type(func) = "Object")) {
      throw TypeErrorConstructorInternal()
    };
    /* 5. If IsCallable(func) is false, throw a TypeError exception. */
    if (IsCallable(func) = false) {
      throw TypeErrorConstructorInternal()
    };
    /* 6. If Type(ref) is Reference, then */
    if (Type(ref) = "Reference") ["after-same:, then"] {
      /* a. If IsPropertyReference(ref) is true, then */
      if (IsPropertyReference(ref) = true) ["after-same: then"] {
        /* i. Let thisValue be GetBase(ref). */
        thisValue := GetBase(ref)
      }
      /* b. Else, the base of ref is an Environment Record */
      else ["after-same:, the base of <i>ref</i> is an <a href=\"#sec-10.2.1\">Environment Record</a>, so"] {
        /* i. Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). */
        thisValue := ImplicitThisValue(GetBase(ref))
      }
    }
    /* 7. Else, Type(ref) is not Reference. */
    else ["after-same:, <a href=\"#sec-8\">Type</a>(<i>ref</i>) is not <a href=\"#sec-8.7\">Reference</a>"] {
      /* a. Let thisValue be undefined. */
      thisValue := 'undefined
    };
    /* 8. Return the result of calling the [[Call]] internal method on func, providing thisValue as the this value
          and providing the list argList as the argument values. */
    return {func.Call}(scope, ref, func, thisValue, argList)
  }
  /* 11.2.5 Function Expressions */
  /* The production MemberExpression : FunctionExpression is evaluated as follows: */
  | { type: "FunctionExpression", id: Identifier, params: FormalParameterList, body: FunctionBody } [
    "11.2.5",
    "",
    "<span class=\"nt\">MemberExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">FunctionExpression</span>",
    "",
    "Function Expressions"
  ] [
    "e:<i>FunctionExpression</i>"
  ] -> {
    /* 1. Return the result of evaluating FunctionExpression. */
    return JS_Interpreter_FunctionExpression(e, scope)
  }
  | default -> {
    return JS_Interpreter_Postfix_Expressions(e, scope)
  }
};

/* 11.3 Postfix Expressions */
function JS_Interpreter_Postfix_Expressions(e, scope) [
  "11.3",
  "",
  "",
  "Postfix Expressions"
] {
  match e with
  /* 11.3.1 Postfix Increment Operator */
  /* The production PostfixExpression : LeftHandSideExpression [no LineTerminator here] ++ is evaluated as follows: */
  | { type: "UpdateExpression", operator: "++", argument: LeftHandSideExpression, prefix: false } [
    "11.3.1",
    "",
    "<span class=\"nt\">PostfixExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LeftHandSideExpression</span>
    <span class=\"grhsannot\">[no <span class=\"nt\">LineTerminator</span> here]</span> <code class=\"t\">++</code></span>",
    "",
    "Postfix Increment Operator"
  ] -> {
    /* 1. Let lhs be the result of evaluating LeftHandSideExpression. */
    lhs := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(lhs) is Reference is true */
      (Type(lhs) = "Reference") &&
      /* IsStrictReference(lhs) is true */
      (IsStrictReference(lhs) = true) &&
      /* Type(GetBase(lhs)) is Environment Record */
      (Type(GetBase(lhs)) = "EnvironmentRecord") &&
      /* GetReferencedName(lhs) is either "eval" or "arguments" */
      ((GetReferencedName(lhs) = "eval") || (GetReferencedName(lhs) = "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal()
    };
    /* 3. Let oldValue be ToNumber(GetValue(lhs)). */
    oldValue := ToNumber(GetValue(lhs));
    /* 4. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator
          (see 11.6.3). */
    gen_wrapper ["after-same:, using the same rules as for the <code>+</code> operator (<a href=\"#sec-11.6.3\">see 11.6.3</a>)"] {
      newValue := oldValue + 1.
    };
    /* 5. Call PutValue(lhs, newValue). */
    PutValue(lhs, newValue);
    /* 6. Return oldValue. */
    return oldValue
  }
  /* 11.3.2 Postfix Decrement Operator */
  /* The production PostfixExpression : LeftHandSideExpression [no LineTerminator here] -- is evaluated as follows: */
  | { type: "UpdateExpression", operator: "--", argument: LeftHandSideExpression, prefix: false } [
    "11.3.2",
    "",
    "<span class=\"nt\">PostfixExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LeftHandSideExpression</span>
    <span class=\"grhsannot\">[no <span class=\"nt\">LineTerminator</span> here]</span> <code class=\"t\">--</code></span>",
    "",
    "Postfix Decrement Operator"
  ] -> {
    /* 1. Let lhs be the result of evaluating LeftHandSideExpression. */
    lhs := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(lhs) is Reference is true */
      (Type(lhs) = "Reference") &&
      /* IsStrictReference(lhs) is true */
      (IsStrictReference(lhs) = true) &&
      /* Type(GetBase(lhs)) is Environment Record */
      (Type(GetBase(lhs)) = "EnvironmentRecord") &&
      /* GetReferencedName(lhs) is either "eval" or "arguments" */
      ((GetReferencedName(lhs) = "eval") || (GetReferencedName(lhs) = "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal()
    };
    /* 3. Let oldValue be ToNumber(GetValue(lhs)). */
    oldValue := ToNumber(GetValue(lhs));
    /* 4. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the -
          operator (11.6.3). */
    gen_wrapper ["after-same:, using the same rules as for the <code>-</code> operator (<a href=\"#sec-11.6.3\">11.6.3</a>)"] {
      newValue := oldValue - 1.
    };
    /* 5. Call PutValue(lhs, newValue). */
    PutValue(lhs, newValue);
    /* 6. Return oldValue. */
    return oldValue
  }
  | default -> {
    return JS_Interpreter_Unary_Operators(e, scope)
  }
};

function JS_Interpreter_Unary_Operators(e, scope) [
  "11.4",
  "",
  "",
  "Unary Operators"
] {
  match e with
  /* 11.4.1 The delete Operator */
  /* The production UnaryExpression : delete UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "delete", argument: UnaryExpression } [
    "11.4.1",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">delete</code> <span class=\"nt\">UnaryExpression</span>",
    "<div class=\"note\"><p><span class=\"nh\">NOTE</span> When a <code>delete</code> operator occurs within <a href=\"#sec-10.1.1\">strict mode
    code</a>, a <b>SyntaxError</b> exception is thrown if its <span class=\"nt\">UnaryExpression</span> is a direct reference to
    a variable, function argument, or function name. In addition, if a <code>delete</code> operator occurs within <a href=\"#sec-10.1.1\">strict mode code</a>
    and the property to be deleted has the attribute { [[Configurable]]: <b>false</b> }, a <b>TypeError</b> exception is thrown.</p></div>",
    "The <span style=\"font-family: monospace\">delete</span> Operator"
  ] -> {
    /* 1. Let ref be the result of evaluating UnaryExpression. */
    ref := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. If Type(ref) is not Reference, return true. */
    if (!(Type(ref) = "Reference")) {
      return true
    };
    /* 3. If IsUnresolvableReference(ref) then, */
    if (IsUnresolvableReference(ref)) ["after-same: then,"] {
      /* a. If IsStrictReference(ref) is true, throw a SyntaxError exception. */
      if (IsStrictReference(ref) = true) {
        throw SyntaxErrorConstructorInternal()
      }
      /* b. Else, return true. */
      else {
        return true
      }
    };
    /* 4. If IsPropertyReference(ref) is true, then */
    if (IsPropertyReference(ref) = true) ["after-same:, then"] {
      /* a. Return the result of calling the [[Delete]] internal method on ToObject(GetBase(ref)) providing
            GetReferencedName(ref) and IsStrictReference(ref) as the arguments. */
      obj := ToObject(GetBase(ref));
      return {obj.Delete}(obj, GetReferencedName(ref), IsStrictReference(ref))
    }
    /* 5. Else, ref is a Reference to an Environment Record binding, so */
    else ["after-same:, <i>ref</i> is a <a href=\"#sec-8.7\">Reference</a> to an <a href=\"#sec-10.2.1\">Environment Record</a> binding, so"] {
      /* a. If IsStrictReference(ref) is true, throw a SyntaxError exception. */
      if (IsStrictReference(ref) = true) {
        throw SyntaxErrorConstructorInternal()
      };
      /* b. Let bindings be GetBase(ref). */
      bindings := GetBase(ref);
      /* c. Return the result of calling the DeleteBinding concrete method of bindings, providing
            GetReferencedName(ref) as the argument. */
      return DeleteBinding(bindings, GetReferencedName(ref))
    }

    /* NOTE When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its
            UnaryExpression is a direct reference to a variable, function argument, or function name.
            In addition, if a delete operator occurs within strict mode code and the property to be deleted has
            the attribute { [[Configurable]]: false }, a TypeError exception is thrown. */
  }
  /* 11.4.2 The void Operator */
  /* The production UnaryExpression : void UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "void", argument: UnaryExpression } [
    "11.4.2",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">void</code> <span class=\"nt\">UnaryExpression</span>",
    "<div class=\"note\"><p><span class=\"nh\">NOTE</span> <a href=\"#sec-8.7.1\">GetValue</a> must be called even though its value is not used because
    it may have observable side-effects.</p></div>",
    "The <span style=\"font-family: monospace\">void</span> Operator"
  ] -> {
    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Call GetValue(expr). */
    GetValue(expr);
    /* 3. Return undefined. */
    return 'undefined
  }
  /* 11.4.3 The typeof Operator */
  /* The production UnaryExpression : typeof UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "typeof", argument: UnaryExpression } [
    "11.4.3",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">typeof</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "The <span style=\"font-family: monospace\">typeof</span> Operator"
  ] -> {
    /* 1. Let val be the result of evaluating UnaryExpression. */
    val := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. If Type(val) is Reference, then */
    if (Type(val) = "Reference") ["after-same:, then"] {
      /* a. If IsUnresolvableReference(val) is true, return "undefined". */
      if (IsUnresolvableReference(val) = true) {
        return "undefined"
      };
      /* b. Let val be GetValue(val). */
      val := GetValue(val)
    };
    /* 3. Return a String determined by Type(val) according to Table 20. */
    /* TODO 11.4.3.1; call to function */
    switch(Type(val)) [
      "Table 20 — typeof Operator Results"
    ] {
      case "Undefined": { return "undefined" }
      case "Null":      { return "object" }
      case "Boolean":   { return "boolean" }
      case "Number":    { return "number" }
      case "String":    { return "string" }
      case "Object": {
        /* Object (native and does not implement [[Call]]) | "object" */
        if (!("Call" in_obj val)) {
          return "object"
        }
        /* Object (native or host and does implement [[Call]]) | "function" */
        else {
          return "function"
        }
      }
    }
  }
  /* 11.4.4 Prefix Increment Operator */
  /* The production UnaryExpression : ++ UnaryExpression is evaluated as follows: */
  | { type: "UpdateExpression", operator: "++", argument: UnaryExpression, prefix: true } [
    "11.4.4",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">++</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "Prefix Increment Operator"
  ] -> {

    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(expr) is Reference is true */
      (Type(expr) = "Reference") &&
      /* IsStrictReference(expr) is true */
      (IsStrictReference(expr) = true) &&
      /* Type(GetBase(expr)) is Environment Record */
      (Type(GetBase(expr)) = "EnvironmentRecord") &&
      /* GetReferencedName(expr) is either "eval" or "arguments" */
      ((GetReferencedName(expr) = "eval") || (GetReferencedName(expr) = "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal()
    };
    /* 3. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 4. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator
          (see 11.6.3). */
    gen_wrapper ["after-same:, using the same rules as for the <code>+</code> operator (<a href=\"#sec-11.6.3\">see 11.6.3</a>)"] {
      newValue := oldValue + 1.
    };
    /* 5. Call PutValue(expr, newValue). */
    PutValue(expr, newValue);
    /* 6. Return newValue.*/
    return newValue
  }
  /* 11.4.5 Prefix Decrement Operator */
  /* The production UnaryExpression : -- UnaryExpression is evaluated as follows: */
  | { type: "UpdateExpression", operator: "--", argument: UnaryExpression, prefix: true } [
    "11.4.5",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">--</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "Prefix Decrement Operator"
  ] -> {
    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Throw a SyntaxError exception if the following conditions are all true: */
    if (
      /* Type(expr) is Reference is true */
      (Type(expr) = "Reference") &&
      /* IsStrictReference(expr) is true */
      (IsStrictReference(expr) = true) &&
      /* Type(GetBase(expr)) is Environment Record */
      (Type(GetBase(expr)) = "EnvironmentRecord") &&
      /* GetReferencedName(expr) is either "eval" or "arguments" */
      ((GetReferencedName(expr) = "eval") || (GetReferencedName(expr) = "arguments"))
    ) {
      throw SyntaxErrorConstructorInternal()
    };
    /* 3. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 4. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the -
          operator (see 11.6.3). */
    gen_wrapper ["after-same:, using the same rules as for the <code>-</code> operator (<a href=\"#sec-11.6.3\">11.6.3</a>)"] {
      newValue := oldValue - 1.
    };
    /* 5. Call PutValue(expr, newValue). */
    PutValue(expr, newValue);
    /* 6. Return newValue.*/
    return newValue
  }
  /* 11.4.6 Unary + Operator */
  /* The unary + operator converts its operand to Number type. */
  /* The production UnaryExpression : + UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "+", argument: UnaryExpression } [
    "11.4.6",
    "The unary + operator converts its operand to Number type.",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">+</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "Unary <span style=\"font-family: monospace\">+</span> Operator"
  ] -> {
    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Return ToNumber(GetValue(expr)). */
    return ToNumber(GetValue(expr))
  }
  /* 11.4.7 Unary - Operator */
  /* The unary - operator converts its operand to Number type and then negates it. Note that negating +0
      produces -0, and negating -0 produces +0. */
  /* The production UnaryExpression : - UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "-", argument: UnaryExpression } [
    "11.4.7",
    "The unary <code>-</code> operator converts its operand to Number type and then negates it. Note that negating <b>+0</b>
    produces <b>−0</b>, and negating <b>−0</b> produces <b>+0</b>.",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">-</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "Unary <span style=\"font-family: monospace\">-</span> Operator"
  ] -> {
    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToNumber(GetValue(expr)). */
    oldValue := ToNumber(GetValue(expr));
    /* 3. If oldValue is NaN, return NaN. */
    if (oldValue = NaN) {
      return NaN
    };
    /* 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign. */
    gen_wrapper ["after-same:; that is, compute a Number with the same magnitude but opposite sign"] {
      return -(oldValue)
    }
  }
  /* 11.4.8 Bitwise NOT Operator ( ~ ) */
  /* The production UnaryExpression : ~ UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "~", argument: UnaryExpression } [
    "11.4.8",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">~</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "Bitwise NOT Operator ( <span style=\"font-family: monospace\">~</span> )"
  ] -> {
    /* Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* Let oldValue be ToInt32(GetValue(expr)). */
    oldValue := ToInt32(GetValue(expr));
    /* Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer. */
    return ~oldValue
  }
  /* 11.4.9 Logical NOT Operator ( ! ) */
  /* The production UnaryExpression : ! UnaryExpression is evaluated as follows: */
  | { type: "UnaryExpression", operator: "!", argument: UnaryExpression } [
    "11.4.9",
    "",
    "<span class=\"nt\">UnaryExpression</span> <span class=\"geq\">:</span> <code class=\"t\">!</code> <span class=\"nt\">UnaryExpression</span>",
    "",
    "Logical NOT Operator ( <span style=\"font-family: monospace\">!</span> )"
  ] -> {
    /* 1. Let expr be the result of evaluating UnaryExpression. */
    expr := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 2. Let oldValue be ToBoolean(GetValue(expr)). */
    oldValue := ToBoolean(GetValue(expr));
    /* 3. If oldValue is true, return false. */
    if (oldValue = true) {
      return false
    };
    /* 4. Return true. */
    return true
  }
  | default -> {
    return JS_Interpreter_Multiplicative_Operators(e, scope)
  }
};

/* 11.5 Multiplicative Operators */
function JS_Interpreter_Multiplicative_Operators(e, scope) [
  "11.5",
  "",
  "",
  "Multiplicative Operators"
] {
  match e with
  /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
      of the operators in the above definitions, is evaluated as follows: */
  | { type: "BinaryExpression", operator: "*", left: MultiplicativeExpression, right: UnaryExpression } [
    "11.5.1",
    "",
    "<span class=\"nt\">MultiplicativeExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">MultiplicativeExpression</span>
    <code class=\"t\">@</code> <span class=\"nt\">UnaryExpression</span></span> , where @ stands for one of the operators in the above definitions",
    "",
    null
  ] -> {
    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.1 Applying the * Operator */
    /* The * operator performs multiplication, producing the product of its operands. Multiplication is commutative.
       Multiplication is not always associative in ECMAScript, because of finite precision.
       The result of a floating-point multiplication is governed by the rules of IEEE 754 binary double-precision
       arithmetic: */

    /* If either operand is NaN, the result is NaN. */
    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* Multiplication of an infinity by a zero results in NaN. */
    /* Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above. */
    /* Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value
       using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign.
       If the magnitude is too small to represent, the result is then a zero of appropriate sign.
       The ECMAScript language requires support of gradual underflow as defined by IEEE 754. */
    return applyingTheMultiplicationOperator(leftNum, rightNum)
  }
  | { type: "BinaryExpression", operator: "/", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.2 Applying the / Operator */
    /* The / operator performs division, producing the quotient of its operands. The left operand is the dividend and
       the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all
       division operations are double-precision floating-point numbers. The result of division is determined by the
       specification of IEEE 754 arithmetic: */

    /* If either operand is NaN, the result is NaN. */
    /* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs. */
    /* Division of an infinity by an infinity results in NaN. */
    /* Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above. */
    /* Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above. */
    /* Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above. */
    /* Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above. */
    /* Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above. */

    /* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and rounded
       to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent,
       the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the
       operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of
       gradual underflow as defined by IEEE 754. */
    return applyingTheDivisionOperator(leftNum, rightNum)
  }
  | { type: "BinaryExpression", operator: "%", left: MultiplicativeExpression, right: UnaryExpression } -> {
    /* The production MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression, where @ stands for one
       of the operators in the above definitions, is evaluated as follows: */

    /* 1. Let left be the result of evaluating MultiplicativeExpression. */
    left := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 2. Let leftValue be GetValue(left). */
    leftValue := GetValue(left);
    /* 3. Let right be the result of evaluating UnaryExpression. */
    right := JS_Interpreter_Expr(UnaryExpression, scope);
    /* 4. Let rightValue be GetValue(right). */
    rightValue := GetValue(right);
    /* 5. Let leftNum be ToNumber(leftValue). */
    leftNum := ToNumber(leftValue);
    /* 6. Let rightNum be ToNumber(rightValue). */
    rightNum := ToNumber(rightValue);
    /* 7. Return the result of applying the specified operation (*, /, or %) to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2, 11.5.3. */

    /* 11.5.3 Applying the % Operator */
    /* The % operator yields the remainder of its operands from an implied division; the left operand is the dividend
       and the right operand is the divisor. */
    /* NOTE In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-
       point operands. */
    /* The result of a floating-point remainder operation as computed by the % operator is not the same as the
       ―remainder‖ operation defined by IEEE 754. The IEEE 754 ―remainder‖ operation computes the remainder
       from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual
       integer remainder operator. Instead the ECMAScript language defines % on floating-point operations to
       behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the
       C library function fmod. */
    /* The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic: */

    /* If either operand is NaN, the result is NaN. */
    /* The sign of the result equals the sign of the dividend. */
    /* If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN. */
    /* If the dividend is finite and the divisor is an infinity, the result equals the dividend. */
    /* If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the
       dividend. */
    /* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the
       floating-point remainder r from a dividend n and a divisor d is defined by the mathematical
       relation r = n  (d  q) where q is an integer that is negative only if n/d is negative and
       positive only if n/d is positive, and whose magnitude is as large as possible without
       exceeding the magnitude of the true mathematical quotient of n and d. r is computed and
       rounded to the nearest representable value using IEEE 754 round -to-nearest mode. */

    return applyingTheRemainderOperator(leftNum, rightNum)
  }
  | default -> {
    return JS_Interpreter_Additive_Operators(e, scope)
  }
};

/* 11.6 Additive Operators */
function JS_Interpreter_Additive_Operators(e, scope) [
  "11.6",
  "",
  "",
  "Additive Operators"
] {
  match e with
  /* 11.6.1 The Addition operator ( + ) */
  /* The addition operator either performs string concatenation or numeric addition. */
  /* The production AdditiveExpression : AdditiveExpression + MultiplicativeExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "+", left: AdditiveExpression, right: MultiplicativeExpression } [
    "11.6.1",
    "The addition operator either performs string concatenation or numeric addition.",
    "<span class=\"nt\">AdditiveExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">AdditiveExpression</span> <code class=\"t\">+</code> <span class=\"nt\">MultiplicativeExpression</span>",
    "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> No hint is provided in the calls to <a href=\"#sec-9.1\">ToPrimitive</a> in steps 5 and 6.
    All native ECMAScript objects except Date objects handle the absence of a hint as if the hint Number were given; Date
    objects handle the absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in
    some other manner.</p></div>
    <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> Step 7 differs from step 3 of the comparison algorithm for the relational operators (<a href=\"#sec-11.8.5\">11.8.5</a>),
    by using the logical-or operation instead of the logical-and operation.</p></div>",
    "The Addition operator ( <span style=\"font-family: monospace\">+</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lprim be ToPrimitive(lval). */
    lprim := ToPrimitive(lval, null);
    /* 6. Let rprim be ToPrimitive(rval). */
    rprim := ToPrimitive(rval, null);
    /* 7. If Type(lprim) is String or Type(rprim) is String, then */
    if ((Type(lprim) = "String") || (Type(rprim) = "String")) {
      /* a. Return the String that is the result of concatenating ToString( lprim) followed by ToString(rprim) */
      return s_concat [ToString(lprim), ToString(rprim)]
    };
    /* 8. Return the result of applying the addition operation to ToNumber( lprim) and ToNumber(rprim). See the
          Note below 11.6.3. */
    return applyingTheAdditionOperation(ToNumber(lprim), ToNumber(rprim))

    /* NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6. All native ECMAScript objects
              except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the
              absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner. */

    /* NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the relational operators (11.8.5), by using the
              logical-or operation instead of the logical-and operation. */
  }
  /* 11.6.2 The Subtraction Operator ( - ) */
  /* The production AdditiveExpression : AdditiveExpression - MultiplicativeExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "-", left: AdditiveExpression, right: MultiplicativeExpression } [
    "11.6.2",
    "",
    "<span class=\"nt\">AdditiveExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">AdditiveExpression</span> <code class=\"t\">-</code> <span class=\"nt\">MultiplicativeExpression</span>",
    "",
    "The Subtraction operator ( <span style=\"font-family: monospace\">-</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating AdditiveExpression. */
    lref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating MultiplicativeExpression. */
    rref := JS_Interpreter_Expr(MultiplicativeExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToNumber(lval). */
    lnum := ToNumber(lval);
    /* 6. Let rnum be ToNumber(rval). */
    rnum := ToNumber(rval);
    /* 7. Return the result of applying the subtraction operation to lnum and rnum.
          See the note below 11.6.3. */
    return applyingTheSubtractionOperation(lnum, rnum)
  }
  | default -> {
    return JS_Interpreter_Bitwise_Shift_Operators(e, scope)
  }
};

/* 11.7 Bitwise Shift Operators */
function JS_Interpreter_Bitwise_Shift_Operators (e, scope) [
  "11.7",
  "",
  "",
  "Bitwise Shift Operators"
] {
  match e with
  /* 11.7.1 The Left Shift Operator ( << ) */
  /* Performs a bitwise left shift operation on the left operand by the amount specified by the right operand. */
  /* The production ShiftExpression : ShiftExpression << AdditiveExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "<<", left: ShiftExpression, right: AdditiveExpression } [
    "11.7.1",
    "Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.",
    "<span class=\"nt\">ShiftExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">ShiftExpression</span> <code class=\"t\">&lt;&lt;</code> <span class=\"nt\">AdditiveExpression</span>",
    "",
    "The Left Shift Operator ( <span style=\"font-family: monospace\">&lt;&lt;</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer. */
    return lnum << shiftCount
  }
  /* 11.7.2 The Signed Right Shift Operator ( >> ) */
  /* Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the
      right operand. */
  /* The production ShiftExpression : ShiftExpression >> AdditiveExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: ">>", left: ShiftExpression, right: AdditiveExpression } [
    "11.7.2",
    "Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.",
    "<span class=\"nt\">ShiftExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">ShiftExpression</span> <code class=\"t\">&gt;&gt;</code> <span class=\"nt\">AdditiveExpression</span>",
    "",
    "The Signed Right Shift Operator ( <span style=\"font-family: monospace\">&gt;&gt;</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most
          significant bit is propagated. The result is a signed 32-bit integer. */
    return lnum >> shiftCount
  }
  /* 11.7.3 The Unsigned Right Shift Operator ( >>> ) */
  /* Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by
      the right operand. */
  /* The production ShiftExpression : ShiftExpression >>> AdditiveExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: ">>>", left: ShiftExpression, right: AdditiveExpression } [
    "11.7.3",
    "Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.",
    "<span class=\"nt\">ShiftExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">ShiftExpression</span> <code class=\"t\">&gt;&gt;&gt;</code> <span class=\"nt\">AdditiveExpression</span>",
    "",
    "The Unsigned Right Shift Operator ( <span style=\"font-family: monospace\">&gt;&gt;&gt;</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating ShiftExpression. */
    lref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AdditiveExpression. */
    rref := JS_Interpreter_Expr(AdditiveExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToUint32(rval). */
    rnum := ToUint32(rval);
    /* 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is,
          compute rnum & 0x1F. */
    shiftCount := maskOutBits(rnum);
    /* 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are
          filled with zero. The result is an unsigned 32-bit integer. */
    return lnum >>> shiftCount
  }
  | default -> {
    return JS_Interpreter_Relational_Operators(e, scope)
  }
};

/* 11.8 Relational Operators */
/* The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship
  named by the operator holds between its two operands.
  The RelationalExpressionNoIn productions are evaluated in the same manner as the RelationalExpression
  productions except that the contained RelationalExpressionNoIn is evaluated instead of the contained
  RelationalExpression. */
function JS_Interpreter_Relational_Operators(e, scope) [
  "11.8",
  "",
  "",
  "Relational Operators"
] {
  match e with
  /* 11.8.1 The Less-than Operator ( < ) */
  /* The production RelationalExpression : RelationalExpression < ShiftExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "<", left: RelationalExpression, right: ShiftExpression } [
    "11.8.1",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">&lt;</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Less-than Operator ( <span style=\"font-family: monospace\">&lt;</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison lval < rval. (see 11.8.5) */
    r := AbstractRelationalComparison(lval, rval, true);
    /* 6. If r is undefined, return false. Otherwise, return r.*/
    if (r = 'undefined) {
      return false
    };

    gen_wrapper ["before-same:Otherwise, "] {
      return r
    }
  }
  /* 11.8.2 The Greater-than Operator ( > ) */
  /* The production RelationalExpression : RelationalExpression > ShiftExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: ">", left: RelationalExpression, right: ShiftExpression } [
    "11.8.2",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">&gt;</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Greater-than Operator ( <span style=\"font-family: monospace\">&gt;</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false. (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is undefined, return false. Otherwise, return r. */
    if (r = 'undefined) {
      return false
    };

    gen_wrapper ["before-same:Otherwise, "] {
      return r
    }
  }
  /* 11.8.3 The Less-than-or-equal Operator ( <= ) */
  /* The production RelationalExpression : RelationalExpression <= ShiftExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "<=", left: RelationalExpression, right: ShiftExpression } [
    "11.8.3",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">&lt;=</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Less-than-or-equal Operator ( <span style=\"font-family: monospace\">&lt;=</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison rval < lval with LeftFirst equal to false.
          (see 11.8.5). */
    r := AbstractRelationalComparison(rval, lval, false);
    /* 6. If r is true or undefined, return false. Otherwise, return true. */
    if ((r = true) || (r = 'undefined)) {
      return false
    };

    gen_wrapper ["before-same:Otherwise, "] {
      return true
    }
  }
  /* 11.8.4 The Greater-than-or-equal Operator ( >= ) */
  /* The production RelationalExpression : RelationalExpression >= ShiftExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: ">=", left: RelationalExpression, right: ShiftExpression } [
    "11.8.4",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">&gt;=</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Greater-than-or-equal Operator ( <span style=\"font-family: monospace\">&gt;=</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract relational comparison lval < rval. (see 11.8.5) */
    r := AbstractRelationalComparison(lval, rval, true);
    /* 6. If r is true or undefined, return false. Otherwise, return true. */
    if ((r = true) || (r = 'undefined)) {
      return false
    };

    gen_wrapper ["before-same:Otherwise, "] {
      return true
    }
  }
  /* 11.8.6 The instanceof operator */
  /* The production RelationalExpression: RelationalExpression instanceof ShiftExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "instanceof", left: RelationalExpression, right: ShiftExpression } [
    "11.8.6",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">instanceof</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The instanceof operator"
  ] -> {
    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. If Type(rval) is not Object, throw a TypeError exception. */
    if (!(Type(rval) = "Object")) {
      throw TypeErrorConstructorInternal()
    };
    /* 6. If rval does not have a [[HasInstance]] internal method, throw a TypeError exception. */
    if (!("HasInstance" in_obj rval)) {
      throw TypeErrorConstructorInternal()
    };
    /* 7. Return the result of calling the [[HasInstance]] internal method of rval with argument lval. */
    return {rval.HasInstance}(rval, lval)
  }
  /* 11.8.7 The in operator */
  /* The production RelationalExpression : RelationalExpression in ShiftExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "in", left: RelationalExpression, right: ShiftExpression } [
    "11.8.7",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">in</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The in operator"
  ] -> {
    /* 1. Let lref be the result of evaluating RelationalExpression. */
    lref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating ShiftExpression. */
    rref := JS_Interpreter_Expr(ShiftExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. If Type(rval) is not Object, throw a TypeError exception. */
    if (!(Type(rval) = "Object")) {
      throw TypeErrorConstructorInternal()
    };
    /* 6. Return the result of calling the [[HasProperty]] internal method of rval with argument ToString(lval). */
    return {rval.HasProperty}(rval, ToString(lval))
  }
  | default -> {
    return JS_Interpreter_Equality_Operators(e, scope)
  }
};

/*
  11.8.5 The Abstract Relational Comparison Algorithm

  The comparison x < y, where x and y are values, produces true, false, or undefined (which indicates that at
  least one operand is NaN). In addition to x and y the algorithm takes a Boolean flag named LeftFirst as a
  parameter. The flag is used to control the order in which operations with potentially visible side-effects are
  performed upon x and y. It is necessary because ECMAScript specifies left to right evaluation of expressions.
  The default value of LeftFirst is true and indicates that the x parameter corresponds to an expression that
  occurs to the left of the y parameter‘s corresponding expression. If LeftFirst is false, the reverse is the case
  and operations must be performed upon y before x. Such a comparison is performed as follows:

    NOTE 1    Step 3 differs from step 7 in the algorithm for the addition operator + (11.6.1) in using and instead of or.
    NOTE 2    The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no
              attempt to use the more complex, semantically oriented definitions of character or string equality and collating order
              defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard
              could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form. Also, note that for
              strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from
              that on sequences of code point values.
*/
function AbstractRelationalComparison(x, y, LeftFirst) [
  "11.8.5",
  "The comparison <var>x</var> &lt; <var>y</var>, where <var>x</var> and <var>y</var> are values, produces <b>true</b>,
  <b>false</b>, or <b>undefined</b> (which indicates that at least one operand is <b>NaN</b>). In addition to <var>x</var> and
  <var>y</var> the algorithm takes a Boolean flag named <span class=\"nt\">LeftFirst</span> as a parameter. The flag is used to
  control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and
  <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of
  <span class=\"nt\">LeftFirst</span> is <b>true</b> and indicates that the <var>x</var> parameter corresponds to an expression
  that occurs to the left of the <var>y</var> parameter’s corresponding expression. If <span class=\"nt\">LeftFirst</span>
  is <b>false</b>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. Such a
  comparison is performed as follows:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> Step 3 differs from step 7 in the algorithm for the addition operator <code>+</code>
  (<a href=\"#sec-11.6.1\">11.6.1</a>) in using and instead of or.</p></div>
  <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> The comparison of Strings uses a simple lexicographic ordering on sequences of code unit
  values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and
  collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the
  Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.
  Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit
  values differs from that on sequences of code point values.</p></div>",
  "The Abstract Relational Comparison Algorithm"
] [
  "LeftFirst:the <i>LeftFirst</i> flag"
] {
  /* 1. If the LeftFirst flag is true, then */
  if (LeftFirst = true) ["after-same:, then"] {
    /* a. Let px be the result of calling ToPrimitive(x, hint Number). */
    px := ToPrimitive(x, 'Number);
    /* b. Let py be the result of calling ToPrimitive(y, hint Number). */
    py := ToPrimitive(y, 'Number)
  }
  /* 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation */
  else ["after-same: the order of evaluation needs to be reversed to preserve left to right evaluation"] {
    /* a. Let py be the result of calling ToPrimitive(y, hint Number). */
    py := ToPrimitive(y, 'Number);
    /* b. Let px be the result of calling ToPrimitive(x, hint Number). */
    px := ToPrimitive(x, 'Number)
  };
  /* 3. If it is not the case that both Type(px) is String and Type(py) is String, then */
  if (!((Type(px) = "String") && (Type(py) = "String"))) ["after-same:, then"] {
    /* a. Let nx be the result of calling ToNumber(px). Because px and py are primitive values evaluation order is not important. */
    gen_wrapper ["after-same:. Because <i>px</i> and <i>py</i> are primitive values evaluation order is not important"] {
      nx := ToNumber(px)
    };
    /* b. Let ny be the result of calling ToNumber(py). */
    ny := ToNumber(py);
    /* c. If nx is NaN, return undefined. */
    if (nx = NaN) { return 'undefined };
    /* d. If ny is NaN, return undefined. */
    if (ny = NaN) { return 'undefined };
    /* e. If nx and ny are the same Number value, return false. */
    if (sameNumber(nx, ny)) { return false };
    /* f. If nx is +0 and ny is -0, return false. */
    if (isZero(nx) && isMinusZero(ny)) { return false };
    /* g. If nx is -0 and ny is +0, return false. */
    if (isMinusZero(nx) && isZero(ny)) { return false };
    /* h. If nx is +Infinity, return false. */
    if (nx = Infinity) { return false };
    /* i. If ny is +Infinity, return true. */
    if (ny = Infinity) { return true };
    /* j. If ny is -Infinity, return false. */
    if (ny = -Infinity) { return false };
    /* k. If nx is -Infinity, return true. */
    if (nx = -Infinity) { return true };
    /* l. If the mathematical value of nx is less than the mathematical value of ny — note that these
          mathematical values are both finite and not both zero — return true. Otherwise, return false. */
    if (mathematicalValue(nx) < mathematicalValue(ny)) [
      "after-same: — note that these mathematical values are both finite and not both zero — "
    ] { return true };

    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  }
  /* 4. Else, both px and py are Strings */
  else ["after-same:, both <i>px</i> and <i>py</i> are Strings"] {
    /* a. If py is a prefix of px, return false. (A String value p is a prefix of String value q if q can be the
          result of concatenating p and some other String r. Note that any String is a prefix of itself, because r
          may be the empty String.) */
    /* b. If px is a prefix of py, return true. */
    /* c. Let k be the smallest nonnegative integer such that the character at position k within px is different
          from the character at position k within py. (There must be such a k, for neither String is a prefix of
          the other.) */
    /* d. Let m be the integer that is the code unit value for the character at position k within px. */
    /* e. Let n be the integer that is the code unit value for the character at position k within py. */
    /* f. If m < n, return true. Otherwise, return false. */

    if (px < py) { return true };

    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  }
};

/* 11.9 Equality Operators */
/* The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship
  named by the operator holds between its two operands.
  The EqualityExpressionNoIn productions are evaluated in the same manner as the EqualityExpression
  productions except that the contained EqualityExpressionNoIn and RelationalExpressionNoIn are evaluated
  instead of the contained EqualityExpression and RelationalExpression, respectively. */
function JS_Interpreter_Equality_Operators(e, scope) [
  "11.9",
  "",
  "",
  "Equality Operators"
] {
  match e with
  /* 11.9.1 The Equals Operator ( == ) */
  /* The production EqualityExpression : EqualityExpression == RelationalExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "==", left: EqualityExpression, right: RelationalExpression } [
    "11.9.1",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">==</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Equals Operator ( <span style=\"font-family: monospace\">==</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Return the result of performing abstract equality comparison rval == lval. (see 11.9.3). */
    return AbstractEqualityComparison(rval, lval)
  }
  /* 11.9.2 The Does-not-equals Operator ( != ) */
  /* The production EqualityExpression : EqualityExpression != RelationalExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "!=", left: EqualityExpression, right: RelationalExpression } [
    "11.9.2",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">!=</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Does-not-equals Operator ( <span style=\"font-family: monospace\">!=</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing abstract equality comparison rval == lval. (see 11.9.3). */
    r := AbstractEqualityComparison(rval, lval);
    /* 6. If r is true, return false. Otherwise, return true. */
    if (r = true) {
      return false
    };

    gen_wrapper ["before-same:Otherwise, "] {
      return true
    }
  }
  /* 11.9.4 The Strict Equals Operator ( === ) */
  /* The production EqualityExpression : EqualityExpression === RelationalExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "===", left: EqualityExpression, right: RelationalExpression } [
    "11.9.4",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">===</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Strict Equals Operator ( <span style=\"font-family: monospace\">===</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Return the result of performing the strict equality comparison rval === lval. (See 11.9.6) */
    return StrictEqualityComparison(rval, lval)
  }
  /* 11.9.5 The Strict Does-not-equal Operator ( !== ) */
  /* The production EqualityExpression : EqualityExpression !== RelationalExpression is evaluated as follows: */
  | { type: "BinaryExpression", operator: "!==", left: EqualityExpression, right: RelationalExpression } [
    "11.9.5",
    "",
    "<span class=\"nt\">RelationalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">RelationalExpression</span> <code class=\"t\">!==</code> <span class=\"nt\">ShiftExpression</span>",
    "",
    "The Strict Does-not-equal Operator ( <span style=\"font-family: monospace\">!==</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating EqualityExpression. */
    lref := JS_Interpreter_Expr(EqualityExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating RelationalExpression. */
    rref := JS_Interpreter_Expr(RelationalExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of performing strict equality comparison rval === lval. (See 11.9.6) */
    r := StrictEqualityComparison(rval, lval);
    /* 6. If r is true, return false. Otherwise, return true. */
    if (r = true) {
      return false
    };

    gen_wrapper ["before-same:Otherwise, "] {
      return true
    }
  }
  | default -> {
    return JS_Interpreter_Binary_Bitwise_Operators(e, scope)
  }
};

/* 11.9.3 The Abstract Equality Comparison Algorithm */
function AbstractEqualityComparison(x, y) [
  "11.9.3",
  "The comparison <var>x</var> == <var>y</var>, where <var>x</var> and <var>y</var> are values, produces <b>true</b> or
  <b>false</b>. Such a comparison is performed as follows:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE 1</span> Given the above definition of equality:</p></div>
  <ul><li>String comparison can be forced by: <code>\"\" + a == \"\" + b</code>.</li>
  <li>Numeric comparison can be forced by: <code>+a == +b</code>.</li>
  <li>Boolean comparison can be forced by: <code>!a == !b</code>.</li></ul>
  <div class=\"note\"><p><span class=\"nh\">NOTE 2</span> The equality operators maintain the following invariants:</p></div>
  <ul><li><code>A</code> <code>!=</code> <code>B</code> is equivalent to <code>!(A</code> <code>==</code> <code>B)</code>.</li>
  <li><code>A</code> <code>==</code> <code>B</code> is equivalent to <code>B</code> <code>==</code> <code>A</code>, except
  in the order of evaluation of <code>A</code> and <code>B</code>.</li></ul>
  <div class=\"note\"><p><span class=\"nh\">NOTE 3</span> The equality operator is not always transitive. For example, there might be two distinct
  String objects, each representing the same String value; each String object would be considered equal to the String value
  by the <code>==</code> operator, but the two String objects would not be equal to each other. For Example:</p></div>
  <ul><li><code>new String(\"a\")</code> <code>==</code> <code>\"a\"</code> and <code>\"a\"</code> <code>==</code>  <code>new
  String(\"a\")</code>are both <b>true</b>.</li>
  <li><code>new String(\"a\")</code> <code>==</code> <code>new String(\"a\")</code> is <b>false</b>.</li></ul>
  <div class=\"note\"><p><span class=\"nh\">NOTE 4</span> Comparison of Strings uses a simple equality test on sequences of code unit values.
  There is no attempt to use the more complex, semantically oriented definitions of character or string equality and
  collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the
  Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised
  form.</p></div>",
  "The Abstract Equality Comparison Algorithm"
] {
  /* The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as
     follows: */

  /* 1. If Type(x) is the same as Type(y), then */
  if (Type(x) = Type(y)) ["after-same:, then"] {
    /* a. If Type(x) is Undefined, return true. */
    if (Type(x) = "Undefined") {
      return true
    };
    /* b. If Type(x) is Null, return true. */
    if (Type(x) = "Null") {
      return true
    };
    /* c. If Type(x) is Number, then */
    if (Type(x) = "Number") ["after-same:, then"] {
      /* i. If x is NaN, return false. */
      if (x = NaN) { return false };
      /* ii. If y is NaN, return false. */
      if (y = NaN) { return false };
      /* iii. If x is the same Number value as y, return true. */
      if (sameNumber(x, y)) { return true };
      /* iv. If x is +0 and y is -0, return true. */
      if (isZero(x) && isMinusZero(y)) { return true };
      /* v. If x is -0 and y is +0, return true. */
      if (isMinusZero(x) && isZero(y)) { return true };
      /* vi. Return false. */
      return false
    };
    /* d. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same
          length and same characters in corresponding positions). Otherwise, return false. */
    if (Type(x) = "String") {
      if (sameSequenceOfCharacters(x, y)) {
        return true
      };
      gen_wrapper ["before-same:Otherwise, "] {
        return false
      }
    };
    /* e. If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false. */
    if (Type(x) = "Boolean") {
      if ((x = true && y = true) || (x = false && y = false)) {
        return true
      };
      gen_wrapper ["before-same:Otherwise, "] {
        return false
      }
    };
    /* f. Return true if x and y refer to the same object. Otherwise, return false. */
    if (sameObject(x, y)) {
      return true
    };
    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  };
  /* 2. If x is null and y is undefined, return true. */
  if ((x = 'null) && (y = 'undefined)) {
    return true
  };
  /* 3. If x is undefined and y is null, return true. */
  if ((x = 'undefined) && (y = 'null)) {
    return true
  };
  /* 4. If Type(x) is Number and Type(y) is String,
        return the result of the comparison x == ToNumber(y). */
  if ((Type(x) = "Number") && (Type(y) = "String")) {
    return AbstractEqualityComparison(x, ToNumber(y))
  };
  /* 5. If Type(x) is String and Type(y) is Number,
        return the result of the comparison ToNumber(x) == y. */
  if ((Type(x) = "String") && (Type(y) = "Number")) {
    return AbstractEqualityComparison(ToNumber(x), y)
  };
  /* 6. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y. */
  if (Type(x) = "Boolean") {
    return AbstractEqualityComparison(ToNumber(x), y)
  };
  /* 7. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). */
  if (Type(y) = "Boolean") {
    return AbstractEqualityComparison(x, ToNumber(y))
  };
  /* 8. If Type(x) is either String or Number and Type(y) is Object,
        return the result of the comparison x == ToPrimitive(y). */
  if (((Type(x) = "String") || (Type(x) = "Number")) && (Type(y) = "Object")) {
    return AbstractEqualityComparison(x, ToPrimitive(y, null))
  };
  /* 9. If Type(x) is Object and Type(y) is either String or Number,
        return the result of the comparison ToPrimitive(x) == y. */
  if ((Type(x) = "Object") && ((Type(y) = "String") || (Type(y) = "Number"))) {
    return AbstractEqualityComparison(ToPrimitive(x, null), y)
  };
  /* 10. Return false. */
  return false

  /* NOTE 1 Given the above definition of equality:
          * String comparison can be forced by: "" + a == "" + b.
          * Numeric comparison can be forced by: +a == +b.
          * Boolean comparison can be forced by: !a == !b. */

  /* NOTE 2 The equality operators maintain the following invariants:
          * A != B is equivalent to !(A == B).
          * A == B is equivalent to B == A, except in the order of evaluation of A and B. */

  /* NOTE 3 The equality operator is not always transitive. For example, there might be two distinct String objects, each
            representing the same String value; each String object would be considered equal to the String value by the == operator,
            but the two String objects would not be equal to each other. For Example:
          * new String("a") == "a" and "a" == new String("a")are both true.
          * new String("a") == new String("a") is false. */

  /* NOTE 4 Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to
            use the more complex, semantically oriented definitions of character or string equality and collating order defined in the
            Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as
            unequal. In effect this algorithm assumes that both Strings are already in normalised form. */
};

/* 11.9.6 The Strict Equality Comparison Algorithm */
function StrictEqualityComparison(x, y) [
  "11.9.6",
  "The comparison <var>x</var> === <var>y</var>, where <var>x</var> and <var>y</var> are values, produces <b>true</b> or
  <b>false</b>. Such a comparison is performed as follows:",
  "<div class=\"note\"><p><span class=\"nh\">NOTE</span> This algorithm differs from <a href=\"#sec-9.12\">the SameValue Algorithm (9.12)</a>
  in its treatment of signed zeroes and NaNs.</p></div>",
  "The Strict Equality Comparison Algorithm"
] {
  /* The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed
     as follows: */

  /* 1. If Type(x) is different from Type(y), return false. */
  if (!(Type(x) = Type(y))) { return false };
  /* 2. If Type(x) is Undefined, return true. */
  if (Type(x) = "Undefined") { return true };
  /* 3. If Type(x) is Null, return true. */
  if (Type(x) = "Null") { return true };
  /* 4. If Type(x) is Number, then */
  if (Type(x) = "Number") ["after-same:, then"] {
    /* a. If x is NaN, return false. */
    if (x = NaN) { return false };
    /* b. If y is NaN, return false. */
    if (y = NaN) { return false };
    /* c. If x is the same Number value as y, return true. */
    if (sameNumber(x, y)) { return true };
    /* d. If x is +0 and y is -0, return true. */
    if (isZero(x) && isMinusZero(y)) { return true };
    /* e. If x is -0 and y is +0, return true. */
    if (isMinusZero(x) && isZero(y)) { return true };
    /* f. Return false. */
    return false
  };
  /* 5. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and
        same characters in corresponding positions); otherwise, return false. */
  if (Type(x) = "String") {
    if (sameSequenceOfCharacters(x, y)) {
      return true
    };
    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  };
  /* 6. If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false. */
  if (Type(x) = "Boolean") {
    if ((x = true && y = true) || (x = false && y = false)) {
      return true
    };
    gen_wrapper ["before-same:Otherwise, "] {
      return false
    }
  };
  /* 7. Return true if x and y refer to the same object. Otherwise, return false. */
  if (sameObject(x, y)) {
    return true
  };
  gen_wrapper ["before-same:Otherwise, "] {
    return false
  }

  /* NOTE This algorithm differs from the SameValue Algorithm (9.12) in its treatment of signed zeroes and NaNs. */
};


/* 11.10 Binary Bitwise Operators */
function JS_Interpreter_Binary_Bitwise_Operators(e, scope) [
  "11.10",
  "",
  "",
  "Binary Bitwise Operators"
] {
  match e with
  /* The production A : A @ B, where @ is one of the bitwise operators in the productions above, is evaluated as follows: */
  | { type: "BinaryExpression", operator: operator, left: A, right: B } [
    "11.10.1",
    "",
    "<var>A</var> <b>:</b> <i><span style=\"font-family: Times New Roman\">A</span> @ <span style=\"font-family: Times New Roman\">B</span></i>,
    where @ is one of the bitwise operators in the productions above",
    "",
    null
  ] -> {
    /* 1. Let lref be the result of evaluating A. */
    lref := JS_Interpreter_Expr(A, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating B. */
    rref := JS_Interpreter_Expr(B, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let lnum be ToInt32(lval). */
    lnum := ToInt32(lval);
    /* 6. Let rnum be ToInt32(rval). */
    rnum := ToInt32(rval);
    /* 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer */
    return applyBitwiseOperator(operator, lnum, rnum)
  }
  | default -> {
    return JS_Interpreter_Binary_Logical_Operators(e, scope)
  }
};

/* 11.11 Binary Logical Operators */
function JS_Interpreter_Binary_Logical_Operators(LogicalExpression, scope) [
  "11.11",
  "",
  "The <span class=\"nt\">LogicalANDExpressionNoIn</span> and <span class=\"nt\">LogicalORExpressionNoIn</span> productions are evaluated in the same manner
  as the <span class=\"nt\">LogicalANDExpression</span> and <span class=\"nt\">LogicalORExpression</span> productions except that the contained
  <span class=\"nt\">LogicalANDExpressionNoIn</span>, <span class=\"nt\">BitwiseORExpressionNoIn</span> and <span class=\"nt\">LogicalORExpressionNoIn</span> are evaluated instead of
  the contained <span class=\"nt\">LogicalANDExpression</span>, <span class=\"nt\">BitwiseORExpression</span> and <span class=\"nt\">LogicalORExpression</span>, respectively.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> The value produced by a <code>&amp;&amp;</code> or <code>||</code> operator is not
  necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.</p></div>",
  "Binary Logical Operators"
] {
  match LogicalExpression with
  /* The production LogicalANDExpression : LogicalANDExpression && BitwiseORExpression is evaluated as follows: */
  | { operator: "&&", left: LogicalANDExpression, right: BitwiseORExpression } [
    "11.11.1",
    "",
    "<span class=\"nt\">LogicalANDExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LogicalANDExpression</span> <code class=\"t\">&amp;&amp;</code> <span class=\"nt\">BitwiseORExpression</span>",
    "",
    null
  ] -> {
    /* 1. Let lref be the result of evaluating LogicalANDExpression. */
    lref := JS_Interpreter_Expr(LogicalANDExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. If ToBoolean(lval) is false, return lval. */
    if (ToBoolean(lval) = false) {
      return lval
    };
    /* 4. Let rref be the result of evaluating BitwiseORExpression. */
    rref := JS_Interpreter_Expr(BitwiseORExpression, scope);
    /* 5. Return GetValue(rref). */
    return GetValue(rref)
  }
  /* The production LogicalORExpression : LogicalORExpression || LogicalANDExpression is evaluated as follows: */
  | { operator: "||", left: LogicalORExpression, right: LogicalANDExpression } [
    "11.11.2",
    "",
    "<span class=\"nt\">LogicalANDExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LogicalANDExpression</span> <code class=\"t\">||</code> <span class=\"nt\">BitwiseORExpression</span>",
    "",
    null
  ] -> {
    /* 1. Let lref be the result of evaluating LogicalORExpression. */
    lref := JS_Interpreter_Expr(LogicalORExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. If ToBoolean(lval) is true, return lval. */
    if (ToBoolean(lval) = true) {
      return lval
    };
    /* 4. Let rref be the result of evaluating LogicalANDExpression. */
    rref := JS_Interpreter_Expr(LogicalANDExpression, scope);
    /* 5. Return GetValue(rref). */
    return GetValue(rref)
  }
  | default -> {
    return JS_Interpreter_Conditional_Operator(LogicalExpression, scope)
  }
};

/* 11.12 Conditional Operator ( ? : ) */
function JS_Interpreter_Conditional_Operator(ConditionalExpression, scope) [
  "11.12",
  "",
  "The <span class=\"nt\">ConditionalExpressionNoIn</span> production is evaluated in the same manner as the <span class=\"nt\">ConditionalExpression</span> production except that the contained <span class=\"nt\">LogicalORExpressionNoIn</span>,
  <span class=\"nt\">AssignmentExpression</span> and <span class=\"nt\">AssignmentExpressionNoIn</span> are evaluated instead of the
  contained <span class=\"nt\">LogicalORExpression</span>, first <span class=\"nt\">AssignmentExpression</span> and second <span class=\"nt\">AssignmentExpression</span>, respectively.</p>
  <div class=\"note\"><p><span class=\"nh\">NOTE</span> The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in
  C and Java, which each allow the second subexpression to be an Expression but restrict the third expression to be a
  ConditionalExpression. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed
  by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.</p></div>",
  "Conditional Operator ( <span style=\"font-family: monospace\">? :</span> )"
] {
  match ConditionalExpression with
  /* The production ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression is evaluated as follows: */
  | { type: "ConditionalExpression", test: LogicalORExpression, consequent: firstAssignmentExpression, alternate: secondAssignmentExpression } [
    "11.12.1",
    "",
    "<span class=\"nt\">ConditionalExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LogicalORExpression</span> <code class=\"t\">?</code>
    <span class=\"nt\">AssignmentExpression</span> <code class=\"t\">:</code> <span class=\"nt\">AssignmentExpression</span>",
    "",
    null
  ] -> {
    /* 1. Let lref be the result of evaluating LogicalORExpression. */
    lref := JS_Interpreter_Expr(LogicalORExpression, scope);
    /* 2. If ToBoolean(GetValue(lref)) is true, then */
    if (ToBoolean(GetValue(lref)) = true) ["after-same:, then"] {
      /* a. Let trueRef be the result of evaluating the first AssignmentExpression. */
      trueRef := JS_Interpreter_Expr(firstAssignmentExpression, scope);
      /* b. Return GetValue(trueRef). */
      return GetValue(trueRef)
    }
    /* 3. Else */
    else {
      /* a. Let falseRef be the result of evaluating the second AssignmentExpression. */
      falseRef := JS_Interpreter_Expr(secondAssignmentExpression, scope);
      /* b. Return GetValue(falseRef). */
      return GetValue(falseRef)
    }

    /* The ConditionalExpressionNoIn production is evaluated in the same manner as the ConditionalExpression
       production except that the contained LogicalORExpressionNoIn, AssignmentExpression and AssignmentExpressionNoIn
       are evaluated instead of the contained LogicalORExpression, first AssignmentExpression and second AssignmentExpression, respectively. */

    /* NOTE The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java, which
            each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression.
            The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a
            conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression. */
  }
  | default -> {
    return JS_Interpreter_Assignment_Operators(ConditionalExpression, scope)
  }
};

/* 11.13 Assignment Operators */
/* The AssignmentExpressionNoIn productions are evaluated in the same manner as the AssignmentExpression
    productions except that the contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are evaluated
    instead of the contained ConditionalExpression and AssignmentExpression, respectively. */
function JS_Interpreter_Assignment_Operators(AssignmentExpression, scope) [
  "11.13",
  "The <span class=\"nt\">AssignmentExpressionNoIn</span> productions are evaluated in the same manner as the <span class=\"nt\">AssignmentExpression</span> productions except that
  the contained <span class=\"nt\">ConditionalExpressionNoIn</span> and <span class=\"nt\">AssignmentExpressionNoIn</span> are evaluated instead of the contained
  <span class=\"nt\">ConditionalExpression</span> and <span class=\"nt\">AssignmentExpression</span>, respectively",
  "",
  "Assignment Operators"
] {
  match e with
  /* 11.13.1 Simple Assignment ( = ) */
  /* The production AssignmentExpression : LeftHandSideExpression = AssignmentExpression is evaluated as follows: */
  | { type: "AssignmentExpression", operator: "=", left: LeftHandSideExpression, right: AssignmentExpression } [
    "11.13.1",
    "",
    "<span class=\"nt\">AssignmentExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LeftHandSideExpression</span> <code class=\"t\">=</code> <span class=\"nt\">AssignmentExpression</span>",
    "<div class=\"note\"><p><span class=\"nh\">NOTE</span> When an assignment occurs within <a href=\"#sec-10.1.1\">strict mode code</a>, its <span class=\"nt\">LeftHandSide</span>
    must not evaluate to an unresolvable reference. If it does a <b>ReferenceError</b>
    exception is thrown upon assignment. The <span class=\"nt\">LeftHandSide</span> also may not be a reference to a data
    property with the attribute value <span style=\"font-family: Times New Roman\">{[[Writable]]:<b>false</b>}</span>, to an
    accessor property with the attribute value <span style=\"font-family: Times New Roman\">{[[Set]]:<b>undefined</b>}</span>,
    nor to a non-existent property of an object whose [[Extensible]] internal property has the value <b>false</b>. In these
    cases a <b>TypeError</b> exception is thrown.</p></div>",
    "Simple Assignment ( <span style=\"font-family: monospace\">=</span> )"
  ] -> {
    /* 1. Let lref be the result of evaluating LeftHandSideExpression. */
    lref := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 3. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 4. Throw a SyntaxError exception if the following conditions are all true: */
      /* Type(lref) is Reference is true */
    if ((Type(lref) = "Reference") &&&
      /* IsStrictReference(lref) is true */
        (IsStrictReference(lref)) &&&
      /* Type(GetBase(lref)) is Environment Record */
        (Type(GetBase(lref)) = "EnvironmentRecord") &&&
      /* GetReferencedName(lref) is either "eval" or "arguments" */
        ((GetReferencedName(lref) = "eval") ||| (GetReferencedName(lref) = "arguments")))
      {
        throw SyntaxErrorConstructorInternal()
      };
    /* 5. Call PutValue(lref, rval). */
    PutValue(lref, rval);
    /* 6. Return rval. */
    return rval

  /* NOTE When an assignment occurs within strict mode code, its LeftHandSide must not evaluate to an unresolvable
          reference. If it does a ReferenceError exception is thrown upon assignment. The LeftHandSide also may not be a
          reference to a data property with the attribute value {[[Writable]]:false}, to an accessor property with the attribute value
          {[[Set]]:undefined}, nor to a non-existent property of an object whose [[Extensible]] internal property has the value false. In
          these cases a TypeError exception is thrown. */
  }
  | { type: "AssignmentExpression", operator: AssignmentOperator, left: LeftHandSideExpression, right: AssignmentExpression } [
    "11.13.2",
    "",
    "<span class=\"nt\">AssignmentExpression</span> <span class=\"geq\">:</span> <span class=\"nt\">LeftHandSideExpression</span> <span class=\"nt\">AssignmentOperator</span>
    <span class=\"nt\">AssignmentExpression</span></span> , where <span class=\"nt\">AssignmentOperator</span> is @<code>=</code> and @ represents one of the operators indicated above",
    "<div class=\"note\"><p><span class=\"nh\">NOTE</span> See NOTE <a hre=\"#sec-11.13.1\">11.13.1</a>.</p></div>",
    "Compound Assignment ( <span style=\"font-family: monospace\">op=</span> )"
  ] -> {
    /* 11.13.2 Compound Assignment ( op= ) */

    /* The production AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression, where
       AssignmentOperator is @= and @ represents one of the operators indicated above, is evaluated as follows: */

    /* 1. Let lref be the result of evaluating LeftHandSideExpression. */
    lref := JS_Interpreter_Expr(LeftHandSideExpression, scope);
    /* 2. Let lval be GetValue(lref). */
    lval := GetValue(lref);
    /* 3. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 4. Let rval be GetValue(rref). */
    rval := GetValue(rref);
    /* 5. Let r be the result of applying operator @ to lval and rval. */
    r := applyOperator(AssignmentOperator, lval, rval);
    /* 6. Throw a SyntaxError exception if the following conditions are all true: */
      /* Type(lref) is Reference is true */
    if ((Type(lref) = "Reference") &&
      /* IsStrictReference(lref) is true */
        (IsStrictReference(lref)) &&
      /* Type(GetBase(lref)) is Environment Record */
        (Type(GetBase(lref)) = "EnvironmentRecord") &&
      /* GetReferencedName(lref) is either "eval" or "arguments" */
        ((GetReferencedName(lref) = "eval") || (GetReferencedName(lref) = "arguments")))
      {
        throw SyntaxErrorConstructorInternal()
      };
    /* 7. Call PutValue(lref, r). */
    PutValue(lref, r);
    /* 8. Return r. */
    return r

    /* NOTE See NOTE 11.13.1. */
  }
  | default -> {
    return JS_Interpreter_Comma_Operator(AssignmentExpression, scope)
  }
};

/* 11.14 Comma Operator ( , ) */
function JS_Interpreter_Comma_Operator(Expression, scope) [
  "11.14",
  "",
  "",
  "Comma Operator ( <span style=\"font-family: monospace\">, )</span>"
] {
  match Expression with
  /* The production Expression : Expression , AssignmentExpression is evaluated as follows: */
  | { type: "SequenceExpression", expressions: Expressions } [
    "11.14.1",
    "",
    "<span class=\"nt\">Expression</span> <span class=\"geq\">:</span> <span class=\"nt\">Expression</span> <code class=\"t\">,</code> <span class=\"nt\">AssignmentExpression</span></span>",
    "The <span class=\"nt\">ExpressionNoIn</span> production is evaluated in the same manner as the <span class=\"nt\">Expression</span> production
    except that the contained <span class=\"nt\">ExpressionNoIn</span> and <span class=\"nt\">AssignmentExpressionNoIn</span> are evaluated instead of
    the contained <span class=\"nt\">Expression</span> and <span class=\"nt\">AssignmentExpression</span>, respectively.
    <div class=\"note\"><p><span class=\"nh\">NOTE</span> <a href=\"#sec-8.7.1\">GetValue</a> must be called even though its value is not used because
    it may have observable side-effects.</p></div>",
    null
  ] -> {
    gen_wrapper ["print_ignore"] {
      ret := strip_sequence_expression(Expressions);
      Expression := fst ret;
      AssignmentExpression := snd ret
    };
    /* 1. Let lref be the result of evaluating Expression. */
    lref := JS_Interpreter_Expr(Expression, scope);
    /* 2. Call GetValue(lref). */
    GetValue(lref);
    /* 3. Let rref be the result of evaluating AssignmentExpression. */
    rref := JS_Interpreter_Expr(AssignmentExpression, scope);
    /* 4. Return GetValue(rref). */
    return GetValue(rref)

    /* The ExpressionNoIn production is evaluated in the same manner as the Expression production except that the
        contained ExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained Expression and
        AssignmentExpression, respectively. */

    /* NOTE GetValue must be called even though its value is not used because it may have observable side-effects. */
  }
};


function JS_Interpreter_Stmt(s, scope) [
  "12",
  "",
  "",
  "Statements"
] {
  match s with
  | default -> {
    return JS_Interpreter_EmptyStatement(s, scope)
  }
};

function JS_Interpreter_EmptyStatement(EmptyStatement, scope) [
  "12.3",
  "",
  "",
  "Empty Statement"
] {
  match EmptyStatement with
  | { type: "EmptyStatement" } [
    "12.3.1",
    "",
    "<span class=\"nt\">EmptyStatement</span> <span class=\"geq\">:</span> <code class=\"t\">;</code></span>",
    "",
    null
  ] -> {
    return normalEmptyCompletion('empty)
  }
  | default -> {
    return JS_Interpreter_ExpressionStatement(EmptyStatement, scope)
  }
};

function JS_Interpreter_ExpressionStatement(ExpressionStatement, scope) [
  "12.4",
  "",
  "",
  "Expression Statement"
] {
  match ExpressionStatement with
  | { type: "ExpressionStatement", expression: Expression } [
    "12.4.1",
    "",
    "<span class=\"nt\">ExpressionStatement</span> <span class=\"geq\">:</span> <span class=\"grhsannot\">[lookahead ∉
    {<code class=\"t\">{</code>, <code class=\"t\">function</code>}]</span> <span class=\"nt\">Expression</span> <code class=\"t\">;</code></span>",
    "",
    null
  ] -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. Return (normal, GetValue(exprRef), empty). */
    return normalEmptyCompletion(GetValue(exprRef))
  }
  | default -> {
    return JS_Interpreter_IfStatement(ExpressionStatement, scope)
  }
};

/* 12.5 The if Statement */
/* Each else for which the choice of associated if is ambiguous shall be associated with the nearest possible
    if that would otherwise have no corresponding else. */
function JS_Interpreter_IfStatement(IfStatement, scope) [
  "12.5",
  "",
  "",
  "The <span style=\"font-family: monospace\">if</span> Statement"
] {
  match IfStatement with
  /* The production IfStatement : if ( Expression ) Statement is evaluated as follows: */
  | { type: "IfStatement", test: Expression, consequent: Statement, alternate: null } [
    "12.5.2",
    "",
    "<span class=\"nt\">IfStatement</span> <span class=\"geq\">:</span> <code class=\"t\">if</code> <code class=\"t\">(</code>
    <span class=\"nt\">Expression</span> <code class=\"t\">)</code> <span class=\"nt\">Statement</span></span>",
    "",
    null
  ] -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. If ToBoolean(GetValue(exprRef)) is false, return (normal, empty, empty). */
    if (ToBoolean(GetValue(exprRef)) = false) {
      return normalEmptyCompletion('empty)
    };
    /* 3. Return the result of evaluating Statement. */
    return JS_Interpreter_Stmt(Statement, scope)
  }
  /* The production IfStatement : if ( Expression ) Statement else Statement is evaluated as follows: */
  | { type: "IfStatement", test: Expression, consequent: Statement1, alternate: Statement2 } [
    "12.5.1",
    "",
    "<span class=\"nt\">IfStatement</span> <span class=\"geq\">:</span> <code class=\"t\">if</code> <code class=\"t\">(</code> <span class=\"nt\">Expression</span>
    <code class=\"t\">)</code> <span class=\"nt\">Statement</span> <code class=\"t\">else</code> <span class=\"nt\">Statement</span></span>",
    "",
    null
  ] [
    "Statement1:the first <i>Statement</i>",
    "Statement2:the second <i>Statement</i>"
  ] -> {
    /* 1. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 2. If ToBoolean(GetValue(exprRef)) is true, then */
    if (ToBoolean(GetValue(exprRef)) = true) ["after-same:, then"] {
      /* a. Return the result of evaluating the first Statement. */
      return JS_Interpreter_Stmt(Statement1, scope)
    }
    /* 3. Else, */
    else {
      /* a. Return the result of evaluating the second Statement. */
      return JS_Interpreter_Stmt(Statement2, scope)
    }
  }
  | default -> {
    return JS_Interpreter_IterationStatement(IfStatement, scope)
  }
};

function JS_Interpreter_IterationStatement(iterStmt, scope) [
  "12.6",
  "",
  "",
  "Iteration Statements"
] {
  match iterStmt with
  /* 12.6.1 The do-while Statement */
  | { type: "DoWhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } [
    "12.6.1",
    "",
    "<code>do</code> <span class=\"nt\">Statement</span> <code>while</code> <code>(</code> <span class=\"nt\">Expression</span> <code>);</code>",
    "",
    "The <span style=\"font-family: monospace\">do</span>-<span style=\"font-family: monospace\">while</span>"
  ] -> {
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Let iterating be true. */
    iterating := true;
    /* 3. Repeat, while iterating is true */
    repeat {
      /* a. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* b. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* c. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, return (normal, V, empty). */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      };
      /* d. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* e. If ToBoolean(GetValue(exprRef)) is false, set iterating to false. */
      if (ToBoolean(GetValue(exprRef)) = false) {
        iterating := false
      }
    } until iterating = false;
    /* 4. Return (normal, V, empty); */
    return normalEmptyCompletion(V)
  }
  /* 12.6.2 The while Statement */
  | { type: "WhileStatement", test: Expression, body: Statement, labelSet: currentLabelSet } [
    "12.6.2",
    "",
    "<span class=\"nt\">IterationStatement</span> <span class=\"geq\">:</span> <code class=\"t\">while</code> <code class=\"t\">(</code>
    <span class=\"nt\">Expression</span> <code class=\"t\">)</code> <span class=\"nt\">Statement</span></span>",
    "",
    "The <span style=\"font-family: monospace\">while</span> Statement"
  ] -> {
    /* 1. Let V = empty. */
    V := 'empty;
    /* 2. Repeat */
    repeat {
      /* a. Let exprRef be the result of evaluating Expression. */
      exprRef := JS_Interpreter_Expr(Expression, scope);
      /* b. If ToBoolean(GetValue(exprRef)) is false, return (normal, V, empty). */
      if (ToBoolean(GetValue(exprRef)) = false) {
        return normalEmptyCompletion(V)
      };
      /* c. Let stmt be the result of evaluating Statement. */
      stmt := JS_Interpreter_Stmt(Statement, scope) catch Interpreter_Statement_Guard;
      /* d. If stmt.value is not empty, let V = stmt.value. */
      if (!(getCompletionValue(stmt) = 'empty)) {
        V := getCompletionValue(stmt)
      };
      /* e. If stmt.type is not continue || stmt.target is not in the current label set, then */
      if (!(getCompletionType(stmt) = 'continue) || (!(getCompletionTarget(stmt) in_list currentLabelSet))) {
        /* i. If stmt.type is break and stmt.target is in the current label set, then */
        if ((getCompletionType(stmt) = 'break) && (getCompletionTarget(stmt) in_list currentLabelSet)) {
          /* 1. Return (normal, V, empty). */
          return normalEmptyCompletion(V)
        };
        /* ii. If stmt is an abrupt completion, return stmt. */
        if (isAnAbruptCompletion(stmt)) {
          return stmt
        }
      }
    }
  }
  /* TODO: */
  | { type: "ForStatement", init: Expr_or_VarDecl_or_Null } [
    "12.6.3",
    "",
    "",
    "",
    "The <span style=\"font-family: monospace\">for</span> Statement"
  ] -> {
    if (Expr_or_VarDecl_or_Null = null) {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope)
    };

    match Expr_or_VarDecl_or_Null with
    | { type: "VariableDeclaration" } -> {
      return JS_Interpreter_ForStmt_VarDecl(iterStmt, scope)
    }
    | default -> {
      return JS_Interpreter_ForStmt_Expr(iterStmt, scope)
    }
  }
  /* 12.6.4 The for-in Statement */
  /* TODO: */
  | { type: "ForInStatement", left: lhsExpr_or_VarDecl } [
    "12.6.4",
    "",
    "<span class=\"nt\">IterationStatement</span> <span class=\"geq\">:</span> <code class=\"t\">for</code> <code class=\"t\">(</code>
    <span class=\"nt\">LeftHandSideExpression</span> <code class=\"t\">in</code> <span class=\"nt\">Expression</span> <code class=\"t\">)</code> <span class=\"nt\">Statement</span></span>",
    "",
    "The <span style=\"font-family: monospace\">for</span>-<span style=\"font-family: monospace\">in</span> Statement"
  ] -> {
    match lhsExpr_or_VarDecl with
    | { type: "VariableDeclaration", kind: "var" } -> {
      /* production IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement */
      return JS_Interpreter_ForInStmt_VarDecl(iterStmt, scope)
    }
    | default -> {
      /* production IterationStatement : for ( LeftHandSideExpression in Expression ) Statement */
      return JS_Interpreter_ForInStmt_lhsExpr(iterStmt, scope)
    }
  }
  | default -> {
    return JS_Interpreter_ContinueStatement(iterStmt, scope)
  }
};

/* 12.7 The continue Statement */
function JS_Interpreter_ContinueStatement(ContinueStatement, scope) [
  "12.7",
  "",
  "",
  "The <span style=\"font-family: monospace\">continue</span> Statement"
] {
  match ContinueStatement with
  /* A ContinueStatement without an Identifier is evaluated as follows: */
  | { type: "ContinueStatement", label: null } [
    "12.7.1",
    "",
    "A <span class=\"nt\">ContinueStatement</span> without an <span class=\"nt\">Identifier</span>",
    "",
    null
  ] -> {
    /* 1. Return (continue, empty, empty). */
    return newCompletion('continue, 'empty, 'empty)
  }
  /* A ContinueStatement with the optional Identifier is evaluated as follows: */
  | { type: "ContinueStatement", label: Identifier } [
    "12.7.2",
    "",
    "A <span class=\"nt\">ContinueStatement</span> with the optional <span class=\"nt\">Identifier</span>",
    "",
    null
  ] -> {
    /* 1. Return (continue, empty, Identifier). */
    return newCompletion('continue, 'empty, Identifier.name)
  }
  | default -> {
    return JS_Interpreter_BreakStatement(ContinueStatement, scope)
  }
};

/* 12.8 The break Statement */
function JS_Interpreter_BreakStatement(BreakStatement, scope) [
  "12.8",
  "",
  "",
  "The <span style=\"font-family: monospace\">break</span> Statement"
] {
  match BreakStatement with
  /* A BreakStatement without an Identifier is evaluated as follows: */
  | { type: "BreakStatement", label: null } [
    "12.8.1",
    "",
    "A <span class=\"nt\">BreakStatement</span> without an <span class=\"nt\">Identifier</span>",
    "",
    null
  ] -> {
    /* 1. Return (break, empty, empty). */
    return newCompletion('break, 'empty, 'empty)
  }
  /* A BreakStatement with an Identifier is evaluated as follows: */
  | { type: "BreakStatement", label: Identifier } [
    "12.8.2",
    "",
    "A <span class=\"nt\">BreakStatement</span> with an <span class=\"nt\">Identifier</span>",
    "",
    null
  ] -> {
    /* 1. Return (break, empty, Identifier). */
    return newCompletion('break, 'empty, Identifier.name)
  }
  | default -> {
    return JS_Interpreter_ReturnStatement(BreakStatement, scope)
  }
};

/* 12.9 The return Statement */
function JS_Interpreter_ReturnStatement(ReturnStatement, scope) [
  "12.9",
  "",
  "",
  ""
] {
  match ReturnStatement with
  | { type: "ReturnStatement", argument: Expression } [
    "12.9.1",
    "",
    "A <span class=\"nt\">ReturnStatement</span>",
    "",
    null
  ] -> {
    /* 1. If the Expression is not present, return (return, undefined, empty). */
    if (Expression = null) {
      return newCompletion('return, 'undefined, 'empty)
    };
    /* 2. Let exprRef be the result of evaluating Expression. */
    exprRef := JS_Interpreter_Expr(Expression, scope);
    /* 3. Return (return, GetValue(exprRef), empty). */
    return newCompletion('return, GetValue(exprRef), 'empty)
  }
}
