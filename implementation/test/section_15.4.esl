import "test/section_8.10.esl";
import "test/section_8.12.esl";
import "test/section_9.esl";
import "test/section_15.11.esl";

/* This method is not supposed to be here. As soon 
   as it is placed in the right section, it should
   be replaced by an import of that section. */
function Type(V) {
  v_type := typeof V;
  if (v_type = __$Int) { return "Number" };
  if (v_type = __$Flt) { return "Number" };
  if (v_type = __$Bool) { return "Boolean" };
  if (v_type = __$Str) { return "String" };
  if (v_type = __$Obj) { return "Object" };
  if (v_type = __$List) { return "List" };
  if (v_type = __$Null) { return "Null" };
  if (v_type = __$Symbol) {
    if (V = 'undefined) { return "Undefined" };
    if (V = 'NaN) { return "Number" };
    if ((V = '+0) || (V = '-0)) { return "Number" };
    if ((V = '+Infinity) || (V = 'Infinity) || (V = '-Infinity)) { return "Number" }
  };
  if (v_type = __$Tuple) {
    ft := fst V;
    if (ft = "R") { return "Reference" };
    if (ft = "C") { return "Completion" }
  };

  throw SyntaxErrorException()
};

/**
 * 15.4 Array Objects
 *
 * Array objects give special treatment to a certain class of property names.
 * A property name P (in the form of a String value) is an array index if and
 * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
 * 2^32 − 1. A property whose property name is an array index is also called
 * an element. Every Array object has a length property whose value is always
 * a nonnegative integer less than 2^32. The value of the length property is
 * numerically greater than the name of every property whose name is an array
 * index; whenever a property of an Array object is created or changed, other
 * properties are adjusted as necessary to maintain this invariant.
 * Specifically, whenever a property is added whose name is an array index,
 * the length property is changed, if necessary, to be one more than the
 * numeric value of that array index; and whenever the length property is
 * changed, every property whose name is an array index whose value is not
 * smaller than the new length is automatically deleted. This constraint
 * applies only to own properties of an Array object and is unaffected by
 * length or array index properties that may be inherited from its prototypes.
 *
 * An object, O, is said to be sparse if the following algorithm returns true:
 *
 * 1. Let len be the result of calling the [[Get]] internal method of O with
 *    argument "length".
 * 2. For each integer i in the range 0≤i<ToUint32(len)
 *    a. Let elem be the result of calling the [[GetOwnProperty]] internal
 *       method of O with argument ToString(i).
 *    b. If elem is undefined, return true.
 * 3. Return false.
 */

/**
 * 15.4.2.1 new Array ( [ item0 [ , item1 [ , … ] ] ] ) # Ⓣ 
 * This description applies if and only if the Array constructor is given
 * no arguments or at least two arguments.
 */
function newArray(items) {
  arr := {
    /* The [[Prototype]] internal property of the newly constructed object
       is set to the original Array prototype object, the one that is the
       initial value of Array.prototype (15.4.3.1). */
    Prototype: null,
    /* The [[Extensible]] internal property of the newly constructed object
       is set to true. */
    Extensible: true,
    /* The [[Class]] internal property of the newly constructed object is
       set to "Array". */
    Class: "Array",
    Put: "Put",
    Get: "Get",
    HasProperty: "HasProperty",
    DefineOwnProperty: "DefineOwnPropertyArray",
    GetOwnProperty: "GetOwnProperty",
    Delete: "Delete"
  };

  i := 0;
  /* The length property of the newly constructed object is set to the
     number of arguments. */
  len := l_len items;
  arr.length := newDataPropertyDescriptor(int_to_float(len));

  /* The 0 property of the newly constructed object is set to item0
     (if supplied); the 1 property of the newly constructed object is set
     to item1 (if supplied); and, in general, for as many arguments as there
     are, the k property of the newly constructed object is set to argument k,
     where the first argument is considered to be argument number 0. These
     properties all have the attributes {[[Writable]]: true,
     [[Enumerable]]: true, [[Configurable]]: true}. */
  while (i < len) {
    i_str := int_to_string i;
    arr[i_str] := newDataPropertyDescriptor(l_nth (items, i));
    i := i + 1
  };

  return arr
};

/**
 * 15.4.4.4 Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )
 *
 * When the concat method is called with zero or more arguments item1, item2,
 * etc., it returns an array containing the array elements of the object
 * followed by the array elements of each argument in order.
 *
 * The following steps are taken:
 */
function concat(this, items) {
  /* 1. Let O be the result of calling ToObject passing the this value as the argument. */
  O := ToObject(this);
  /* 2. Let A be a new array created as if by the expression new Array() where
        Array is the standard built-in constructor with that name. */
  A := newArray([]);
  /* 3. Let n be 0. */
  n := int_to_float 0;

  /* 4. Let items be an internal List whose first element is O and whose subsequent elements
        are, in left to right order, the arguments that were passed to this function invocation. */
  items := l_prepend(O, items);

  /* 5. Repeat, while items is not empty */
  while (!(items = [])) {
    /* a. Remove the first element from items and let E be the value of the element. */
    E := hd items;
    items := tl items;
    
    /* b. If the value of the [[Class]] internal property of E is "Array", then */
    if (E.Class = "Array") {
      /* i. Let k be 0. */
      k := int_to_float 0;
      /* ii. Let len be the result of calling the [[Get]] internal method of E with argument "length". */
      len := {E.Get}(E, "length");

      /* iii. Repeat, while k < len */
      while (k < len) {
        /* 1. Let P be ToString(k). */
        P := ToString(k);
        /* 2. Let exists be the result of calling the [[HasProperty]] internal method of E with P. */
        exists := {E.HasProperty}(E, P);

        /* 3. If exists is true, then */
        if (exists = true) {
          /* a. Let subElement be the result of calling the [[Get]] internal method of E with argument P. */
          subElement := {E.Get}(E, P);
          /* b. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(n),
                Property Descriptor {[[Value]]: subElement, [[Writable]]: true, [[Enumerable]]: true,
                [[Configurable]]: true}, and false.*/
          descriptor := newDataPropertyDescriptorFull(subElement, true, true, true);
          {A.DefineOwnProperty}(A, ToString(n), descriptor, false)
        };

        /* 4. Increase n by 1. */
        n := n + 1;
        /* 5. Increase k by 1. */
        k := k + 1
      }
    }
    /* c. Else, E is not an Array */
    else {
      /* i. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(n),
            Property Descriptor {[[Value]]: E, [[Writable]]: true, [[Enumerable]]: true,
            [[Configurable]]: true}, and false. */
      descriptor := newDataPropertyDescriptorFull(E, true, true, true);
      {A.DefineOwnProperty}(A, ToString(n), descriptor, false);
      /* ii. Increase n by 1. */
      n := n + 1
    }
  };

  /* 6. Return A. */
  return A
};

/**
 * 15.4.5.1 [[DefineOwnProperty]] ( P, Desc, Throw )
 *
 * Array objects use a variation of the [[DefineOwnProperty]] internal method
 * used for other native ECMAScript objects (8.12.9).
 *
 * Assume A is an Array object, Desc is a Property Descriptor, and Throw is a
 * Boolean flag.
 *
 * In the following algorithm, the term “Reject” means “If Throw is true, then
 * throw a TypeError exception, otherwise return false.”
 *
 * When the [[DefineOwnProperty]] internal method of A is called with property
 * P, Property Descriptor Desc, and Boolean flag Throw, the following steps are
 * taken:
 */
function DefineOwnPropertyArray(A, P, Desc, Throw) {
  
  /* 1. Let oldLenDesc be the result of calling the [[GetOwnProperty]] internal
      method of A passing "length" as the argument. The result will never be
      undefined or an accessor descriptor because Array objects are created
      with a length data property that cannot be deleted or reconfigured. */
  oldLenDesc := {A.GetOwnProperty}(A, "length");

  /* 2. Let oldLen be oldLenDesc.[[Value]]. */
  oldLen := oldLenDesc;

  /* 3. If P is "length", then */
  if (P = "length") {
    /* a. If the [[Value]] field of Desc is absent, then */
    if (!("Value" in_obj Desc)) {
      /* i. Return the result of calling the default [[DefineOwnProperty]] internal
          method (8.12.9) on A passing "length", Desc, and Throw as arguments. */
      return DefineOwnProperty(A, "length", Desc, Throw)
    };
    /* b. Let newLenDesc be a copy of Desc. */
    newLenDesc := CopyDescriptor(Desc);
    /* c. Let newLen be ToUint32(Desc.[[Value]]). */
    newLen := ToUint32(Desc.Value);
    /* d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError
          exception.*/
    if (!(newLen = ToNumber(Desc.Value))) {
      throw RangeErrorException()
    };
    /* e. Set newLenDesc.[[Value]] to newLen. */
    newLenDesc.Value := newLen;
    /* f. If newLen ≥ oldLen, then */
    if (newLen >= oldLen) {
      /* i. Return the result of calling the default [[DefineOwnProperty]]
            internal method (8.12.9) on A passing "length", newLenDesc,
            and Throw as arguments. */
      return DefineOwnProperty(A, "length", newLenDesc, Throw)
    };
    /* g. Reject if oldLenDesc.[[Writable]] is false. */
    if (oldLenDesc.Writable = false) {
      Reject(Throw)
    };
    
    /* h. If newLenDesc.[[Writable]] is absent or has the value true,
          let newWritable be true. */
    if (!("Writable" in_obj newLenDesc) || newLenDesc.Writable = true) {
      newWritable := true
    }
    /* i. Else, */
    else {
      /* i. Need to defer setting the [[Writable]] attribute to false in
            case any elements cannot be deleted. */
      /* TODO ???*/
      /* ii. Let newWritable be false. */
      newWritable := false;
      /* iii. Set newLenDesc.[[Writable] to true. */
      newLenDesc.Writable := true
    };
    /* j. Let succeeded be the result of calling the default
          [[DefineOwnProperty]] internal method (8.12.9) on A passing
          "length", newLenDesc, and Throw as arguments. */
    succeeded := DefineOwnProperty(A, "length", newLenDesc, Throw);
    /* k. If succeeded is false, return false.. */
    if (succeeded = false) {
      return false
    };
    /* l. While newLen < oldLen repeat, */
    while (newLen < oldLen) {
      /* i. Set oldLen to oldLen – 1. */
      oldLen := oldLen - 1;
      /* ii. Let deleteSucceeded be the result of calling the
             [[Delete]] internal method of A passing ToString(oldLen)
             and false as arguments. */
      deleteSucceeded := {A.Delete}(A, ToString(oldLen), false);
      /* iii. If deleteSucceeded is false, then */
      if (deleteSucceeded = false) {
        /* 1. Set newLenDesc.[[Value] to oldLen+1. */
        newLenDesc.Value := oldLen + 1;
        /* 2. If newWritable is false, set newLenDesc.[[Writable] to false. */
        if (newWritable = false) {
          newLenDesc.Writable := false
        };
        /* 3. Call the default [[DefineOwnProperty]] internal method (8.12.9)
              on A passing "length", newLenDesc, and false as arguments. */
        DefineOwnProperty(A, "length", newLenDesc, false);
        /* 4. Reject. */
        Reject(Throw)
      }
    };
    /* m. If newWritable is false, then */
    if (newWritable = false) {
      /* i. Call the default [[DefineOwnProperty]] internal method (8.12.9)
            on A passing "length", Property Descriptor{[[Writable]]: false},
            and false as arguments. This call will always return true. */
      /*descriptor := newDataPropertyDescriptorFull(??, false, true, true); TODO*/
      /*DefineOwnProperty(A, "length", descriptor, false)*/
      throw "TODO"
    };
    /* n. Return true. */
    return true
  }
  /* 4. Else if P is an array index (15.4), then */
  else {
    if (IsArrayIndex(P)) {
      /* a. Let index be ToUint32(P). */
      index := ToUint32(P);
      /* b. Reject if index ≥ oldLen and oldLenDesc.[[Writable]] is false. */
      if (index >= oldLen && oldLenDesc.Writable = false) {
        Reject(Throw)
      };
      /* c. Let succeeded be the result of calling the default [[DefineOwnProperty]]
            internal method (8.12.9) on A passing P, Desc, and false as arguments. */
      succeeded := DefineOwnProperty(A, P, Desc, false);
      /* d. Reject if succeeded is false. */
      if (succeeded = false) {
        Reject(Throw)
      };
      /* e. If index ≥ oldLen */
      if (index >= oldLen) {
        /* i. Set oldLenDesc.[[Value]] to index + 1. */
        oldLenDesc.Value := index + 1;
        /* ii. Call the default [[DefineOwnProperty]] internal method (8.12.9)
              on A passing "length", oldLenDesc, and false as arguments. This
              call will always return true. */
        DefineOwnProperty(A, "length", oldLenDesc, false)
      };
      /* f. Return true. */
      return true
    }
  };
  /* 5. Return the result of calling the default [[DefineOwnProperty]] internal
        method (8.12.9) on A passing P, Desc, and Throw as arguments. */
  return DefineOwnProperty(A, P, Desc, Throw)
};

function IsArrayIndex(P) {
  i := ToUint32(P);
  return !(i = null)
};

function main() {
  arr1 := newArray([2, 3]);
  arr2 := newArray([4, 5]);
  arr := concat(arr1, [arr2]);
  return arr
}
